<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>經夠盃挑戰｜聖經經文快問快答</title>
    <link rel="canonical" href="https://topheart.github.io/bible-challenge/bible-challenge.html">
    <meta name="description" content="用遊戲認識聖經！三種難度、題庫範圍（舊約/新約/自選書卷）、經文罕見度（常見/冷門）任你搭配；完成關卡可上排行榜，支援本機與線上成績。">
    <meta name="theme-color" content="#6366f1">
    <link rel="manifest" href="./manifest.webmanifest">
    <link rel="icon" type="image/png" href="logo/logo1-light.png">
    <link rel="apple-touch-icon" href="logo/logo1-light.png">
    <!-- Open Graph / Twitter -->
    <meta property="og:type" content="website">
    <meta property="og:locale" content="zh_TW">
    <meta property="og:site_name" content="經夠盃挑戰">
    <meta property="og:url" content="https://topheart.github.io/bible-challenge/bible-challenge.html">
    <meta property="og:title" content="經夠盃挑戰｜聖經經文快問快答">
    <meta property="og:description" content="用遊戲認識聖經！三種難度、題庫範圍（舊約/新約/自選書卷）、經文罕見度（常見/冷門）任你搭配；完成關卡可上排行榜，支援本機與線上成績。">
    <meta property="og:image" content="https://topheart.github.io/bible-challenge/logo/logo1-light.png">
    <meta property="og:image" content="https://topheart.github.io/bible-challenge/logo/share-1200x630.svg">
    <meta property="og:image:alt" content="經夠盃挑戰遊戲縮圖">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="經夠盃挑戰｜聖經經文快問快答">
    <meta name="twitter:description" content="用遊戲認識聖經！三種難度、題庫範圍（舊約/新約/自選書卷）、經文罕見度（常見/冷門）任你搭配；完成關卡可上排行榜，支援本機與線上成績。">
    <meta name="twitter:image" content="https://topheart.github.io/bible-challenge/logo/logo1-light.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Preconnects for faster third-party fetches -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://kkbwoahtwfdirqsgyqda.supabase.co" crossorigin>
    <!-- Speed up Google Fonts fetch to reduce FOIT/FOUT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <!-- Fallback preloads for both logo/word variants to mitigate late paint on slow networks -->
    <link rel="preload" as="image" href="logo/logo1-light.png" imagesrcset="logo/logo1-light.png" />
    <link rel="preload" as="image" href="logo/logo2-light.png" imagesrcset="logo/logo2-light.png" />
    <link rel="preload" as="image" href="logo/logo1-dark.png" imagesrcset="logo/logo1-dark.png" />
    <link rel="preload" as="image" href="logo/logo2-dark.png" imagesrcset="logo/logo2-dark.png" />
    <link rel="preload" as="image" href="logo/word1-light.png" imagesrcset="logo/word1-light.png" />
    <link rel="preload" as="image" href="logo/word2-light.png" imagesrcset="logo/word2-light.png" />
    <link rel="preload" as="image" href="logo/word1-dark.png" imagesrcset="logo/word1-dark.png" />
    <link rel="preload" as="image" href="logo/word2-dark.png" imagesrcset="logo/word2-dark.png" />
    <script>
        // Pre-pick and preload startup images as early as possible to avoid late appearance on slow networks.
        (function(){
            try {
                var pick = Math.ceil(Math.random() * 4); // 1..4
                window.__startupPick = pick;
                var isDark = (pick === 1 || pick === 2);
                var base = 'logo/';
                var logoSrc = isDark
                    ? (pick === 1 ? base + 'logo1-light.png' : base + 'logo2-light.png')
                    : (pick === 3 ? base + 'logo1-dark.png'  : base + 'logo2-dark.png');
                var wordSrc = isDark
                    ? (pick === 1 ? base + 'word1-light.png' : base + 'word2-light.png')
                    : (pick === 3 ? base + 'word1-dark.png'  : base + 'word2-dark.png');
                window.__startupLogoSrc = logoSrc;
                window.__startupWordSrc = wordSrc;
                window.__startupIsDark = isDark;
                // Inject preload hints for the chosen pair
                var l1 = document.createElement('link');
                l1.rel = 'preload'; l1.as = 'image'; l1.href = logoSrc; l1.setAttribute('fetchpriority','high');
                document.head.appendChild(l1);
                var l2 = document.createElement('link');
                l2.rel = 'preload'; l2.as = 'image'; l2.href = wordSrc; l2.setAttribute('fetchpriority','high');
                document.head.appendChild(l2);
            } catch (e) { /* ignore */ }
        })();
    </script>
    <!-- Online leaderboard support (optional): Supabase client + user-provided config -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- If you create bible-challenge/leaderboard-config.js with your keys, it will be loaded next; this file may not exist locally, which is okay. -->
    <script src="leaderboard-config.js"></script>
    <style>
        * {
            font-family: 'Noto Sans TC', sans-serif;
        }

        

        /* Desktop: arrange verse/chapter lists horizontally (row, wrap) so buttons appear side-by-side */
        @media (min-width: 761px) {
            .verses-list, .chapter-list {
                display: flex !important;
                flex-direction: row !important;
                flex-wrap: wrap !important;
                gap: 0.75rem !important;
                align-items: flex-start !important;
                justify-content: center !important; /* center rows when fewer than 3 items or last row */
                padding-left: 0 !important;
                padding-right: 0 !important;
            }

            /* Desktop - make panel titles and lists more compact so content fits without scrolling */
            #verseTitle, #chapterTitle {
                /* reduce large letter-spacing used for stylistic titles to save horizontal/vertical space */
                letter-spacing: 0.06em !important;
                margin-bottom: 0.15rem !important;
                line-height: 1.02 !important;
                /* slightly reduce font-size on wide screens for denser layout while keeping readability */
                font-size: clamp(1.6rem, 1.8vw, 2.4rem) !important;
                white-space: nowrap !important; /* keep the short title on one line */
            }

            /* Slightly tighten spacing inside panels and lists on desktop */
            .panel { padding: 0.6rem !important; }
            .panel .panel-title { margin-bottom: 0.1rem !important; padding-top: 0.25rem !important; padding-bottom: 0.25rem !important; }
            .verses-list, .chapter-list { gap: 0.5rem !important; }

            /* Make verse / chapter cards slightly denser on desktop to reduce overall height */
            .verses-list .verse-card, .chapter-list .chapter-card { padding: 0.6rem 0.85rem !important; min-height: 48px !important; }

            /* Ensure cards keep their JS-assigned widths (w-48, w-56, etc.) and don't expand to full width */
            /* Force up to 3 items per row: each card gets ~1/3 width minus gaps and is centered by the parent */
            .verses-list .verse-card, .chapter-list .chapter-card {
                display: inline-flex !important;
                flex: 0 0 calc((100% - 1.5rem) / 3) !important; /* two gaps of 0.75rem => 1.5rem total */
                max-width: calc((100% - 1.5rem) / 3) !important;
                width: auto !important;
                padding: 0.75rem 1rem !important;
                box-sizing: border-box !important;
            }

            /* keep panel padding reasonable on desktop */
            .panel { padding: 1rem !important; }
        }

        /* Desktop: remove the pale focus outline for main menu buttons/options (mouse click effect)
           Keep keyboard focus-visible intact elsewhere; scope to #startScreen to avoid harming in-game accessibility. */
        @media (min-width: 761px) {
            #startScreen .cute-button:focus,
            #startScreen .cute-button:focus-visible,
            #startScreen .cute-button:active,
            #startScreen .difficulty-option:focus,
            #startScreen .range-option:focus {
                outline: none !important;
                outline-offset: 0 !important;
                /* keep the existing shadow instead of the pale outline */
                box-shadow: 0 8px 24px rgba(2,6,23,0.08) !important;
            }
        }

    /* Unified spacing for scoring remarks lines (denser) */
    .scoring-remarks > div { margin-bottom: 0.2rem; line-height: 1.05; }
    .scoring-remarks > div:last-child { margin-bottom: 0; }

        /* Also remove the pale focus outline on mobile start screen (same behavior across devices) */
        #startScreen .cute-button:focus,
        #startScreen .cute-button:focus-visible,
        #startScreen .cute-button:active,
        #startScreen .difficulty-option:focus,
        #startScreen .range-option:focus {
            outline: none !important;
            outline-offset: 0 !important;
            box-shadow: 0 8px 24px rgba(2,6,23,0.08) !important;
        }
        
        .cute-button {
            transition: all 0.3s ease;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .cute-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .cute-card {
            border-radius: 25px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.1);
            background-color: rgba(255, 255, 255, 1) !important;
        }
        
        .difficulty-option, .range-option {
            background-color: rgba(255, 255, 255, 1) !important;
        }
        /* stronger hover / active / selected emphasis for difficulty cards */
    .difficulty-option {
            transition: transform 0.22s ease, box-shadow 0.22s ease, border-color 0.18s ease;
        }
        .difficulty-option:hover {
            transform: translateY(-6px) scale(1.02);
            box-shadow: 0 18px 45px rgba(0,0,0,0.16) !important;
            z-index: 10;
        }
        .difficulty-option:active {
            transform: translateY(-2px) scale(0.995);
        }
        .difficulty-option.selected {
            transform: translateY(-4px) scale(1.03);
            box-shadow: 0 20px 50px rgba(0,0,0,0.18) !important;
            border-width: 4px !important;
        }
        .difficulty-option:focus {
            outline: 3px solid rgba(96,165,250,0.35);
            outline-offset: 4px;
        }

        /* Ensure selected difficulty/range buttons always show a 4px colored border (explicit) */
        #startScreen .difficulty-option.selected[data-difficulty="easy"] {
            border: 4px solid #16a34a !important; /* green-600 */
        }
        #startScreen .difficulty-option.selected[data-difficulty="normal"] {
            border: 4px solid #d97706 !important; /* yellow-600 */
        }
        #startScreen .difficulty-option.selected[data-difficulty="hard"] {
            border: 4px solid #dc2626 !important; /* red-600 */
        }

        /* range buttons */
        #startScreen .range-option.selected[data-range="all"] {
            border: 4px solid #7c3aed !important; /* purple-600 */
        }
        #startScreen .range-option.selected[data-range="testament"] {
            border: 4px solid #2563eb !important; /* blue-600 */
        }
        #startScreen .range-option.selected[data-range="custom"] {
            border: 4px solid #ea580c !important; /* orange-600 */
        }
        .difficulty-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem 0.5rem;
            align-items: center;
            font-size: 0.85rem; /* slightly smaller for compactness */
        }
        .difficulty-badges .rounded-full {
            padding: 0.2rem 0.5rem;
            white-space: nowrap;
            min-width: auto;
            text-align: center;
            line-height: 1.1;
        }

        /* Desktop: stack the pair label above the friendly description for clarity */
        @media (min-width: 768px) {
            #startScreen .difficulty-option .difficulty-badges {
                display: flex !important;
                flex-direction: column !important;
                align-items: center !important; /* center everything */
                justify-content: center !important;
                gap: 0.125rem !important; /* keep description lines tighter */
                text-align: center;
            }
            /* keep any pre-existing badge sizing sensible when stacked */
            #startScreen .difficulty-option .difficulty-badges .rounded-full {
                width: auto;
            }
            /* ensure the prominent pair label has its color preserved and is slightly bolder */
            #startScreen .difficulty-option .difficulty-badges > div:first-child {
                font-weight: 800; /* more prominent */
                font-size: 1.05rem; /* slightly larger */
                letter-spacing: 0.06em;
                margin-bottom: 0.5rem; /* increase space before the description */
            }
            /* all following lines (description lines) should be muted and slightly smaller */
            #startScreen .difficulty-option .difficulty-badges > div:not(:first-child) {
                color: rgba(31,41,55,0.72); /* default muted description */
                font-weight: 500;
                font-size: 0.95rem;
                line-height: 1.15;
            }

            /* color the description lines according to difficulty */
            #startScreen .difficulty-option[data-difficulty="easy"] .difficulty-badges > div:not(:first-child) {
                color: #047857; /* green-700 */
            }
            #startScreen .difficulty-option[data-difficulty="normal"] .difficulty-badges > div:not(:first-child) {
                color: #b45309; /* amber-700 */
            }
            #startScreen .difficulty-option[data-difficulty="hard"] .difficulty-badges > div:not(:first-child) {
                color: #b91c1c; /* red-700 */
            }
        }
        /* range-option styling for 出題範圍 (match difficulty card style; colors unchanged) */
        .range-option {
            transition: transform 0.22s ease, box-shadow 0.22s ease, border-color 0.18s ease;
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.6rem;
            min-height: 56px;
            padding: 0.6rem 0.9rem;
            overflow: hidden;
            text-align: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
        }
        .range-option .label {
            display: inline-block;
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 12rem;
            width: 100%;
            text-align: center;
            letter-spacing: 0.12em;
            word-spacing: 0.12em;
        }
        .range-option:hover {
            transform: translateY(-6px) scale(1.02);
            box-shadow: 0 18px 45px rgba(0,0,0,0.16) !important;
            z-index: 10;
        }

        /* Make range-option darken slightly on hover like the start button (desktop) */
        @media (hover: hover) and (pointer: fine) {
            #startScreen .range-option:hover {
                filter: brightness(0.94);
                transition: transform 0.22s ease, box-shadow 0.22s ease, filter 0.18s ease;
            }
            #startScreen .range-option:active {
                filter: brightness(0.90);
            }
        }
        .range-option:active {
            transform: translateY(-2px) scale(0.995);
        }
        .range-option.selected {
            transform: translateY(-4px) scale(1.03);
            box-shadow: 0 20px 50px rgba(0,0,0,0.18) !important;
            border-width: 4px !important;
        }
        .range-option:focus {
            outline: 3px solid rgba(96,165,250,0.35);
            outline-offset: 4px;
        }
        .range-badges { display: flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.35rem; }
        .range-badges .rounded-full { padding:0.35rem 0.6rem; font-size:0.85rem; }

        /* responsive: allow labels to wrap on very small screens */
        @media (max-width: 420px) {
            .range-option { min-height: 48px; padding: 0.6rem; }
            .range-option .label { white-space: normal; max-width: 100%; font-size: 0.95rem; letter-spacing: 0.08em; }
        }

    /* Hide the small mobile-only difficulty hints by default (desktop) */
    #startScreen .difficulty-option .difficulty-hint { display: none; }

        /* Normalize difficulty option sizes on small screens so each button appears equal */
        @media (max-width: 640px) {
            #startScreen .difficulty-option .text-3xl { font-size: 1.6rem !important; line-height: 1 !important; }
            #startScreen .difficulty-option .text-lg { font-size: 0.95rem !important; margin-top: 0.12rem !important; }
            #startScreen .difficulty-option { padding: 0.45rem 0.5rem !important; }
            /* Ensure the icon container is same size across options */
            #startScreen .difficulty-option > div > .col-span-1 { flex-basis: 44px !important; min-width:44px !important; display:flex; align-items:center; justify-content:center; }
            /* small hint under each difficulty button (visible on mobile compact layout) */
            #startScreen .difficulty-option .difficulty-hint { display: none; }
        }
        
        .verse-card {
            transition: all 0.3s ease;
            border-radius: 15px;
            cursor: pointer;
            position: relative; /* allow absolutely-positioned overlays like the ref label */
        }

        /* Easy-mode reference label: overlay at the bottom of the verse card without affecting layout */
        .verse-ref-label {
            position: absolute;
            right: 10px; /* 靠右一點 */
            bottom: 6px;
            /* subtle readable chip */
            background: rgba(255,255,255,0.75);
            -webkit-backdrop-filter: saturate(120%) blur(2px);
            backdrop-filter: saturate(120%) blur(2px);
            padding: 2px 8px;
            border-radius: 9999px;
            line-height: 1;
            pointer-events: none; /* decorative only */
            z-index: 5;
            white-space: nowrap;
            max-width: calc(100% - 1.4rem);
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 0 !important; /* ignore any margin classes when overlaid */
        }

        /* Mobile comfort adjustments */
    @media (max-width: 640px) {
            html, body { -webkit-text-size-adjust: 100%; }

            /* Bigger tappable buttons */
            .cute-button {
                padding: 0.9rem 1rem !important;
                min-height: 48px !important;
                font-size: 1rem !important;
                border-radius: 14px !important;
            }

            /* Slightly smaller card radius and lighter shadows for mobile performance */
            .cute-card {
                    border-radius: 12px !important;
                    box-shadow: 0 10px 30px rgba(16,24,40,0.06) !important;
            }

            /* Make modals full-screen and scrollable on small devices */
            #playerNameModal .cute-card,
            #clearLeaderboardModal .cute-card,
            #customBooksModal .cute-card,
            #confirmBackModal .cute-card {
                width: 100% !important;
                max-width: none !important;
                height: 100% !important;
                max-height: none !important;
                border-radius: 0 !important;
                margin: 0 !important;
                padding: 1rem !important;
                box-shadow: none !important;
                border-left: none !important;
                border-right: none !important;
                overflow-y: auto !important;
            }

            /* Reduce heavy decorative animations/particles on mobile only to protect performance */
            @media (max-width: 640px) {
                .confetti, .party-popper, .celebration-popup { display: none !important; }
            }

            /* Mobile: hide scoring details but provide a toggle to expand them */
            #scoringCard .scoring-body { display: block !important; }
            #toggleScoringBtn { display: none !important; }
            @media (max-width: 420px) {
                /* show compact, pretty toggle on very small screens */
                #toggleScoringBtn { 
                    display: inline-flex !important; align-items: center; gap: 6px;
                    background: linear-gradient(180deg, rgba(107,114,128,0.06), rgba(156,163,175,0.06)); /* gray-500 -> gray-400 */
                    border: 1px solid rgba(107,114,128,0.28); /* gray-500 */
                    padding: 6px 10px; border-radius: 9999px; color: #374151; /* gray-700 */ font-size: 0.88rem;
                    box-shadow: 0 8px 22px rgba(2,6,23,0.07);
                    -webkit-backdrop-filter: saturate(140%) blur(6px);
                    backdrop-filter: saturate(140%) blur(6px);
                    transition: background-color .18s ease, box-shadow .18s ease, transform .12s ease;
                }
                #toggleScoringBtn:active { transform: scale(0.985); }
                #toggleScoringBtn:focus-visible { outline: 3px solid rgba(107,114,128,0.28); outline-offset: 3px; }
                #toggleScoringBtn .chev { transition: transform .18s ease; font-size: .9em; opacity: .9; }
                #scoringCard:not(.scoring-open) .scoring-body { display: none !important; }
                #scoringCard.scoring-open #toggleScoringBtn { background: rgba(107,114,128,0.08) !important; }
                #scoringCard.scoring-open #toggleScoringBtn .chev { transform: rotate(180deg); }

                /* End modal: make closing-verse text smaller to reduce scrolling */
                #playerNameModal #closingVerseText { font-size: 0.98rem !important; line-height: 1.55 !important; }
                #playerNameModal #closingVerse { padding: 0.6rem !important; }
            }

            /* Slightly larger verse cards and touch area */
            .verse-card, .chapter-card {
                min-height: 64px;
                padding: 0.75rem;
            }

            /* unified button style for clarity */
            .cute-button {
                box-shadow: 0 8px 24px rgba(2,6,23,0.08) !important;
                transition: transform 160ms ease, box-shadow 160ms ease !important;
            }

            .cute-button:active {
                transform: translateY(1px) scale(0.998) !important;
                box-shadow: 0 6px 18px rgba(2,6,23,0.06) !important;
            }

            /* focus-visible for keyboard users on mobile (accessibility) */
            .cute-button:focus-visible {
                outline: 3px solid rgba(99,102,241,0.22) !important;
                outline-offset: 4px !important;
            }

            /* Restore thin pale borders for unselected difficulty/range options on mobile (overrides .cute-button { border: none !important }) */
            #startScreen .difficulty-option:not(.selected),
            #startScreen .range-option:not(.selected) {
                border-style: solid !important;
                border-width: 2px !important;
                /* keep the color provided by utility classes (border-*-300) so the pale tint remains */
            }

            /* Mobile: single-column game area and larger interactive regions (scoped to startScreen only) */
            #startScreen .grid, #startScreen .game-area, #startScreen .game-controls {
                display: block !important;
                width: 100% !important;
                padding: 0 0.5rem !important;
            }

        /* Mobile adjustments for difficulty cards: hide the '配對XX' label and simplify descriptions */
        @media (max-width: 640px) {
            /* hide the prominent pair label on mobile to save space */
            #startScreen .difficulty-option .difficulty-badges > div:first-child {
                display: none !important;
            }
            /* hide the first description line and keep only the concise final line */
            #startScreen .difficulty-option .difficulty-badges > div:nth-child(2) {
                display: none !important;
            }
            #startScreen .difficulty-option .difficulty-badges > div:nth-child(3) {
                display: block !important;
                font-size: 0.82rem !important; /* smaller on mobile */
                line-height: 1.15 !important;
                white-space: nowrap !important; /* keep single line */
                overflow: hidden !important;
                text-overflow: ellipsis !important;
            }
            /* ensure concise description colors follow difficulty */
            #startScreen .difficulty-option[data-difficulty="easy"] .difficulty-badges > div:nth-child(3) { color: #047857 !important; }
            #startScreen .difficulty-option[data-difficulty="normal"] .difficulty-badges > div:nth-child(3) { color: #b45309 !important; }
            #startScreen .difficulty-option[data-difficulty="hard"] .difficulty-badges > div:nth-child(3) { color: #b91c1c !important; }
        }

            /* Compact mobile: stack difficulty options vertically as thin horizontal strips (three rows)
               Each button is full-width, single row layout with icon on the left and label + hint on the right.
               This is mobile-only and does not affect desktop layout. */
            #startScreen .cute-card > .space-y-3 {
                display: flex !important;
                flex-direction: column !important;
                gap: 0.18rem !important; /* even smaller spacing between difficulty cards */
                align-items: stretch !important;
                justify-content: flex-start !important;
            }

            #startScreen .cute-card > .space-y-3 .difficulty-option {
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                justify-content: flex-start !important;
                width: 100% !important;
                padding: 0.3rem 0.6rem !important; /* slightly tighter internal padding */
                height: 56px !important;
                min-height: 56px !important;
                max-height: 56px !important;
                box-sizing: border-box !important;
                gap: 0.6rem !important; /* reduce inner gap */
                border-radius: 12px !important;
                box-shadow: 0 6px 18px rgba(0,0,0,0.05) !important;
            }

            /* keep compact badges visible in mobile strip layout */
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-badges {
                display: flex !important;
                gap: 0.2rem 0.4rem !important; /* a bit looser so 失誤/提示不會過近 */
            }
            /* Loosen the two visible lines (失誤/提示) */
            #difficultyCard .difficulty-badges > div {
                line-height: 1.18 !important;
                margin: 0 !important;
            }
            /* Add a touch more spacing before 提示 (third child; second is hidden on mobile) */
            #difficultyCard .difficulty-badges > div:nth-child(3) {
                margin-top: 0.1rem !important;
            }

            /* Layout the original grid children as horizontal content: left icon area and main label area */
            #startScreen .cute-card > .space-y-3 .difficulty-option .grid {
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                width: 100% !important;
                gap: 0.75rem !important;
            }

            /* left icon column — fixed width */
            #startScreen .cute-card > .space-y-3 .difficulty-option > .grid > .col-span-1 {
                flex: 0 0 52px !important;
                min-width: 52px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
            }

            /* main content area */
            #startScreen .cute-card > .space-y-3 .difficulty-option > .grid > .col-span-4 {
                flex: 1 1 auto !important;
                display: flex !important;
                flex-direction: column !important;
                align-items: flex-start !important;
                justify-content: center !important;
                padding-right: 0.5rem !important;
            }

            /* icon and label sizing for consistency */
            #startScreen .cute-card > .space-y-3 .difficulty-option .text-3xl { font-size: 1.4rem !important; line-height: 1 !important; }
            #startScreen .cute-card > .space-y-3 .difficulty-option .text-lg { font-size: 0.95rem !important; margin-top: 0 !important; }

            /* place the small hint inline under the label but keep it subtle */
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-hint {
                display: inline-block !important;
                font-size: 0.8rem !important;
                margin-top: 2px !important;
                opacity: 0.9 !important;
            }

            /* Mobile-only: show a large right-aligned difficulty hint (e.g., 配對經文) */
            #startScreen .difficulty-mobile-strip { display: none !important; }
            #startScreen .cute-card > .space-y-3 .difficulty-option .mobile-rarity { white-space: nowrap !important; }
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-hint {
                display: block !important;
                position: absolute !important;
                right: 0.85rem !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                margin: 0 !important;
                font-weight: 800 !important;
                letter-spacing: 0.08em !important;
                white-space: nowrap !important;
                text-align: right !important;
                max-width: 48% !important; /* prevent overflow on very small screens */
                /* responsive size: bigger on mobile but not overwhelming */
                font-size: clamp(1.05rem, 4.6vw, 1.35rem) !important;
                color: rgba(31,41,55,0.9) !important; /* default gray, overridden per difficulty below */
                text-shadow: 0 1px 0 rgba(255,255,255,0.6) !important;
                pointer-events: none !important;
                z-index: 32 !important;
            }
            /* Color the big hint to match each difficulty */
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="easy"] .difficulty-hint { color: #047857 !important; /* green-700 */ }
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="normal"] .difficulty-hint { color: #b45309 !important; /* amber-700 */ }
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="hard"] .difficulty-hint { color: #b91c1c !important; /* red-700 */ }

            /* Show the strip in the mobile stacked layout */
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-mobile-strip {
                display: block !important;
                width: 100% !important;
                padding: 0.45rem !important;
                border-radius: 12px !important;
                background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.4)) !important;
                box-shadow: 0 6px 18px rgba(2,6,23,0.04) !important;
            }

            /* ensure difficulty-option and its strip sit above nearby cute-card backgrounds on mobile */
            #startScreen .cute-card > .space-y-3 .difficulty-option {
                position: relative !important;
                z-index: 30 !important; /* above the parent cute-card but below modals */
                /* reserve space on the right for the big label 配對ＸＸ */
                padding-right: clamp(4.5rem, 28vw, 9rem) !important;
            }
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-mobile-strip {
                position: relative !important;
                z-index: 31 !important; /* make the strip visually above the tile edges */
            }

            /* adjust inner strip layout */
            #startScreen .difficulty-mobile-strip .mobile-strip-icon { width: 36px; display: inline-flex; align-items: center; justify-content: center; opacity: 0.95; }
            /* keep the original icon area visible */
            /* (previous override that hid .col-span-1 removed) */

            #startScreen .difficulty-mobile-strip .mobile-strip-content { display: flex; align-items: center; gap: 0.5rem; width: 100%; }
            #startScreen .difficulty-mobile-strip .mobile-strip-left { display: flex; flex-direction: column; }
            #startScreen .difficulty-mobile-strip .mobile-strip-right { display: flex; align-items: center; }

            /* per-difficulty strip tints (subtle) */
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="easy"] .difficulty-mobile-strip {
                background: linear-gradient(180deg, rgba(236,253,245,0.9), rgba(255,255,255,0.55)) !important;
            }
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="normal"] .difficulty-mobile-strip {
                background: linear-gradient(180deg, rgba(255,250,235,0.9), rgba(255,255,255,0.55)) !important;
            }
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="hard"] .difficulty-mobile-strip {
                background: linear-gradient(180deg, rgba(255,244,244,0.9), rgba(255,255,255,0.55)) !important;
            }

            /* better spacing for labels */
            #startScreen .difficulty-mobile-strip .mobile-label { font-size: 0.98rem !important; }
            #startScreen .difficulty-mobile-strip .mobile-hint { font-size: 0.78rem !important; color: rgba(31,41,55,0.65) !important; }
            #startScreen .difficulty-mobile-strip .mobile-rarity { font-size: 0.72rem !important; opacity: 0.95 !important; }

            /* On mobile, hide the middle badge line (配對經文/書卷/章節) to avoid duplication with the large right label */
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-badges > div:nth-child(2) { display: none !important; }

            /* ensure the cute-card itself doesn't force extra vertical stacking for difficulty area */
            #startScreen .cute-card.bg-white.p-6 { padding-bottom: 0.5rem !important; }

            /* Add vertical spacing between the white info cards on the start screen for better separation on mobile */
            #startScreen .cute-card {
                margin-bottom: 0.9rem !important;
            }

            /* Defensive: if the start screen is visible, ensure the game screen is hidden to avoid scrolling into it.
               Use the general sibling selector so the rule still applies when modals or other elements are between them. */
            #startScreen:not(.hidden) ~ #gameScreen {
                display: none !important;
                visibility: hidden !important;
                pointer-events: none !important;
            }

            /* Verse cards become full-width tappable rows */
            .verse-card {
                display: flex !important;
                align-items: center !important;
                justify-content: space-between !important;
                width: 100% !important;
                margin-bottom: 0.6rem !important;
                padding: 0.9rem !important;
                font-size: 1.05rem !important;
                touch-action: manipulation !important;
                /* reserve a little space at the bottom so the overlaid ref-label won't cover text */
                padding-bottom: calc(0.9rem + 1.1rem) !important;
            }

            /* Title container adjustments for small screens: allow wrapping and reduce spacing */
            .title-container {
                display: block !important;
                width: 100% !important;
                padding: 0.8rem 1rem !important;
                overflow: visible !important;
                border-radius: 12px !important;
            }

            /* Compact labels and improved button style for difficulty and range cards on mobile */
            #difficultyCard h2, #rangeCard h2 {
                font-size: 1.25rem !important;
                letter-spacing: 0.03em !important;
                margin-bottom: 0.6rem !important;
            }
            /* Make the range buttons visually tighter and unified on mobile */
            #rangeCard .range-option {
                padding: 0.6rem !important;
                border-radius: 12px !important;
                font-size: 0.95rem !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                gap: 0.5rem !important;
                box-shadow: 0 6px 18px rgba(2,6,23,0.04) !important;
            }

            /* differentiate the practice/testament options with subtle tint and smaller badges */
            #rangeCard .range-option .label { font-weight: 700 !important; }
            #rangeCard .range-option.selected { box-shadow: 0 10px 28px rgba(0,0,0,0.08) !important; transform: translateY(-2px) !important; }
            #rangeCard .range-option .label { padding: 0.2rem 0.4rem !important; border-radius: 8px !important; }

            #startScreen h1 {
                font-size: 1.6rem !important;
                line-height: 1.05 !important;
                letter-spacing: 0.04em !important;
                white-space: normal !important;
                text-shadow: 0 0 8px rgba(255,255,255,0.4) !important;
                padding: 0.1rem 0.2rem !important;
                display: block !important;
                word-break: keep-all !important;
            }

            /* make the little emoji icons slightly smaller to avoid wrapping issues */
            #titleLeftIcon, #titleRightIcon { font-size: 1.1rem !important; margin: 0 .25rem !important; }

            /* --- Mobile: force entire game screen to fit within one viewport --- */
            #gameScreen {
                height: 100vh !important;
                padding: 0.3rem !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: space-between !important;
                overflow: hidden !important;
            }

            /* Make the main content area grow to fill the available space so the carousel can use full height */
            #gameScreen > .max-w-7xl {
                margin: 0 !important;
                padding: 0.25rem !important;
                max-width: 100% !important;
                display: flex !important;
                flex-direction: column !important;
                flex: 1 1 auto !important;
                overflow: visible !important; /* allow score card rounded corners/shadow to show */
            }

            /* Let the carousel and panels grow to fill the middle area */
            .verses-carousel {
                flex: 1 1 auto !important;
                display: flex !important;
                overflow-x: auto !important;
            }
            .verses-carousel .panel {
                display: flex !important;
                flex-direction: column !important;
                height: 100% !important;
                overflow-y: auto !important; /* allow the content inside each panel to scroll vertically */
                padding-top: 0.4rem !important; /* reduce extra top space above titles */
                padding-bottom: 0.6rem !important; /* small internal bottom padding */
            }

            /* Ensure the lists inside panels have safe bottom padding so the last item is reachable above pinned controls */
            .verses-list, .chapter-list {
                padding-bottom: calc(4.5rem + env(safe-area-inset-bottom, 0px)) !important; /* provide space for pinned controls */
                overflow-y: auto !important;
            }

            /* Extra small spacer element at the end of lists if needed (keeps last card tappable) */
            .verses-list::after, .chapter-list::after { content: ''; display: block; height: 0.8rem; }

                /* Hide non-essential info on mobile to ensure the gameplay fits in one viewport.
                    Keep level & question progress, and the hint/back buttons visible per request. */
                #gameInfoSettings, #gameInfoCard {
                display: none !important;
                visibility: hidden !important;
                height: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
                overflow: hidden !important;
            }

            /* Ensure level progress card stays visible but compact */
            #levelProgressCard {
                display: block !important;
                padding: 0.5rem !important;
                margin-bottom: 0.35rem !important;
            }

            /* Save space: hide the level-progress heading row (icon + label), keep only the ovals */
            #levelProgressCard .flex.items-center { display: none !important; }
            #levelProgressCard #levelOvals { margin-top: 0 !important; }
            #levelProgressCard .flex.space-x-2 { gap: 0.35rem !important; }

            /* Ensure the ovals row is always visible and has a minimum height on small screens */
            #levelOvals { display: flex !important; min-height: 1.75rem !important; }

            /* Mobile: hide the question progress entirely (only keep level progress ovals) */
            #questionProgressCard { display: none !important; visibility: hidden !important; height: 0 !important; margin: 0 !important; padding: 0 !important; overflow: hidden !important; }

            /* Pin controls (hint + back) to the bottom for easy reach without hiding them */
            #gameControlsPinned {
                position: fixed !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                z-index: 9999 !important;
                padding: 0.5rem !important;
                background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.9)) !important;
                backdrop-filter: blur(6px) !important;
                box-shadow: 0 -6px 24px rgba(2,6,23,0.06) !important;
            }

            /* Keep hint and back buttons large and side-by-side inside the pinned controls */
            #gameControlsPinned .cute-button {
                width: 48% !important;
                display: inline-block !important;
                font-size: 1rem !important;
                padding: 0.7rem 0.9rem !important;
            }

            /* Mobile: make the hint/back buttons horizontal (icon + text inline), same-height and more compact */
            @media (max-width: 640px) {
                #gameControlsPinned { padding: 0.35rem !important; }
                #gameControlsPinned .cute-button {
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    flex-direction: row !important;
                    gap: 0.4rem !important;
                    height: 44px !important; /* uniform height */
                    padding: 0 0.6rem !important; /* horizontal padding only */
                    font-size: 0.95rem !important;
                    width: 48% !important;
                    white-space: nowrap !important;
                }

                /* Ensure the inline content inside the button stays on one line */
                #gameControlsPinned .cute-button > span { display: inline-flex !important; align-items: center !important; gap: 0.4rem !important; flex-direction: row !important; white-space: nowrap !important; }

                /* Shrink the hint-count badge to match button height */
                #hintCount {
                    height: 36px !important;
                    min-width: 36px !important;
                    padding: 0 0.6rem !important;
                    display: inline-flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    font-size: 0.88rem !important;
                }

                /* Slightly reduce pinned area vertical footprint */
                #gameControlsPinned { background: linear-gradient(180deg, rgba(255,255,255,0.66), rgba(255,255,255,0.92)) !important; }
            }

            /* Reduce margins around verse/chapter areas to save vertical space */
            .max-w-7xl.mx-auto.mb-6.relative.z-10 { margin-bottom: 0.5rem !important; padding: 0 !important; }
            .p-8.relative.overflow-hidden { padding: 0.5rem !important; }

            /* Reduce top info area and make it compact */
            #gameScreen > .max-w-7xl {
                margin: 0 !important;
                padding: 0.25rem !important;
                max-width: 100% !important;
            }

            /* compact the three-column header into a vertical stack that fits */
            #gameScreen .flex.items-center.justify-between.gap-6 {
                display: flex !important;
                flex-direction: column !important;
                gap: 0.5rem !important;
                align-items: stretch !important;
            }

            /* Reduce whitespace above panel titles and make titles compact */
            .panel-title { margin: 0.15rem 0 0.25rem 0 !important; padding: 0 !important; }
            .panel .mb-8 { margin-bottom: 0.3rem !important; }

            /* shrink score panel and allow it to scale responsively */
            #gameScreen .cute-card[style*="min-w"] {
                min-width: auto !important;
                padding: 0.6rem !important;
            }

            #centerScore {
                font-size: clamp(2.2rem, 10vw, 3.6rem) !important;
                line-height: 1 !important;
            }

            /* reduce progress card sizes and paddings */
            #gameScreen .cute-card.p-5, #gameScreen .cute-card.p-4 {
                padding: 0.5rem !important;
            }

            /* compress titles and verse/chapter areas */
            #verseTitle, #chapterTitle {
                font-size: clamp(1rem, 4.5vw, 1.4rem) !important;
                margin-bottom: 0.35rem !important;
                letter-spacing: 0.06em !important;
            }

            /* make verse and chapter containers smaller and ensure cards wrap compactly */
            #gameVerses, #gameChapters {
                gap: 6px !important;
                justify-content: center !important;
            }

            .verse-card {
                padding: 0.5rem !important;
                min-height: 44px !important;
                font-size: 0.95rem !important;
            }

            /* controls area pinned at bottom and easy to tap */
            #gameScreen .cute-card.bg-white\/60.rounded-xl.p-3.border {
                padding: 0.45rem !important;
            }

            /* ensure control buttons are large and full-width on mobile */
            .cute-card .cute-button, .cute-card button.cute-button {
                padding: 0.7rem 0.9rem !important;
                font-size: 1rem !important;
            }

            /* hide oversized decorative fixed icons to free space */
            #gameScreen .fixed.inset-0.pointer-events-none.z-0 { display: none !important; }

            /* reduce modal/popup sizes if they appear during gameplay */
            .cute-card.max-w-2xl { max-width: 92% !important; padding: 0.8rem !important; }

            /* Choice / answer buttons larger and more touch-friendly */
            .choice-button, .choice-btn, .answer-btn {
                width: 100% !important;
                display: block !important;
                padding: 0.95rem 1rem !important;
                font-size: 1.05rem !important;
                border-radius: 12px !important;
                margin-bottom: 0.6rem !important;
                touch-action: manipulation !important;
            }

            /* Ensure verse (question) and chapter (answer) cards follow the same sizing rule on mobile
               — full width, variable height for longer text, and consistent gap. */
            .verses-list .verse-card,
            .chapter-list .chapter-card {
                width: 100% !important;
                max-width: 100% !important;
                min-height: 44px !important; /* fixed min height; grows with content */
                display: block !important;
                margin-bottom: 0.6rem !important;
            }

            /* Start button full width and large on mobile */
            #startGameBtn {
                font-size: 1.25rem !important;
                padding: 1rem 1.25rem !important;
                border-radius: 14px !important;
            }

            /* Leaderboard: ensure comfortable spacing and readable font sizes */
            #leaderboardList > div { padding: 0; }
            #leaderboardList .bg-white { padding: 0.75rem !important; }

            /* Compact typography inside leaderboard cards to fit more info without changing card size */
            .leaderboard-compact .text-lg { line-height: 1.05 !important; }
            .leaderboard-compact .text-sm { line-height: 1 !important; }
            .leaderboard-compact .truncate { white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; }
            #leaderboardList .bg-white { display: flex; align-items: center; }

            /* remove hover-only effects that interfere with touch */
            .cute-button:hover, .difficulty-option:hover, .range-option:hover { transform: none !important; box-shadow: 0 6px 18px rgba(0,0,0,0.06) !important; }

            /* easier-to-tap leaderboard tabs */
            .leaderboard-tab { padding: 0.6rem 0.9rem; font-size: 0.95rem; }
        }

        /* Leaderboard cards — redesigned for clearer rank styling and responsiveness */
        /* Base card */
        #leaderboardList .leaderboard-card {
            position: relative;
            background: #ffffff;
            border: 2px solid #e5e7eb; /* gray-200 */
            border-radius: 14px;
            padding: 0.85rem 0.95rem; /* default padding (mobile-first) */
            box-shadow: 0 6px 18px rgba(0,0,0,0.06);
            transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
            display: block !important; /* override any generic .bg-white flex rules */
            overflow: hidden;
            will-change: transform;
            z-index: 0;
        }
        #leaderboardList .leaderboard-card:hover,
        #leaderboardList .leaderboard-card:focus-visible {
            transform: translateY(-6px);
            box-shadow: 0 16px 38px rgba(0,0,0,0.12);
            z-index: 5; /* raise above neighbors when lifted */
        }
        /* Click/press lift a bit more */
        #leaderboardList .leaderboard-card:active {
            transform: translateY(-8px);
            box-shadow: 0 18px 42px rgba(0,0,0,0.16);
            z-index: 6;
        }
        /* Rank ribbon (desktop) / chip (mobile) */
        #leaderboardList .leaderboard-card .lb-rank-ribbon {
            position: absolute;
            left: 0.5rem;
            top: 0.5rem;
            width: 2.6rem;
            height: calc(100% - 1rem);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            color: #111827; /* gray-900 */
            user-select: none;
        }
        #leaderboardList .leaderboard-card .lb-rank-ribbon span {
            writing-mode: horizontal-tb; /* keep numbers upright on desktop */
            transform: none;
            letter-spacing: 0.06em;
        }
        /* Content body */
        #leaderboardList .leaderboard-card .lb-card-body {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        @media (min-width: 640px) { /* sm+ add left padding to accommodate ribbon */
            #leaderboardList .leaderboard-card { padding-left: 3.75rem; }
        }
        #leaderboardList .leaderboard-card .lb-top-row { display: flex; align-items: baseline; gap: 0.5rem; }
        #leaderboardList .leaderboard-card .lb-score { font-size: 1.35rem; font-weight: 900; color: #111827; line-height: 1; }
        #leaderboardList .leaderboard-card .lb-score .unit { font-size: 0.7rem; font-weight: 600; margin-left: 2px; color: #6b7280; }
        #leaderboardList .leaderboard-card .lb-name { font-size: 0.95rem; font-weight: 700; color: #374151; min-width: 0; }
        #leaderboardList .leaderboard-card .lb-name .truncate { display: block; max-width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #leaderboardList .leaderboard-card .lb-meta { font-size: 0.72rem; color: #9ca3af; }
        #leaderboardList .leaderboard-card .lb-pill { font-size: 0.72rem; padding: 0.15rem 0.5rem; border-radius: 9999px; font-weight: 800; display: inline-block; }
    /* Leaderboard rarity pill colors follow rank color scheme (與名次色系一致) */
    #leaderboardList .leaderboard-card.rank-1 .lb-pill { background-color: #FDE68A; color: #1F2937; box-shadow: 0 1px 0 rgba(0,0,0,0.04); }
    #leaderboardList .leaderboard-card.rank-2 .lb-pill { background-color: #E5E7EB; color: #1F2937; box-shadow: 0 1px 0 rgba(0,0,0,0.04); }
    #leaderboardList .leaderboard-card.rank-3 .lb-pill { background-color: #FCD34D; color: #111827; box-shadow: 0 1px 0 rgba(0,0,0,0.04); }
    /* Darker bronze for '全部經文' chip under rank-3 to distinguish from gold */
    #leaderboardList .leaderboard-card.rank-3 .lb-pill.rarity-all { background-color: #D97706; color: #111827; border: 1px solid #B45309; }
    #leaderboardList .leaderboard-card.rank-default .lb-pill { background-color: #F3F4F6; color: #6B7280; }
        #leaderboardList .leaderboard-card .lb-medal { position: absolute; top: 0.4rem; right: 0.5rem; font-size: 1.15rem; line-height: 1; }

    /* Leaderboard swipe/slide container */
    /* Allow cards to float outside without being clipped */
    #leaderboardList { position: relative; overflow: visible; }
    .lb-slide { position: absolute; inset: 0; will-change: transform, opacity; transition: transform 360ms cubic-bezier(.2,.9,.2,1), opacity 240ms ease-out; }
    .lb-slide.lb-slide-static { position: relative; transition: none; transform: none; }
    /* Keep breakdown number and suffix on one line */
    .bd-right { white-space: nowrap; display: inline-flex; align-items: baseline; gap: 2px; }
    .bd-suffix { margin-left: 0.1em; }

        /* Rank themes (ribbon + subtle border accent) */
        #leaderboardList .leaderboard-card.rank-1 { border-color: #f59e0b; /* amber-600 */ }
        #leaderboardList .leaderboard-card.rank-2 { border-color: #9ca3af; /* gray-400 */ }
        #leaderboardList .leaderboard-card.rank-3 { border-color: #b45309; /* amber-800 */ }

        #leaderboardList .leaderboard-card.rank-1 .lb-rank-ribbon { background: linear-gradient(180deg,#fde68a,#f59e0b); color:#1f2937; box-shadow: 0 6px 16px rgba(245,158,11,.30); }
        #leaderboardList .leaderboard-card.rank-2 .lb-rank-ribbon { background: linear-gradient(180deg,#e5e7eb,#9ca3af); color:#1f2937; box-shadow: 0 6px 16px rgba(156,163,175,.25); }
        #leaderboardList .leaderboard-card.rank-3 .lb-rank-ribbon { background: linear-gradient(180deg,#fcd34d,#b45309); color:#111827; box-shadow: 0 6px 16px rgba(180,83,9,.22); }
        #leaderboardList .leaderboard-card.rank-default .lb-rank-ribbon { background: #f3f4f6; color:#6b7280; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.02); }

        /* Mobile: turn ribbon into a circular chip at the left */
        @media (max-width: 640px) {
            #leaderboardList .leaderboard-card { display: flex !important; align-items: center; padding-left: 0.95rem; }
            #leaderboardList .leaderboard-card .lb-rank-ribbon {
                position: static;
                width: 2.75rem; height: 2.75rem; border-radius: 9999px;
                margin-right: 0.75rem;
            }
            #leaderboardList .leaderboard-card .lb-rank-ribbon span { writing-mode: horizontal-tb; transform: none; letter-spacing: 0; font-size: 1.1rem; }
            #leaderboardList .leaderboard-card .lb-medal { top: 0.45rem; right: 0.55rem; }
        }

        /* Make selected state on mobile as prominent as desktop: thicker border + larger shadow */
        @media (max-width: 760px) {
            .difficulty-option.selected, .range-option.selected {
                transform: translateY(-4px) scale(1.03) !important; /* gentle lift */
                box-shadow: 0 20px 50px rgba(0,0,0,0.18) !important;
                border-width: 4px !important;
            }

            /* Ensure selected cards keep their colored border on mobile as JS adds color classes */
            .difficulty-option.selected.border-green-600 { border-color: #16a34a !important; }
            .difficulty-option.selected.border-yellow-600 { border-color: #d97706 !important; }
            .difficulty-option.selected.border-red-600 { border-color: #dc2626 !important; }

            .range-option.selected.border-purple-600 { border-color: #7c3aed !important; }
            .range-option.selected.border-blue-600 { border-color: #2563eb !important; }
            .range-option.selected.border-orange-600 { border-color: #ea580c !important; }
        }

        /* Respect reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            * { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; }
        }

        /* heading icon + label adjustments for range card titles */
        .heading-icon { display: inline-block; margin-right: 0.5rem; }
        .heading-label { letter-spacing: 0.18em; }

        /* Verses carousel styles are mobile-only. Keep desktop layout intact. */
        @media (max-width: 760px) {
            /* Verses carousel: two panels side-by-side on the x-axis. Mobile users can swipe between them. */
            .verses-carousel {
                display: flex;
                width: 100%;
                overflow-x: auto;
                scroll-snap-type: x mandatory;
                -webkit-overflow-scrolling: touch;
            }
            .verses-carousel .panel {
                flex: 0 0 100%; /* each panel takes full viewport width */
                scroll-snap-align: start;
                box-sizing: border-box;
                /* prevent inner horizontal scrolling - only the outer carousel should scroll horizontally */
                overflow-x: hidden !important;
                overflow-y: auto !important; /* vertical scrolling inside panel */
            }

            /* Ensure the lists inside panels are vertical stacks */
            .verses-list .verse-card,
            .chapter-list .chapter-card {
                width: 100% !important;
                max-width: 100% !important;
                display: block !important;
                padding: 0.9rem 1rem !important;
                box-shadow: 0 6px 18px rgba(14, 30, 37, 0.06);
                border-radius: 0.5rem;
                overflow-x: hidden !important; /* ensure card content doesn't create horizontal overflow */
                box-sizing: border-box !important;
            }

            /* Small spacing and larger tap targets on mobile */
            .verses-list,
            .chapter-list {
                display: flex;
                flex-direction: column;
                gap: 0.6rem;
                overflow-x: hidden !important; /* prevent nested horizontal scrolling */
                padding-left: 0.4rem !important; /* small inset so cards don't sit flush to panel edges */
                padding-right: 0.4rem !important;
                box-sizing: border-box !important;
            }

            /* Hide default scrollbar on supported browsers for a cleaner look */
            .verses-carousel::-webkit-scrollbar { height: 6px; }
            .verses-carousel::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); border-radius: 3px; }
        }
        
        .verse-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.12);
        }

        /* Ensure selected cards float above neighbors and are not clipped: use border+shadow highlight instead of scaling */
        .selected-verse {
            position: relative !important;
            z-index: 50 !important;
            transform: none !important;
            border-width: 3px !important;
            box-shadow: 0 12px 34px rgba(0,0,0,0.18) !important;
        }

        /* If a selected card sits inside an overflow-hidden container, allow its visible overflow within panels specifically */
        .panel .selected-verse {
            overflow: visible !important;
            box-shadow: 0 12px 34px rgba(0,0,0,0.18) !important;
        }

        /* General safety rules to avoid clipping on transforms */
        .verse-card, .chapter-card, .verse-card > div, .chapter-card > div {
            box-sizing: border-box !important;
            transform-origin: center center !important;
            -webkit-transform-origin: center center !important;
            will-change: transform, box-shadow !important;
        }

        /* Ensure inner text doesn't overflow when card is scaled */
        .verse-card > div, .chapter-card > div { overflow-wrap: break-word; word-break: break-word; }
        
        .chapter-card {
            transition: all 0.3s ease;
            border-radius: 15px;
            cursor: pointer;
        }
        
        .chapter-card:hover {
            transform: scale(1.05);
        }
        
        .hint-flash {
            animation: hintPulse 1s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
            border: 3px solid #FFD700 !important;
        }
        
        @keyframes hintPulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            }
        }

        /* encouragement pulse available globally; class only applied on mobile via media query */
        @keyframes encouragementPulseMobile {
            0% { transform: translate(-50%, -50%) scale(0.95); opacity: 0; }
            10% { transform: translate(-50%, -50%) scale(1.08); opacity: 1; }
            40% { transform: translate(-50%, -50%) scale(1.03); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        @-webkit-keyframes encouragementPulseMobile {
            0% { -webkit-transform: translate(-50%, -50%) scale(0.95); opacity: 0; }
            10% { -webkit-transform: translate(-50%, -50%) scale(1.08); opacity: 1; }
            40% { -webkit-transform: translate(-50%, -50%) scale(1.03); opacity: 1; }
            100% { -webkit-transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* when JS adds this class, the animation will run (kept global to avoid media-query quirks) */
        #encouragementText.mobile-pulse {
            animation: encouragementPulseMobile 700ms cubic-bezier(.2,.9,.2,1) 0s 1 both;
            -webkit-animation: encouragementPulseMobile 700ms cubic-bezier(.2,.9,.2,1) 0s 1 both;
        }

        /* inner span scale-only pulse (more reliable on mobile/webviews) */
        .encourage-inner { display: inline-block; transform-origin: center center; }
        @keyframes encourageInnerPulse {
            0% { transform: scale(0.96); }
            30% { transform: scale(1.12); }
            60% { transform: scale(1.04); }
            100% { transform: scale(1); }
        }
        @-webkit-keyframes encourageInnerPulse {
            0% { -webkit-transform: scale(0.96); }
            30% { -webkit-transform: scale(1.12); }
            60% { -webkit-transform: scale(1.04); }
            100% { -webkit-transform: scale(1); }
        }
        .encourage-inner.pulse {
            animation: encourageInnerPulse 700ms cubic-bezier(.2,.9,.2,1) 0s 1 both;
            -webkit-animation: encourageInnerPulse 700ms cubic-bezier(.2,.9,.2,1) 0s 1 both;
        }

        /* floating score popup animation */
        .score-popup {
            animation: scoreFloat 1.8s ease-out forwards;
        }

        /* downward sink for negative score popups */
        .score-popup.score-down {
            animation: scoreSink 1.8s ease-out forwards;
        }

        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-30px) scale(1.08); opacity: 1; }
            100% { transform: translateY(-60px) scale(1.2); opacity: 0; }
        }

        @keyframes scoreSink {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(30px) scale(0.96); opacity: 1; }
            100% { transform: translateY(60px) scale(0.92); opacity: 0; }
        }

        .celebration-popup {
            animation: celebrationFloat 2.2s ease-out forwards;
            text-shadow: 0 0 16px rgba(255, 255, 255, 0.9), 0 0 32px rgba(255, 255, 255, 0.5), 0 6px 12px rgba(255, 255, 255, 0.3) !important;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.9)) drop-shadow(0 6px 12px rgba(255, 255, 255, 0.3));
            /* ensure the text itself is centered and the box hugs content width */
            text-align: center;
            display: inline-block;
        }
        
        @keyframes celebrationFloat {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 1; }
            20% { transform: translate(-50%, -50%) translateY(-20px) scale(1.2); opacity: 1; }
            60% { transform: translate(-50%, -50%) translateY(-40px) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) translateY(-80px) scale(1.4); opacity: 0; }
        }
        
        .perfect-popup {
            animation: perfectFloat 4s ease-out forwards;
            text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 60px rgba(255, 255, 255, 0.8), 0 8px 16px rgba(255, 255, 255, 0.4) !important;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 1)) drop-shadow(0 8px 16px rgba(255, 255, 255, 0.4));
            /* ensure the text itself is centered and the box hugs content width */
            text-align: center;
            display: inline-block;
        }

        /* keep encouragement text out of document flow so it won't shift the score box */
    /* Legacy encouragement element is no longer used */
    #encouragementText { display: none !important; visibility: hidden !important; }

        /* Mobile tweaks: ensure the floating +score / encouragement text is visible
           above the pinned controls on small viewports. Use a fixed position so
           it won't be clipped/covered by the bottom control bar. */
        @media (max-width: 640px) {
            :root { --pinned-controls-height: 64px; }
            #encouragementText { display: none !important; visibility: hidden !important; }

            /* give the score card a little extra bottom padding so its internal
               progress bar / labels aren't accidentally clipped when the viewport
               is very tight. This is minimal and only on small screens. */
            .cute-card[style*="min-w-[320px]"] {
                padding-bottom: 4.5rem !important;
            }
                /* Mobile overlay badge that will be inserted into the two panel titles
                    or next to the main score. Use a dedicated center badge style for
                    positioning beside the gold score. */
                .mobile-score-badge {
                position: absolute;
                left: 50%;
                top: -1.6rem; /* float above the title text */
                transform: translateX(-50%);
                background: linear-gradient(90deg,#16a34a,#4ade80);
                color: white;
                padding: 6px 10px;
                border-radius: 999px;
                font-weight: 800;
                font-size: 0.95rem;
                line-height: 1;
                box-shadow: 0 6px 18px rgba(16,185,129,0.18), 0 2px 6px rgba(0,0,0,0.12);
                pointer-events: none;
                opacity: 0;
                transition: transform 420ms cubic-bezier(.2,.9,.2,1), opacity 420ms ease-out;
            }

            /* entrance/exit transforms */
            .mobile-score-badge.show {
                opacity: 1;
                transform: translateX(-50%) translateY(-6px) scale(1);
            }
            .mobile-score-badge.hide {
                opacity: 0;
                transform: translateX(-50%) translateY(-28px) scale(0.96);
            }
            /* ensure title containers can host absolute children */
            .panel .panel-front .panel-title,
            .panel .panel-back .panel-title,
            #verseTitle, #chapterTitle {
                position: relative;
                overflow: visible;
            }

            /* class applied when encouragement appears on mobile (rule moved to global scope for compatibility) */
            /* center score badge (places +/- value next to the large gold score) */
            .mobile-center-badge {
                position: absolute;
                right: -0.6rem; /* nudge slightly outside the score box */
                top: -0.45rem;
                transform: none;
                background: linear-gradient(90deg,#16a34a,#4ade80);
                color: white;
                padding: 4px 8px;
                border-radius: 999px;
                font-weight: 800;
                font-size: 1rem;
                line-height: 1;
                box-shadow: 0 6px 18px rgba(16,185,129,0.18), 0 2px 6px rgba(0,0,0,0.12);
                pointer-events: none;
                opacity: 0;
                transition: transform 260ms ease-out, opacity 260ms ease-out;
            }
            .mobile-center-badge.show { opacity: 1; transform: translateY(-4px); }
            .mobile-center-badge.hide { opacity: 0; transform: translateY(0); }
        }

    /* removed center golden halo behind the encouragement text to keep screen clean */
    #encouragementText::before { display: none !important; }
    #encouragementText:empty::before { display: none !important; }

        /* Platinum → Gold gradient text helper (used for encouragement text) */
        .platinum-gold-text {
            /* Stronger score-like gold: white → rich yellow → white, with wider gold band */
            background: linear-gradient(90deg,
                #ffffff 0%,
                #fff7d6 12%,   /* warm white */
                #ffe38a 28%,   /* soft gold */
                #ffd54d 45%,   /* mid gold (approx Tailwind amber/yellow) */
                #f6c629 55%,   /* deep gold core */
                #ffd54d 65%,   /* mid gold */
                #ffe38a 82%,   /* soft gold */
                #fff7d6 90%,   /* warm white */
                #ffffff 100%
            );
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* Platinum themed result card (match in-game dark score card) */
        .platinum-card {
            position: relative;
            background: linear-gradient(135deg, #334155 0%, #1f2937 55%, #0f172a 100%); /* slate-700 → slate-800 → slate-900 */
            border: 2px solid #475569; /* slate-600 */
            box-shadow:
                0 16px 40px rgba(0,0,0,0.35),
                inset 0 1px 0 rgba(255,255,255,0.06),
                inset 0 -1px 0 rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .platinum-card::after {
            /* subtle diagonal sheen with a hint of gold, tuned for dark bg */
            content: "";
            position: absolute;
            top: -40%;
            left: -20%;
            width: 80%;
            height: 180%;
            transform: rotate(20deg);
            background: linear-gradient(135deg,
                rgba(255,255,255,0.06) 0%,
                rgba(255,215,0,0.045) 25%,
                rgba(255,255,255,0.05) 55%,
                rgba(212,175,55,0.045) 85%,
                rgba(255,255,255,0.04) 100%
            );
            pointer-events: none;
            z-index: 0; /* keep sheen behind content */
        }
        /* ensure card content stays above the sheen */
        .platinum-card > * { position: relative; z-index: 1; }

        /* high-contrast helpers for dark card */
        .on-dark-strong { color: rgba(255,255,255,0.98) !important; }
        .on-dark-medium { color: rgba(255,255,255,0.88) !important; }
        .on-dark-subtle { color: rgba(255,255,255,0.80) !important; }
        .text-on-dark-glow { text-shadow: 0 1px 0 rgba(0,0,0,0.35); }

        /* subtle vertical divider for the platinum card center */
        .platinum-divider {
            width: 1.5px;
            height: 56px;
            background: linear-gradient(to bottom,
                rgba(255,255,255,0.08) 0%,
                rgba(255,215,0,0.14) 50%,
                rgba(255,255,255,0.08) 100%
            );
            box-shadow: 0 0 10px rgba(255,255,255,0.08);
            border-radius: 8px;
        }
        .final-score-xl { font-size: clamp(2.4rem, 8vw, 3.25rem); line-height: 1; }
        .final-score-shadow { text-shadow: 0 0 22px rgba(255,255,255,0.85), 0 0 36px rgba(255,255,255,0.55); }
        
        @keyframes perfectFloat {
            0% { transform: translate(-50%, -50%) scale(0.5) rotate(0deg); opacity: 1; }
            15% { transform: translate(-50%, -50%) translateY(-15px) scale(1.3) rotate(10deg); opacity: 1; }
            30% { transform: translate(-50%, -50%) translateY(-30px) scale(1.1) rotate(-5deg); opacity: 1; }
            70% { transform: translate(-50%, -50%) translateY(-50px) scale(1.2) rotate(5deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) translateY(-100px) scale(1.5) rotate(0deg); opacity: 0; }
        }
        
        @keyframes sparkleEffect {
            0% { 
                transform: translate(-50%, -50%) scale(0) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.5) rotate(180deg); 
                opacity: 1; 
            }
            100% { 
                transform: translate(-50%, -50%) scale(0.5) rotate(360deg); 
                opacity: 0; 
            }
        }
        
        @keyframes confettiEffect {
            0% { 
                transform: translateY(0) scale(1) rotate(0deg); 
                opacity: 1; 
            }
            100% { 
                transform: translateY(-80px) scale(0.8) rotate(720deg); 
                opacity: 0; 
            }
        }

        /* Lightweight score particle sprites that appear near the large center score
           Now using a sparkle/star glyph and white->gold color palette. Animation duration
           doubled per user request but travel distance remains controlled by --dx/--dy.
        */
        .score-particle {
            position: fixed;
            pointer-events: none;
            z-index: 10003;
            will-change: transform, opacity;
            opacity: 1;
            transform-origin: center center;
            display: inline-block;
            line-height: 1;
            font-weight: 700;
            animation: scoreParticleMove 1400ms cubic-bezier(.2,.9,.2,1) forwards;
        }

        @keyframes scoreParticleMove {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0.6) rotate(0deg);
            }
            60% {
                opacity: 1;
                transform: translate(var(--dx, 0px), var(--dy, -28px)) scale(1.05) rotate(90deg);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--dx, 0px) * 1.2), calc(var(--dy, -28px) * 1.4)) scale(0.8) rotate(180deg);
            }
        }

        /* Confetti rain pieces (colorful ribbons) */
    .confetti-piece {
            position: fixed;
            pointer-events: none;
            z-index: 10005;
            will-change: transform, opacity;
            width: 10px;
            height: 16px;
            border-radius: 2px;
            opacity: 1;
            transform-origin: center center;
            animation: confettiFallLinear 5600ms cubic-bezier(.2,.8,.2,1) forwards;
        }

        @keyframes confettiFallLinear {
            0% { transform: translateY(-6vh) rotate(0deg) translateX(0); opacity: 1; }
            60% { opacity: 1; }
            100% { transform: translateY(110vh) rotate(540deg) translateX(var(--conf-x, 0px)); opacity: 0; }
        }

        /* Gold glitter: small shimmering particles that fall/sparkle */
        .gold-glitter {
            position: fixed;
            pointer-events: none;
            z-index: 10006;
            color: #FFD700;
            text-shadow: 0 0 6px rgba(255,215,0,0.9), 0 0 14px rgba(255,240,200,0.45);
            font-weight: 800;
            font-size: 10px;
            will-change: transform, opacity;
            opacity: 1;
            animation: goldGlitterFall 2000ms ease-out forwards;
        }

        @keyframes goldGlitterFall {
            0% { transform: translateY(0) scale(0.85) rotate(0deg); opacity: 1; }
            60% { opacity: 1; }
            100% { transform: translateY(140px) scale(0.6) rotate(180deg); opacity: 0; }
        }
        
    /* medal badge backgrounds & readable text colors */
    .medal-gold { background: linear-gradient(135deg,#D69E2E,#FFD700); color: #111827; box-shadow: 0 2px 6px rgba(214,158,46,0.2); }
    .medal-silver { background: linear-gradient(135deg,#9CA3AF,#C0C0C0); color: #111827; box-shadow: 0 2px 6px rgba(156,163,175,0.12); }
    .medal-bronze { background: linear-gradient(135deg,#b36b2a,#CD7F32); color: #ffffff; box-shadow: 0 2px 6px rgba(205,127,50,0.18); }
    .medal-default { background: #e5e7eb; color: #6b7280; }
    /* Rank header styles for the end-game modal */
    .rank-header { display:inline-flex; align-items:center; gap:0.6rem; justify-content:center; }
    .rank-badge { width:40px; height:40px; border-radius:9999px; display:inline-flex; align-items:center; justify-content:center; font-weight:800; font-size:1rem; }
    .rank-title { font-weight:900; font-size:1.15rem; background:linear-gradient(90deg,#7c3aed,#ec4899); -webkit-background-clip:text; background-clip:text; color:transparent; }
    .rank-gold .rank-badge { background: linear-gradient(135deg,#D69E2E,#FFD700); color:#111827; box-shadow:0 4px 14px rgba(214,158,46,0.18); }
    .rank-silver .rank-badge { background: linear-gradient(135deg,#9CA3AF,#C0C0C0); color:#111827; box-shadow:0 4px 12px rgba(156,163,175,0.12); }
    .rank-bronze .rank-badge { background: linear-gradient(135deg,#b36b2a,#CD7F32); color:#fff; box-shadow:0 4px 12px rgba(205,127,50,0.14); }
    .rank-default .rank-badge { background:#e5e7eb; color:#6b7280; }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .score-flash {
            animation: scoreFlash 1.5s ease-in-out;
        }
        
        @keyframes scoreFlash {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .score-animate {
            animation: scoreShow 2s ease-out forwards;
        }
        
        @keyframes scoreShow {
            0% { opacity: 1; transform: translateX(0); }
            70% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(20px); }
        }
        

        
        /* 數字計數動畫 */
        .counting-animation {
            animation: countingPulse 0.1s ease-in-out;
        }
        
        @keyframes countingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* --- Compact modal styles for score/finish modal --- */
        /* Keep the finish modal compact and consistent across desktop and mobile. */
        #playerNameModal .cute-card {
            max-width: 760px !important;
            width: min(92%, 760px) !important;
            padding: 1rem !important; /* reduced outer padding */
            box-sizing: border-box !important;
        }

        #playerNameModal .cute-card h2, #playerNameModal .cute-card h3, #playerNameModal .cute-card h4 {
            line-height: 1.04 !important;
            margin-bottom: 0.35rem !important;
        }

        #playerNameModal .cute-card .bg-white\/70 {
            padding: 0.6rem !important; /* reduce inner panel padding */
        }

        /* Closing verse: auto-size on desktop to avoid overlapping the reference line; keep text clamped to 2 lines */
        #closingVerse {
            max-height: none !important;
            overflow: visible !important;
            text-overflow: clip !important;
            white-space: normal !important;
            padding: 0.5rem !important;
            margin-bottom: 0.45rem !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: stretch !important;
            justify-content: flex-start !important;
            gap: 0.25rem !important;
        }

        /* Helper for clamping the closing verse text (2 lines) */
        .closing-verse-clamp {
            display: -webkit-box !important;
            -webkit-line-clamp: 2 !important;
            -webkit-box-orient: vertical !important;
            line-clamp: 2 !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }

        /* Compact name input and buttons inside modal */
        #playerNameModal input#playerNameInput { padding: 0.6rem !important; font-size: 0.96rem !important; }
        #playerNameModal #confirmNameBtn { padding: 0.7rem 0.9rem !important; font-size: 1rem !important; }
        #playerNameModal .cute-button.w-full { margin-bottom: 0.35rem !important; }

        #replaySameQuestionsBtn { padding: 0.5rem 0.6rem !important; font-size: 0.95rem !important; }
        #sameReplayNote { margin-top: 0.35rem !important; font-size: 0.85rem !important; }

        @media (max-width: 640px) {
            /* Mobile: allow inner content to scroll and keep action footer sticky/visible */
            #playerNameModal .cute-card {
                padding: 0.9rem !important;
                max-height: 90vh !important;
                overflow: visible !important; /* allow body to scroll while footer stays sticky */
                border-radius: 1rem !important; /* stronger rounded corners on mobile */
                box-shadow: 0 18px 40px rgba(6,21,38,0.16) !important;
            }
            /* Show full closing verse on mobile */
            #closingVerse { max-height: none !important; overflow: visible !important; }
            .closing-verse-clamp { -webkit-line-clamp: unset !important; line-clamp: unset !important; }
            /* Restore internal scrolling so sticky footer stays visible while content scrolls */
            #playerNameModal .modal-body {
                -webkit-overflow-scrolling: touch !important;
                overflow-y: auto !important;
                max-height: calc(90vh - 88px) !important; /* reserve space for footer */
                padding-bottom: calc(0.75rem + env(safe-area-inset-bottom, 0px)) !important;
                touch-action: manipulation !important;
            }
            /* Sticky footer with safe-area support */
            #playerNameModal .modal-footer {
                position: sticky !important;
                bottom: env(safe-area-inset-bottom, 0px) !important;
                z-index: 70 !important;
                pointer-events: auto !important;
                background: linear-gradient(to top, rgba(255,255,255,0.96), rgba(255,255,255,0.78) 60%, rgba(255,255,255,0)) !important;
                padding-top: 0.25rem !important;
                padding-bottom: calc(0.35rem + env(safe-area-inset-bottom, 0px)) !important;
                backdrop-filter: saturate(140%) blur(6px);
            }
            #playerNameModal .modal-footer button.cute-button { padding: 0.78rem 0.9rem !important; font-size: 1.02rem !important; }
        }

        /* 倒數數字輕微上下浮動效果 */
        @keyframes countdownFloat {
            0% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
            100% { transform: translateY(0); }
        }

        .countdown-float {
            animation: countdownFloat 1.2s ease-in-out infinite;
        }
        
        .hint-blink {
            animation: hintBlink 1s ease-in-out infinite;
        }
        
        @keyframes hintBlink {
            0%, 50% { background-color: #fbbf24; }
            51%, 100% { background-color: #f59e0b; }
        }
        
        .shake-error {
            animation: shakeError 0.6s ease-in-out;
        }
        
        @keyframes shakeError {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-14px); }
            20%, 40%, 60%, 80% { transform: translateX(14px); }
        }
        
        .start-button-pulse {
            animation: startButtonPulse 1s ease-in-out 5;
        }
        
        @keyframes startButtonPulse {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.05);
            }
        }
        
        .game-instruction {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 193, 7, 0.95);
            color: #856404;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            z-index: 1000;
            animation: instructionFade 15s ease-in-out;
            border: 2px solid rgba(255, 193, 7, 0.8);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
            text-shadow: none;
        }
        
        @keyframes instructionFade {
            0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
        
        @keyframes instructionFadeOut {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
        
        @keyframes instructionEnhanced {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5) rotate(-5deg); 
                filter: blur(5px);
            }
            10% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1) rotate(2deg); 
                filter: blur(0px);
            }
            15% { 
                transform: translate(-50%, -50%) scale(1) rotate(0deg); 
            }
            85% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1) rotate(0deg); 
                filter: blur(0px);
            }
            95% { 
                opacity: 0.3; 
                transform: translate(-50%, -50%) scale(0.9) rotate(-2deg); 
                filter: blur(2px);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.7) rotate(-5deg); 
                filter: blur(5px);
            }
        }
        
        /* 慶祝彩帶動畫 */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f39c12;
            animation: confetti-fall 3s linear infinite;
        }
        
        .confetti:nth-child(odd) {
            background: #e74c3c;
            width: 8px;
            height: 8px;
            animation-duration: 2.5s;
        }
        
        .confetti:nth-child(even) {
            background: #3498db;
            width: 6px;
            height: 6px;
            animation-duration: 3.5s;
        }
        
        .confetti:nth-child(3n) {
            background: #2ecc71;
            width: 12px;
            height: 12px;
            animation-duration: 2.8s;
        }
        
        .confetti:nth-child(4n) {
            background: #9b59b6;
            width: 9px;
            height: 9px;
            animation-duration: 3.2s;
        }
        
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        /* 拉炮效果 */
        .party-popper {
            position: absolute;
            font-size: 4rem;
            animation: party-pop 2s ease-out;
        }
        
        @keyframes party-pop {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.2) rotate(180deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(360deg);
                opacity: 0.8;
            }
        }
        
        .selected-verse {
            border-width: 4px !important;
            transform: scale(1.05);
        }
        
        .selected-verse.bg-blue-50 {
            border-color: #1d4ed8 !important;
            box-shadow: 0 10px 25px rgba(29, 78, 216, 0.3);
        }
        
        .selected-verse.bg-yellow-100 {
            border-color: #d97706 !important;
            box-shadow: 0 10px 25px rgba(217, 119, 6, 0.3);
        }
        
        .selected-verse.bg-orange-100 {
            border-color: #ea580c !important;
            box-shadow: 0 10px 25px rgba(234, 88, 12, 0.3);
        }
        
        .hint-reminder {
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(255, 193, 7, 0.95);
            color: #856404;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            z-index: 100;
            animation: hintReminder 2s ease-in-out;
            border: 1px solid rgba(255, 193, 7, 0.8);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }
        
        @keyframes hintReminder {
            0%, 100% { opacity: 0; transform: translateY(10px); }
            20%, 80% { opacity: 1; transform: translateY(0); }
        }
        
        /* 背景經文跑馬燈效果 */
        .verse-marquee {
            position: fixed;
            /* expand container and rotate so lines move diagonally (counter-clockwise -45deg) */
            top: -25%;
            left: -25%;
            width: 150%;
            height: 150%;
            pointer-events: none;
            z-index: 0;
            overflow: visible; /* allow entries from outside viewport */
            transform: rotate(-45deg);
            transform-origin: 50% 50%;
        }
        
        .verse-text {
            position: absolute;
            white-space: nowrap;
            font-size: 4.5rem;
            font-weight: 800;
            color: rgba(139, 69, 19, 0.08);
            animation: marquee-horizontal 25s linear infinite;
            transform-origin: center;
            letter-spacing: 0.3rem;
            opacity: 1;
            text-shadow: 0 0 20px rgba(0,0,0,0.05);
            /* keep line spacing consistent even if font-size varies (halved as requested) */
            line-height: 3.5rem;
        }

        /* Mobile: show a lightweight marquee instead of fully disabling */
        @media (max-width: 640px) {
            .verse-marquee { display: block !important; opacity: 0.6; }
        }
        
        @keyframes marquee-horizontal {
            0% {
                /* start well outside the right edge */
                transform: translateX(calc(100vw + 300px));
                opacity: 0.0;
            }
            6% {
                opacity: 1;
            }
            94% {
                opacity: 1;
            }
            100% {
                /* end well past the left edge */
                transform: translateX(calc(-100vw - 300px));
                opacity: 0.0;
            }
        }
        
        .verse-text:nth-child(1) {
            top: 5%;
            color: rgba(107, 114, 128, 0.12);
        }
        
        .verse-text:nth-child(2) {
            top: 18%;
            color: rgba(75, 85, 99, 0.12);
        }
        
        .verse-text:nth-child(3) {
            top: 31%;
            color: rgba(156, 163, 175, 0.12);
        }
        
        .verse-text:nth-child(4) {
            top: 44%;
            color: rgba(139, 69, 19, 0.12);
        }
        
        .verse-text:nth-child(5) {
            top: 57%;
            color: rgba(120, 113, 108, 0.12);
        }
        
        .verse-text:nth-child(6) {
            top: 70%;
            color: rgba(99, 102, 241, 0.12);
        }
        
        .verse-text:nth-child(7) {
            top: 83%;
            color: rgba(168, 85, 247, 0.12);
        }
        

        </style>
        <style>
            /* Cute hint bar shared styles */
            .cute-hint { 
                display: none; align-items: center; gap: .5rem; 
                position: fixed; left: 50%; transform: translateX(-50%) translateY(24px);
                bottom: 12px; opacity: 0;
                max-width: 56rem; width: max-content; 
                padding: .6rem .9rem; border-radius: 9999px; 
                border: 2px solid; background: white; 
                box-shadow: 0 10px 30px rgba(2,6,23,.1);
                font-weight: 700; letter-spacing: .02em; z-index: 1000;
                pointer-events: none; /* do not block clicks */
                transition: opacity .2s ease, transform .2s ease;
                white-space: nowrap !important; /* keep hint in a single line */
                overflow: hidden !important; /* clip overflow on small screens */
                text-overflow: ellipsis !important;
            }
            .cute-hint.show { opacity: 1; transform: translateX(-50%) translateY(0); }
            .cute-hint .cute-hint-icon { font-size: 1.1rem; }
            .cute-hint .cute-hint-text { font-size: .95rem; color: #334155; white-space: nowrap !important; }
            /* Neutralize the cute icon for a more professional tone */
            .cute-hint .cute-hint-icon { display: inline-block !important; margin-right: 2px; }
            /* theme colors */
            .cute-hint.green { border-color: #86efac; background: #f0fdf4; }
            .cute-hint.green .cute-hint-text { color: #065f46; }
            .cute-hint.amber { border-color: #fcd34d; background: #fffbeb; }
            .cute-hint.amber .cute-hint-text { color: #92400e; }
            .cute-hint.red { border-color: #fca5a5; background: #fef2f2; }
            .cute-hint.red .cute-hint-text { color: #991b1b; }
            .cute-hint.purple { border-color: #c4b5fd; background: #faf5ff; }
            .cute-hint.purple .cute-hint-text { color: #6b21a8; }
            .cute-hint.blue { border-color: #93c5fd; background: #eff6ff; }
            .cute-hint.blue .cute-hint-text { color: #1d4ed8; }
            /* mobile fit */
            @media (max-width: 640px) {
                .cute-hint { 
                    max-width: calc(100% - 1rem); width: auto; 
                    transform: translateX(-50%) translateY(24px); 
                    /* keep hint bar above pinned controls and safe-area */
                    bottom: calc(var(--pinned-controls-height, 64px) + env(safe-area-inset-bottom, 0px) + 8px);
                    padding: .55rem .8rem; border-width: 2px; border-radius: 16px; 
                }
                .cute-hint .cute-hint-text { font-size: .9rem; }
            }
        </style>
        <style>
            /* === 問題卡片 進/出/掉落 動畫 === */
            @keyframes cardEnterRight {
                0% { opacity: 0; transform: translateX(calc(var(--enterX, 120px) * 4)) translateY(var(--enterY, 0px)) rotate(var(--enterR, 0deg)) scale(0.98); filter: blur(1px); }
                100% { opacity: 1; transform: translateX(0) translateY(0) rotate(0deg) scale(1); filter: blur(0); }
            }
            .card-enter {
                animation: cardEnterRight var(--enterDur, 620ms) cubic-bezier(.2,.9,.2,1) var(--enterDelay, 0ms) both;
                will-change: transform, opacity, filter;
            }
            @keyframes cardExitLeft {
                to { opacity: 0; transform: translateX(calc((-160px - var(--exitX, 0px)) * 4)) translateY(var(--exitY, 0px)) rotate(var(--exitR, -6deg)); filter: blur(1px); }
            }
            .card-exit { 
                animation: cardExitLeft var(--exitDur, 520ms) cubic-bezier(.2,.9,.2,1) var(--exitDelay, 0ms) forwards;
                will-change: transform, opacity, filter;
            }
            @keyframes fallScatter {
                to { opacity: 0; transform: translateX(var(--fx, 0px)) translateY(var(--fy, 260px)) rotate(var(--fr, 24deg)) scale(0.98); filter: blur(1.5px); }
            }
            .card-fall-scatter { 
                animation: fallScatter var(--fallDur, 900ms) cubic-bezier(.2,.8,.2,1.05) var(--fallDelay, 0ms) forwards;
                will-change: transform, opacity, filter;
            }
            /* Correct pop feedback without conflicting with slide animations */
            @keyframes correctPop { 0% { transform: scale(1); } 30% { transform: scale(1.06); } 100% { transform: scale(1); } }
            .correct-pop { animation: correctPop 420ms cubic-bezier(.2,.9,.2,1) 0ms 1 both; }
        </style>
        <style>
        /* Startup overlay: subtle shimmer for loading text */
        @keyframes loadingShimmer {
            0%   { text-shadow: 0 0 8px rgba(255,255,255,0.30); opacity: 0.92; }
            50%  { text-shadow: 0 0 16px rgba(255,255,255,0.65); opacity: 1.00; }
            100% { text-shadow: 0 0 8px rgba(255,255,255,0.30); opacity: 0.92; }
        }
        #startupOverlay .loading-shimmer { animation: loadingShimmer 2s ease-in-out infinite; }
    /* Simple fade-in for startup elements */
    @keyframes softFadeIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    #startupOverlay .fade-in-1 { opacity: 0; animation: softFadeIn 1.2s ease-out .1s forwards; }
    #startupOverlay .fade-in-2 { opacity: 0; animation: softFadeIn 1.4s ease-out .25s forwards; }
    #startupOverlay .fade-in-3 { opacity: 0; animation: softFadeIn 1.6s ease-out .4s forwards; }
        /* Startup overlay theme backgrounds */
        #startupOverlay.theme-light {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 35%, #dbeafe 70%, #bfdbfe 100%);
        }
        #startupOverlay.theme-dark {
            background: linear-gradient(135deg, #1f2937 0%, #273244 40%, #334155 100%);
        }
        /* Use a stable system font for all startup overlay text to prevent webfont swap jumps */
        #startupOverlay {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang TC", "Microsoft JhengHei", "Heiti TC", "PMingLiU", sans-serif !important;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-variant-ligatures: none;
            font-feature-settings: "liga" 0, "clig" 0;
        }
        /* Optional startup logo sizing */
        #startupOverlay #startupLogo {
            max-width: clamp(420px, 60vw, 960px);
            max-height: clamp(240px, 45vh, 420px);
            width: auto; height: auto;
            margin-bottom: 14px;
            filter: drop-shadow(0 8px 18px rgba(0,0,0,0.18));
            opacity: 0.98;
            user-select: none;
            -webkit-user-drag: none;
        }
    /* Version at top-right */
    #startupOverlay #startupVersion { top: 14px !important; right: 16px !important; bottom: auto !important; }
        /* Bottom-left wordmark */
        #startupOverlay #startupWord {
            position: absolute; left: calc(env(safe-area-inset-left, 0px) + 0px); bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
            width: auto; height: auto; max-width: clamp(210px, 42vw, 540px); max-height: 30vh;
            filter: drop-shadow(0 6px 14px rgba(0,0,0,0.18));
            opacity: 0.95; pointer-events: none; user-select: none; -webkit-user-drag: none;
        }
        /* Word2 variants follow the same bottom-left anchoring as default (no extra offsets/scaling) */
        #startupOverlay #startupWord.variant-word2 {
            left: calc(env(safe-area-inset-left, 0px) + 0px);
            bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
            transform: none;
            transform-origin: left bottom;
        }
        /* Loading text: center horizontally, at 25vh from the bottom (viewport-based) */
        #startupOverlay #startupLoadingText {
            position: absolute; left: 0; right: 0; bottom: calc(25vh + env(safe-area-inset-bottom, 0px)); transform: none;
            width: 100%; text-align: center;
            color: rgba(255,255,255,0.95); font-weight: 800; letter-spacing: 0.25em;
            text-shadow: 0 0 14px rgba(0,0,0,0.25);
            /* Force a stable, locally-available font to avoid webfont swap causing layout jump */
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang TC", "Microsoft JhengHei", "Heiti TC", "PMingLiU", sans-serif !important;
            /* Disable ligatures to keep width consistent across engines */
            font-variant-ligatures: none;
            font-feature-settings: "liga" 0, "clig" 0;
        }
    </style>
    <style>
        /* Start screen: mobile tweaks for leaderboard title and tabs */
        @media (max-width: 640px) {
            #startScreen #leaderboardSection { padding: 0.75rem !important; }
            #startScreen #leaderboardSection h2 { font-size: 1.1rem !important; line-height: 1.15 !important; }
            #startScreen #leaderboardSection .mb-4 { margin-bottom: 0.5rem !important; }
            #startScreen #leaderboardSection .bg-gray-100.rounded-full { padding: 2px !important; }
            #startScreen #leaderboardSection .leaderboard-tab {
                padding: 0.35rem 0.6rem !important;
                font-size: 0.85rem !important;
                font-weight: 800 !important;
                min-width: auto !important;
            }
        }
    </style>
        <!-- Final mobile overrides (iPhone SE fixes): tighter top cards, hidden level label, clipped panel ornaments, compact score bar -->
        <style>
            @media (max-width: 640px) {
                /* Use small-viewport height to avoid iOS 100vh jump */
                #gameScreen { height: 100svh !important; overflow: visible !important; }

                /* Hide the entire level-progress card (use mobile mini fallback instead) */
                #levelProgressCard { display: none !important; visibility: hidden !important; height: 0 !important; margin: 0 !important; padding: 0 !important; overflow: hidden !important; }

                /* Compact the center score card */
                #gameScreen .cute-card[style*="min-w"] { padding: 0.45rem 0.5rem !important; }
                #centerScore { font-size: clamp(2rem, 9vw, 3rem) !important; }
            
                /* Score bar: reduce height; re-layout ticks with equal grid columns so positions align with bar */
                #scoreProgressBar { height: 14px !important; }
                #scoreProgressFill { height: 100% !important; }
                /* Hide the default tick row (it uses flex and centers labels unevenly on tiny screens) */
                #timeRewardProgressContainer > .flex.justify-between { display: none !important; }
                /* Build a 11-column grid that sits under the bar. We'll reuse the same labels but as a grid. */
                #timeRewardTicksGrid { display: grid !important; grid-template-columns: repeat(11, 1fr) !important; gap: 0 !important; width: 100% !important; margin-top: 4px !important; font-size: 10px !important; color: #6b7280 !important; }
                #timeRewardTicksGrid span { text-align: center !important; min-width: 0 !important; }
                #timeRewardTicksGrid span:first-child { text-align: left !important; }
                #timeRewardTicksGrid span:last-child { text-align: right !important; }
                #timeRewardProgressText { display: none !important; }

                /* Mobile-only mini level progress (fallback) inside score card */
                #levelProgressMini { display: grid !important; grid-template-columns: repeat(5, minmax(0, 1fr)) !important; gap: 4px !important; margin-bottom: 6px !important; }
                #levelProgressMini .mini-dot { width: 100% !important; height: 10px !important; border-width: 2px !important; border-radius: 9999px !important; }

                /* Carousel panels: trim side paddings and prevent decorative emojis from overlapping */
                .verses-carousel .panel { padding-left: 0.5rem !important; padding-right: 0.5rem !important; }
                .verses-carousel .panel > .absolute { display: none !important; }
                .verses-carousel .panel { min-height: 0 !important; }

                /* Titles: smaller with tighter letter-spacing */
                #verseTitle, #chapterTitle { font-size: clamp(0.98rem, 4.2vw, 1.22rem) !important; letter-spacing: 0.02em !important; }

                /* Ensure our encouragement text sits above a slightly shorter pinned bar */
                :root { --pinned-controls-height: 56px !important; }
                #gameControlsPinned { min-height: var(--pinned-controls-height) !important; }
                #gameControlsPinned .cute-button { height: 44px !important; }

                /* Compress panel titles (前段經文/後段經文) to free space for questions */
                /* Hide decorative emoji in titles on small screens */
                #verseTitle .animate-pulse, #chapterTitle .animate-pulse { display: none !important; }
                /* Make the title small, left-aligned, and tight letter-spacing */
                #verseTitle, #chapterTitle {
                    display: inline-flex !important;
                    align-items: center !important;
                    justify-content: flex-start !important;
                    gap: 0.35rem !important;
                    font-size: 0.95rem !important;
                    line-height: 1.1 !important;
                    letter-spacing: 0.02em !important;
                    margin: 0 0 0.2rem 0 !important;
                }
                /* Override the wide tracking on inner label spans */
                #verseTitle .tracking-widest, #chapterTitle .tracking-widest {
                    letter-spacing: 0.02em !important;
                    font-size: 0.98rem !important;
                }
                /* Reduce the wrapper block's bottom margin further */
                #versesCarousel .panel .mb-8 { margin-bottom: 0.2rem !important; }
            }
            /* Desktop+ restore: show ticks in a spaced row as before */
            @media (min-width: 641px) {
                #timeRewardTicksGrid { display: flex !important; justify-content: space-between !important; }
                /* Hide mini level progress on larger screens */
                #levelProgressMini { display: none !important; }
                /* Make the time reward bar slimmer on desktop */
                #scoreProgressBar { height: 12px !important; border-width: 1px !important; }
                #scoreProgressFill { height: 100% !important; }
                /* Equalize hint/back button heights on desktop */
                #gameControlsPinned .cute-button { height: 42px !important; display: inline-flex !important; align-items: center !important; justify-content: center !important; }
            }

            /* Fallback for browsers without svh support: rely on a JS-updated --vh variable */
            @supports not (height: 100svh) {
                @media (max-width: 640px) {
                    #gameScreen { height: calc(var(--vh, 1vh) * 100) !important; }
                }
            }
        </style>
</head>
<body class="bg-gradient-to-br from-pink-100 via-purple-50 to-blue-100 min-h-screen">
    <!-- Startup overlay: 可變主題（亮/暗），中間 LOGO、左下 wordmark、底部 Loading 與右下版本 -->
    <div id="startupOverlay" class="fixed inset-0 z-[9999] flex items-center justify-center select-none theme-light"
         style="transition: opacity 1s ease;">
        <div class="absolute inset-0" aria-hidden="true" style="
            background:
                radial-gradient(1000px 600px at 15% 25%, rgba(255,255,255,0.28) 0%, rgba(255,255,255,0.18) 40%, transparent 55%),
                radial-gradient(900px 540px at 85% 20%, rgba(255,255,255,0.24) 0%, rgba(255,255,255,0.16) 38%, transparent 52%),
                radial-gradient(1100px 660px at 60% 80%, rgba(255,255,255,0.22) 0%, rgba(255,255,255,0.14) 36%, transparent 50%);
        "></div>
        <div class="relative flex flex-col items-center">
            <img id="startupLogo" class="fade-in-1" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='420' height='240'%3E%3C/svg%3E" alt="App logo" decoding="async" fetchpriority="high" />
        </div>
        <img id="startupWord" class="fade-in-2" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='280' height='120'%3E%3C/svg%3E" alt="Wordmark" decoding="async" fetchpriority="high" />
        <div id="startupLoadingText" class="fade-in-2 text-base md:text-lg font-black tracking-widest loading-shimmer">Loading...</div>
        <div id="startupVersion" class="fade-in-3 absolute bottom-3 right-4 text-white/90 text-sm md:text-base font-semibold select-none">
            <!-- set dynamically -->
        </div>
    </div>
    <!-- 背景經文跑馬燈 -->
    <div class="verse-marquee" id="verseMarquee">
        <!-- 跑馬燈經文將在這裡生成 -->
    </div>

    <!-- 全局可愛語氣提示條（置於最外層，避免被任何畫面容器 hidden 影響） -->
    <div id="cuteHintBar" class="cute-hint" role="status" aria-live="polite" aria-atomic="true">
        <span class="cute-hint-icon" aria-hidden="true">✨</span>
        <span class="cute-hint-text">提示文字</span>
    </div>

    <!-- 開始畫面 -->
    <div id="startScreen" class="min-h-screen p-4">
        <div class="max-w-6xl mx-auto">
            <!-- 標題 -->
            <div class="text-center mb-4">
                <div class="title-container bg-gradient-to-br from-slate-700 via-slate-800 to-slate-900 p-6 text-center border-2 border-slate-600 shadow-2xl relative overflow-hidden inline-block rounded-3xl">
                    <!-- 標題背景裝飾 -->
                    <div class="absolute inset-0 bg-gradient-to-br from-slate-700/40 to-slate-800/40 rounded-3xl"></div>
                    <div class="relative z-10">
                        <h1 class="text-4xl font-black bg-gradient-to-r from-gray-200 via-yellow-200 to-gray-200 bg-clip-text text-transparent mb-2 drop-shadow-lg" style="letter-spacing: 0.3em; text-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);">
                            <span id="titleLeftIcon" class="mr-4">📖</span>
                            <span id="mainTitle" class="mx-2" style="cursor:pointer;">經夠盃挑戰</span>
                            <span id="titleRightIcon" class="ml-4">📖</span>
                        </h1>
                    </div>
                </div>
            </div>
            <div class="grid lg:grid-cols-3 gap-4">
                <!-- 計分說明區 -->
                <div id="scoringCard" class="cute-card bg-white p-4 scoring-card">
                    <!-- 開始遊戲按鈕 -->
                    <div class="text-center mb-4">
                        <button id="startGameBtn" class="cute-button bg-gradient-to-r from-purple-500 to-pink-500 text-white py-4 px-8 text-2xl font-bold hover:from-purple-600 hover:to-pink-600 shadow-xl w-full" style="letter-spacing: 0.3em;">
                            開始遊戲
                        </button>
                        <div id="gameStartHint" class="text-sm text-gray-500 mt-2 opacity-0 transition-opacity duration-300">
                            請先選擇難度和出題範圍
                        </div>
                        <!-- Mobile: toggle to show/hide scoring details (keeps desktop unchanged) -->
                        <!-- (moved down under the time reward switch on mobile) -->
                    </div>
                    
                    <!-- 時間獎懲開關 -->
                    <div class="flex items-center justify-center mb-4 p-2 bg-gray-50 rounded-lg">
                        <span class="text-sm text-gray-700 font-medium mr-3">時間獎懲：</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="countdownToggle" class="sr-only peer" checked>
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                            <span class="ml-2 text-sm text-gray-600 font-medium" id="countdownToggleText">開啟</span>
                        </label>
                    </div>

                    <!-- Mobile: toggle to show/hide scoring details (keeps desktop unchanged) -->
                    <div class="text-center mb-2" style="display:block;">
                        <button id="toggleScoringBtn" class="toggle-scoring-btn" aria-expanded="false" aria-controls="scoringBody" style="display:none; margin-top:.25rem; font-size:0.95rem;" title="顯示/收起計分說明">
                            <span aria-hidden="true">📊</span>
                            <span>顯示計分說明</span>
                            <span class="chev" aria-hidden="true">▾</span>
                        </button>
                        <div id="toggleScoringA11y" class="sr-only" aria-live="polite"></div>
                    </div>
                    
                    <!-- 分割線 -->
                    <div class="border-t border-gray-300 mb-4"></div>
                    
                    <div id="scoringBody" class="scoring-body">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">📊 計分說明</h2>
                    
                    <div class="space-y-1 text-sm text-gray-700 scoring-remarks">
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 基礎分數：</span>
                            <span id="baseScoreRuleValue" class="font-bold text-green-600">+100/125/150分/題</span>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 失誤扣分：</span>
                            <span class="font-bold text-red-600">-50分/次</span>
                        </div>
                        
                        <div id="timeRewardRule" class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 時間獎懲：</span>
                            <span class="font-bold text-blue-600">+50~-50分</span>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 全對獎勵：</span>
                            <span class="font-bold text-yellow-600">+100分</span>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 完美獎勵：</span>
                            <span class="font-bold text-purple-600">+300分</span>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 提示獎勵：</span>
                            <span class="font-bold text-orange-600">+100分/剩餘</span>
                        </div>
                    </div>
                    
                        <div class="mt-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
                                <div class="text-xs text-gray-600 scoring-remarks">
                                            <div>※ 失誤扣分：每失誤 1 次，該題分數減 50。</div>
                                            <div>※ 完美獎勵：全對且無失誤且無提示</div>
                                            <div id="timeRewardNote">※ 時間獎懲：8秒內 +50；至120秒降為 -50</div>
                                </div>
                            </div>
                    </div>
                </div>
                
                <!-- 難度選擇區 -->
                <div id="difficultyCard" class="cute-card bg-white p-6">
                    <h2 class="text-3xl font-bold text-gray-800 mb-6 text-center">⚙️ 難度選擇</h2>
                    
                    <div class="space-y-3">
                        <div class="difficulty-option cute-button bg-gradient-to-br from-green-50 to-green-100 border-2 border-green-300 p-4 cursor-pointer shadow-lg hover:shadow-xl transition-all duration-300" data-difficulty="easy" tabindex="0" role="button">
                            <div class="grid grid-cols-5 gap-4 items-center">
                                <div class="col-span-1 flex flex-col items-center justify-center">
                                    <div class="text-3xl">💚</div>
                                    <div class="mt-1 text-lg font-semibold text-green-700 tracking-widest">簡單</div>
                                    <div class="difficulty-hint text-sm text-gray-600">配對經文</div>
                                </div>
                                <div class="col-span-4">
                                    <div class="difficulty-badges">
                                        <div class="text-green-700 font-semibold text-center">配對經文</div>
                                        <div class="text-gray-600 text-center">尋找前後段斷句的連結</div>
                                        <div class="text-gray-600 text-center">分段經文輕鬆記</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="difficulty-option cute-button bg-gradient-to-br from-yellow-50 to-yellow-100 border-2 border-yellow-300 p-4 cursor-pointer shadow-lg hover:shadow-xl transition-all duration-300" data-difficulty="normal" tabindex="0" role="button">
                            <div class="grid grid-cols-5 gap-4 items-center">
                                <div class="col-span-1 flex flex-col items-center justify-center">
                                    <div class="text-3xl">⭐</div>
                                    <div class="mt-1 text-lg font-semibold text-yellow-700 tracking-widest">普通</div>
                                    <div class="difficulty-hint text-sm text-gray-600">配對書卷</div>
                                </div>
                                <div class="col-span-4">
                                    <div class="difficulty-badges">
                                        <div class="text-yellow-700 font-semibold text-center">配對書卷</div>
                                        <div class="text-gray-600 text-center">考驗你對聖經故事的理解</div>
                                        <div class="text-gray-600 text-center">連結經文與書卷</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="difficulty-option cute-button bg-gradient-to-br from-red-50 to-red-100 border-2 border-red-300 p-4 cursor-pointer shadow-lg hover:shadow-xl transition-all duration-300" data-difficulty="hard" tabindex="0" role="button">
                            <div class="grid grid-cols-5 gap-4 items-center">
                                <div class="col-span-1 flex flex-col items-center justify-center">
                                    <div class="text-3xl">🔥</div>
                                    <div class="mt-1 text-lg font-semibold text-red-700 tracking-widest">困難</div>
                                    <div class="difficulty-hint text-sm text-gray-600">配對章節</div>
                                </div>
                                <div class="col-span-4">
                                    <div class="difficulty-badges">
                                        <div class="text-red-700 font-semibold text-center">配對章節</div>
                                        <div class="text-gray-600 text-center">練習判斷經文在章節的位置</div>
                                        <div class="text-gray-600 text-center">深化經文熟悉度</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 出題範圍區 -->
                <div id="rangeCard" class="cute-card bg-white p-6">
                    <h2 class="text-3xl font-bold text-gray-800 mb-4 text-center">📚 出題範圍</h2>

                    <div class="grid grid-cols-1 gap-4">
                        <!-- 上區（排行模式：選擇罕見度） -->
                        <div class="p-4 rounded-xl bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-200 h-full flex flex-col justify-center">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center">
                                    <span class="heading-icon mr-1">🏆</span>
                                    <h3 class="text-base md:text-xl font-bold text-purple-700"><span class="heading-label">排行模式</span></h3>
                                </div>
                                <div class="heading-sub text-purple-500 opacity-80 text-xs md:text-sm font-semibold">經文罕見度</div>
                            </div>

                            <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                                <div class="rarity-option cute-button bg-gradient-to-br from-purple-50 to-purple-100 border-purple-300 border-2 p-2 rounded-md cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex items-center justify-center min-h-[36px]" data-rarity="common" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-purple-700 text-sm font-bold tracking-wider">常見</span>
                                </div>
                                
                                <div class="rarity-option cute-button bg-gradient-to-br from-purple-50 to-purple-100 border-purple-300 border-2 p-2 rounded-md cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex items-center justify-center min-h-[36px]" data-rarity="rare" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-purple-700 text-sm font-bold tracking-wider">冷門</span>
                                </div>
                                <div class="rarity-option cute-button bg-gradient-to-br from-purple-50 to-purple-100 border-purple-300 border-2 p-2 rounded-md cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex items-center justify-center min-h-[36px]" data-rarity="all" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-purple-700 text-sm font-bold tracking-wider">全部</span>
                                </div>
                            </div>
                        </div>

                        <!-- 下區（原練習模式） -->
                        <div class="p-4 rounded-xl bg-gradient-to-br from-blue-50 to-cyan-50 border-2 border-blue-200 h-full flex flex-col justify-center">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center">
                                    <span class="heading-icon mr-1">📝</span>
                                    <h3 class="text-base md:text-xl font-bold text-blue-700"><span class="heading-label">練習模式</span></h3>
                                </div>
                                <div class="heading-sub text-blue-500 opacity-80 text-xs md:text-sm font-semibold">不列入排行</div>
                            </div>

                            <div class="grid grid-cols-2 gap-3 items-stretch">
                                <div class="range-option cute-button bg-gradient-to-br from-blue-50 to-blue-100 border-blue-300 border-2 p-3 rounded-lg cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex-1" data-range="testament" data-testament="old" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-blue-700">舊約</span>
                                </div>

                                <div class="range-option cute-button bg-gradient-to-br from-blue-50 to-blue-100 border-blue-300 border-2 p-3 rounded-lg cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex-1" data-range="testament" data-testament="new" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-blue-700">新約</span>
                                </div>

                                <div class="col-span-2 range-option cute-button bg-gradient-to-br from-orange-50 to-orange-100 border-orange-300 border-2 p-3 rounded-lg cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full" data-range="custom" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-orange-600">自訂書卷</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 自訂書卷擴展卡片（保留現有 id/行為） -->
                    <div id="customBooksExpandCard" class="cute-card bg-white p-3 mt-4 hidden">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-sm font-bold text-orange-700">🎯 選擇書卷</h3>
                            <div class="flex items-center gap-2">
                                <button id="selectAllBooksExpand" class="text-xs bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded">全選</button>
                                <button id="clearAllBooksExpand" class="text-xs bg-red-400 hover:bg-red-500 text-white px-2 py-1 rounded">取消勾選</button>
                            </div>
                        </div>

                        <div class="mb-2">
                            <input type="text" id="bookSearchExpand" placeholder="搜尋書卷..." class="w-full p-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-orange-400">
                        </div>

                        <div id="customBooksExpand" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2 max-h-32 overflow-y-auto" style="grid-auto-rows: minmax(44px, auto);">
                            <!-- 書卷選項將在這裡生成 -->
                        </div>
                    </div>

                    <div id="rangeWarning" class="text-red-500 text-center text-sm hidden mt-4">
                        ⚠️ 選擇的書卷過少，無法開始遊戲！
                    </div>
                </div>
            </div>
            
            <!-- 排行榜區 -->
            <div id="leaderboardSection" class="cute-card bg-white p-6 mt-6">
                <!-- 標題與難度選擇標籤同行 -->
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-800">🏆 排行榜</h2>
                    <div class="flex items-center space-x-3">
                        <div class="bg-gray-100 rounded-full p-1 flex">
                        <button class="leaderboard-tab px-4 py-2 rounded-full text-sm font-bold" data-difficulty="easy">簡單</button>
                        <button class="leaderboard-tab px-4 py-2 rounded-full text-sm font-bold" data-difficulty="normal">普通</button>
                        <button class="leaderboard-tab px-4 py-2 rounded-full text-sm font-bold" data-difficulty="hard">困難</button>
                        </div>
                    </div>
                </div>
                
                <div id="leaderboardList" class="relative" aria-live="polite">
                    <div class="lb-slide lb-slide-static grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4" data-lb-pane="current">
                        <!-- 排行榜項目將在這裡生成 -->
                    </div>
                </div>
                <div id="leaderboardOnlineNote" class="text-xs text-gray-500 mt-2"></div>
                
                <!-- 清空排行榜確認 Modal -->
                <div id="clearLeaderboardModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-60">
                    <div class="cute-card bg-white p-6 rounded-lg max-w-sm mx-4">
                        <h3 class="text-lg font-bold text-gray-800 mb-3">清空排行榜</h3>
                        <p class="text-sm text-gray-600 mb-4">確定要清空所有排行榜紀錄嗎？此操作無法復原。</p>
                        <div class="flex justify-end space-x-3">
                            <button id="cancelClearLeaderboard" class="cute-button bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded">取消</button>
                            <button id="confirmClearLeaderboard" class="cute-button bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">確定清空</button>
                        </div>
                    </div>
                </div>
            </div>
            

        </div>
    </div>

    <!-- 自訂書卷選擇視窗 -->
    <div id="customBooksModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="cute-card bg-white p-6 max-w-2xl mx-4 max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-green-700">🎯 選擇書卷</h3>
                <button id="closeCustomModal" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            
            <div class="mb-4">
                <input type="text" id="bookSearch" placeholder="搜尋書卷..." class="w-full p-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-400">
            </div>
            
            <div class="flex justify-between items-center mb-4">
                <div class="flex space-x-2">
                    <button id="selectAllBooks" class="text-sm bg-green-500 hover:bg-green-600 text-white px-3 py-2 rounded">全選</button>
                    <button id="selectOldTestament" class="text-sm bg-blue-400 hover:bg-blue-500 text-white px-3 py-2 rounded">選擇舊約</button>
                    <button id="selectNewTestament" class="text-sm bg-purple-400 hover:bg-purple-500 text-white px-3 py-2 rounded">選擇新約</button>
                    <button id="clearAllBooks" class="text-sm bg-red-400 hover:bg-red-500 text-white px-3 py-2 rounded">清除全部</button>
                </div>
                <span id="selectedCount" class="text-sm text-gray-600 font-bold">已選: 0本</span>
            </div>
            
            <div id="customBooks" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2 mb-4 max-h-64 overflow-y-auto" style="grid-auto-rows: minmax(48px, auto);">
                <!-- 書卷選項將在這裡生成 -->
            </div>
            
            <div class="flex justify-end space-x-3">
                <button id="cancelCustomSelection" class="cute-button bg-gray-400 hover:bg-gray-500 text-white px-4 py-2 font-bold">取消</button>
                <button id="confirmCustomSelection" class="cute-button bg-green-500 hover:bg-green-600 text-white px-4 py-2 font-bold">確認選擇</button>
            </div>
        </div>
    </div>



    <!-- 遊戲畫面 -->
    <div id="gameScreen" class="min-h-screen p-4 hidden bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50">
        <!-- 遊戲背景裝飾 -->
        <div class="fixed inset-0 pointer-events-none z-0">
            <div class="absolute top-10 left-10 text-6xl opacity-10 animate-pulse">📖</div>
            <div class="absolute top-20 right-20 text-5xl opacity-10 animate-bounce">✨</div>
            <div class="absolute bottom-20 left-20 text-4xl opacity-10 animate-pulse">🙏</div>
            <div class="absolute bottom-10 right-10 text-6xl opacity-10 animate-bounce">⭐</div>
            <div class="absolute top-1/2 left-5 text-3xl opacity-10 animate-pulse">🕊️</div>
            <div class="absolute top-1/3 right-5 text-4xl opacity-10 animate-bounce">💫</div>
        </div>
        
        <!-- 遊戲主要資訊區 -->
        <div class="max-w-7xl mx-auto mb-6 relative z-10">
            <div class="flex items-center justify-between gap-6">
                <!-- 左側：進度條區域 -->
                <div class="flex-1 space-y-4">
                    <!-- 關卡進度條 -->
                    <div id="levelProgressCard" class="cute-card bg-gradient-to-r from-purple-50 to-indigo-50 p-3 border-2 border-purple-200 shadow-xl">
                        <div class="mb-4 flex items-center space-x-2">
                            <span class="text-2xl">🎯</span>
                            <span class="text-lg font-bold text-purple-700">關卡進度</span>
                        </div>
                        <div id="levelOvals" class="flex space-x-2">
                            <!-- 橢圓條將在這裡生成 -->
                        </div>
                    </div>
                    
                    <!-- 題目進度條 -->
                    <div id="questionProgressCard" class="cute-card bg-gradient-to-r from-blue-50 to-cyan-50 p-3 border-2 border-blue-200 shadow-xl">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center space-x-2">
                                <span class="text-2xl">📝</span>
                                <span class="text-lg font-bold text-blue-700">題目進度</span>
                            </div>
                            <span id="currentQuestion" class="text-lg font-bold text-blue-600 bg-blue-100 px-3 py-1 rounded-full">0/5</span>
                        </div>
                        <div id="questionOvals" class="flex space-x-2">
                            <!-- 題目橢圓條將在這裡生成 -->
                        </div>
                    </div>
                </div>

                <!-- 中間：分數顯示 -->
                <div class="cute-card bg-gradient-to-br from-slate-700 via-slate-800 to-slate-900 p-8 text-center min-w-[320px] border-2 border-slate-600 shadow-2xl relative overflow-hidden">
                    <!-- 分數背景裝飾 -->
                    <div class="absolute inset-0 bg-gradient-to-br from-slate-700/40 to-slate-800/40 rounded-3xl"></div>
                    <div class="relative z-10">
                        <div class="flex items-center justify-center space-x-6 mb-4">
                            <div class="flex items-center space-x-2">
                                <span id="centerScore" class="text-7xl font-black bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent drop-shadow-lg" style="text-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 0 0 60px rgba(255, 255, 255, 0.6);">0</span>
                                <span class="text-2xl font-bold bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent" style="text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);">分</span>
                            </div>
                        </div>
                        <!-- ARIA live region for score updates (visually hidden) -->
                        <div id="scoreAriaLive" aria-live="polite" class="sr-only" style="position:absolute; width:1px; height:1px; overflow:hidden; clip:rect(1px, 1px, 1px, 1px);">分數 0 分</div>

                        
                        <!-- 手機版備援：迷你關卡進度（5個小膠囊） -->
                        <div id="levelProgressMini" class="hidden">
                            <div class="mini-dot bg-gray-200 border-gray-300"></div>
                            <div class="mini-dot bg-gray-200 border-gray-300"></div>
                            <div class="mini-dot bg-gray-200 border-gray-300"></div>
                            <div class="mini-dot bg-gray-200 border-gray-300"></div>
                            <div class="mini-dot bg-gray-200 border-gray-300"></div>
                        </div>

                        <!-- 時間獎勵溫度計 -->
                        <div id="timeRewardProgressContainer" class="space-y-2 mb-3">
                            <div class="relative">
                                <div id="scoreProgressBar" class="w-full bg-gray-200 rounded-full h-6 shadow-inner border-2 border-gray-300">
                                    <div id="scoreProgressFill" class="bg-green-500 h-full rounded-full transition-all duration-300 shadow-sm" style="width: 100%"></div>
                                </div>
                                <!-- 溫度計刻度 (已根據 TIME_SCALE 放大顯示：-50 ~ +50) -->
                                <div id="timeRewardTicksGrid" class="text-xs text-gray-500 mt-1 px-0 relative">
                                    <span class="text-left">-50</span>
                                    <span class="text-center">-40</span>
                                    <span class="text-center">-30</span>
                                    <span class="text-center">-20</span>
                                    <span class="text-center">-10</span>
                                    <span class="text-center">0</span>
                                    <span class="text-center">+10</span>
                                    <span class="text-center">+20</span>
                                    <span class="text-center">+30</span>
                                    <span class="text-center">+40</span>
                                    <span class="text-right">+50</span>
                                </div>
                            </div>
                        </div>
                        <div id="timeRewardProgressText" class="text-sm text-gray-400 mb-4 font-normal opacity-70">時間獎懲倒數</div>
                        
                        <!-- Removed old golden encouragement overlay (now using cute toast) -->
                    </div>
                </div>

                <!-- 右側：遊戲資訊與控制 -->
                <div class="flex-1">
                    <!-- 整合的遊戲資訊與控制卡片 -->
                    <div id="gameInfoCard" class="cute-card bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 p-4 border-2 border-indigo-200 shadow-xl">
                        <!-- 標題 -->
                        <div class="flex items-center justify-center space-x-2 mb-4">
                            <span class="text-xl">🎮</span>
                            <span class="text-lg font-bold text-indigo-700">遊戲資訊</span>
                            <span class="text-xl">⚙️</span>
                        </div>
                        
                        <!-- 設定資訊 -->
                        <div id="gameInfoSettings" class="bg-white/60 rounded-xl p-3 mb-4 border border-indigo-200">
                            <div class="flex items-center justify-center space-x-4 text-center">
                                <div class="bg-blue-100 rounded-lg p-2 border border-blue-200 flex-1">
                                    <div class="text-xs text-indigo-700 font-bold mb-1">🎯 難度</div>
                                    <div id="gameDifficultyDisplay" class="font-bold text-blue-700 text-sm">簡單</div>
                                </div>
                                <div class="bg-green-100 rounded-lg p-2 border border-green-200 flex-1">
                                    <div class="text-xs text-emerald-700 font-bold mb-1">📚 範圍</div>
                                    <div id="gameRangeDisplay" class="font-bold text-green-700 text-sm">全部</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 控制按鈕區已移出以便在隱藏遊戲資訊卡時仍可顯示 (see #gameControlsPinned inserted below) -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Pinned controls (hint + back) moved here so they remain visible when the game-info card is hidden on mobile -->
        <div id="gameControlsPinned" class="fixed inset-x-0 bottom-0 z-40 p-3 bg-white/70 backdrop-blur-md border-t border-gray-200 sm:relative sm:bg-white/60 sm:rounded-xl sm:border sm:border-indigo-200 sm:p-3">
            <div class="flex items-center justify-between max-w-[520px] mx-auto">
                <!-- 提示功能 -->
                <div class="flex items-center space-x-2">
                    <button id="hintBtn" class="cute-button bg-gradient-to-r from-amber-500 via-yellow-500 to-amber-600 hover:from-amber-600 hover:via-yellow-600 hover:to-amber-700 text-white font-bold text-sm px-4 py-3 shadow-xl border-2 border-yellow-300 hover:border-yellow-400 transition-all duration-300 transform hover:scale-105">
                        <span class="flex items-center justify-center">提示</span>
                    </button>
                    <div id="hintCount" class="text-sm font-bold text-blue-600 bg-blue-100 px-3 py-2 rounded-full border-2 border-blue-200 shadow-md">
                        ⭐×5
                    </div>
                </div>

                <!-- 返回按鈕 -->
                <button id="backToMenuFromGame" class="cute-button bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white px-4 py-3 font-bold text-sm shadow-lg">
                    返回主選單
                </button>
            </div>
        </div>

        <!-- 遊戲內容 -->
        <div class="max-w-7xl mx-auto space-y-6 relative z-10">
            <!-- Carousel container: two panels (前段經文 / 後段經文) that swipe horizontally on mobile -->
            <div id="versesCarousel" class="verses-carousel relative">
                <!-- Panel: 前段經文 -->
                <div class="panel panel-front p-8 relative">
                    <div class="absolute top-4 right-4 text-6xl opacity-5">📜</div>
                    <div class="absolute bottom-4 left-4 text-5xl opacity-5">✍️</div>
                    <div class="mb-8 relative z-10">
                        <h3 id="verseTitle" class="panel-title text-4xl font-bold text-gray-700 flex items-center justify-center relative" style="letter-spacing:0.12em; margin-bottom:0.25rem;">
                            <span class="text-4xl animate-pulse mr-4">📜</span>
                            <span class="tracking-widest bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">經文</span>
                            <span class="text-4xl animate-pulse ml-4">📜</span>
                        </h3>
                    </div>
                    <div id="gameVerses" class="verses-list flex flex-col gap-3 justify-start relative z-10">
                        <!-- 經文卡片將在這裡生成 -->
                    </div>
                </div>

                <!-- Panel: 後段經文 (章節/配對選項) -->
                <div class="panel panel-back p-8 relative">
                    <div class="absolute top-4 left-4 text-6xl opacity-5">📍</div>
                    <div class="absolute bottom-4 right-4 text-5xl opacity-5">🎯</div>
                    <div class="mb-8 relative z-10">
                        <h3 id="chapterTitle" class="panel-title text-4xl font-bold text-gray-700 flex items-center justify-center relative" style="letter-spacing:0.12em; margin-bottom:0.25rem;">
                            <span class="text-4xl animate-pulse mr-4">📍</span>
                            <span class="tracking-widest bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">章節</span>
                            <span class="text-4xl animate-pulse ml-4">📍</span>
                        </h3>
                    </div>
                    <div id="gameChapters" class="chapter-list flex flex-col gap-3 justify-start relative z-10">
                        <!-- 章節卡片將在這裡生成 -->
                    </div>
                </div>
            </div>
        </div>





        <!-- 確認返回視窗 -->
        <div id="confirmBackModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="confirmBackTitle" tabindex="-1">
            <div class="cute-card bg-white p-8 max-w-md mx-4 text-center">
                <div class="text-4xl mb-4">⚠️</div>
                <h3 id="confirmBackTitle" class="text-xl font-bold text-gray-800 mb-4">確認返回</h3>
                <p class="text-gray-600 mb-6">確定要中斷遊戲並返回首頁嗎？<br><span class="text-sm text-red-500">（中斷遊戲將不會計入排行榜）</span></p>
                <div class="flex space-x-3">
                    <button id="confirmBackBtn" class="cute-button flex-1 bg-red-500 hover:bg-red-600 text-white px-6 py-3 font-bold">
                        確認返回
                    </button>
                    <button id="cancelBackBtn" class="cute-button flex-1 bg-gray-400 hover:bg-gray-500 text-white px-6 py-3 font-bold">
                        繼續遊戲
                    </button>
                </div>
            </div>
        </div>

        <!-- 結算視窗 -->
    <div id="playerNameModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="playerNameModalTitle" tabindex="-1">
            <div class="cute-card bg-gradient-to-br from-white via-blue-50 to-purple-50 p-6 md:p-8 max-w-2xl mx-4 text-center rounded-3xl border-2 border-purple-200 shadow-2xl max-h-[90vh]">
                <div class="modal-body" style="overflow-y:auto; max-height: calc(90vh - 84px); padding-right: 0.25rem;"> 
                <!-- 完成遊戲標題 -->
                <div class="mb-6">
                    <!-- celebratory emoji removed per request -->
            <h2 id="playerNameModalTitle" class="text-3xl font-black bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent mb-2">分數結算</h2>
                    <div class="w-20 h-1 bg-gradient-to-r from-purple-500 to-pink-500 mx-auto rounded-full"></div>
                </div>
                
                <!-- 分數資訊 -->
                <div class="bg-white/70 rounded-2xl p-6 mb-6 border-2 border-purple-200 shadow-lg">
                    <div class="platinum-card rounded-2xl p-5 md:p-6 mb-4">
                        <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
                            <div class="text-center sm:text-left">
                                <div id="finalScore" class="final-score-xl font-black platinum-gold-text final-score-shadow text-on-dark-glow">0</div>
                                <div class="text-xs font-bold on-dark-subtle mt-1">總分數</div>
                            </div>
                            <div class="hidden sm:block platinum-divider" aria-hidden="true"></div>
                            <div class="text-center sm:text-right">
                                <div id="finalAccuracy" class="text-xl font-extrabold on-dark-strong text-on-dark-glow">0%</div>
                                <div id="finalAccuracyRatio" class="text-sm on-dark-medium text-on-dark-glow"><strong>(0/0)</strong></div>
                                <div class="text-xs font-bold on-dark-subtle mt-1">答對率</div>
                            </div>
                        </div>
                        <div id="finalMetaLine" class="mt-3 text-[11px] on-dark-subtle text-center sm:text-right hidden"></div>
                    </div>
                    
                    <!-- 詳細計分數據 -->
                    <div id="scoreBreakdown" class="bg-gray-50 rounded-xl p-4 border border-gray-200">
                        <h4 class="text-sm font-bold text-gray-700 mb-3">📊 詳細計分</h4>
                        <div id="scoreBreakdownContent" class="grid grid-cols-2 gap-2 text-xs">
                            <!-- 計分詳情將在這裡生成 -->
                        </div>
                    </div>
                </div>
                
                <!-- 結語經文 -->
                <div id="closingVerse" class="bg-gradient-to-r from-yellow-100 to-orange-100 rounded-2xl p-4 mb-6 border-2 border-yellow-300 shadow-lg">
                    <div id="closingVerseText" class="text-lg font-bold text-gray-800 mb-1 closing-verse-clamp"></div>
                    <div id="closingVerseRef" class="text-sm text-gray-600 font-semibold" style="margin-top:4px;"></div>
                </div>
                
                <!-- 排行榜訊息 -->
                <div id="leaderboardMessage" class="mb-6">
                    <!-- Dynamic header: will be set to e.g. "第1名" when appropriate -->
                    <h3 id="leaderboardHeader" class="text-xl font-bold text-gray-800 mb-2"></h3>
                    <p id="rankMessage" class="text-lg text-purple-600 font-bold">您獲得了第1名！</p>
                </div>
                
                <!-- 名稱輸入 -->
                <div id="nameInputSection" class="mb-6">
                    <label class="block text-lg font-bold text-gray-700 mb-3">請輸入您的名稱：</label>
                    <input type="text" id="playerNameInput" class="w-full p-4 text-lg border-2 border-purple-300 rounded-xl focus:outline-none focus:ring-4 focus:ring-purple-200 focus:border-purple-500 bg-white/80" maxlength="10" placeholder="留空將顯示為匿名">
                    <div class="text-gray-500 text-sm mt-1">可留空，或輸入2-10個中英文字元</div>
                    <div id="nameError" class="text-red-500 text-sm mt-2 hidden font-bold"></div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-1 gap-3 mb-3">
                    <button id="replaySameQuestionsBtn" class="cute-button w-full bg-yellow-500 hover:bg-yellow-600 text-white px-6 py-3 rounded-xl font-bold flex items-center justify-center gap-3">
                        <span class="text-xl">🎯</span>
                        <span class="text-left">同題重玩<br><span class="text-xs font-normal">不列入排行榜</span></span>
                    </button>
                </div>

                </div>
                <!-- Sticky footer so confirm button is always reachable on small viewports -->
                <div class="modal-footer" style="position:sticky; bottom:0; background: transparent; padding-top:0.2rem; padding-bottom:0.2rem;">
                    <!-- 確認按鈕（主要行動） -->
                    <button id="confirmNameBtn" class="cute-button w-full bg-gradient-to-r from-purple-600 to-pink-500 hover:from-purple-700 hover:to-pink-600 text-white px-6 py-3 font-extrabold text-lg rounded-2xl shadow-2xl">
                        ✅ 確認並返回主選單
                    </button>

                    <!-- sameReplayNote removed as requested -->
                </div>

                <input type="hidden" id="currentViewedRecordId" value="" />
            </div>
        </div>
    </div>

    <script>
        // 遊戲狀態
        let gameState = {
            difficulty: null,
            // ranking/practice model
            mode: null, // 'ranking' or 'practice' (derived from UI selection); optional display helper
            rarity: null, // 'common' | 'rare' | 'all' (for 排行模式；少見 'uncommon' 僅作內部分類)
            range: null,
            testament: 'old',
            customBooks: [],
            currentLevel: 1,
            currentQuestion: 1,
            score: 0,
            hintsUsed: 0,
            levelPerfect: true,
            questionData: [],
            currentQuestionIndex: 0,
            questionAttempts: {},
            usedHints: new Set(),
            selectedVerseIndex: null,
            levelStartTime: null,
            timerInterval: null,
            totalCorrectAnswers: 0,
            totalQuestions: 0,
            gameStartTime: null,
            gameCompleted: false,
            levelResults: {},
            hintsRemaining: 5,
            isFirstQuestionOfLevel: true,
            consecutiveMistakes: 0,
            hintReminderShown: false,
            levelFailedCount: 0,
            showTimeReward: true, // 時間獎懲開關狀態，預設開啟
            // 本局（整場遊戲）首次「該題無法再得分」時顯示提示功能提醒（只顯示一次）
            firstNoScoreMissToastShown: false,
            // 防止同一關結束流程被重複觸發（避免重複加分／連跳關）
            // Prevent duplicate end-of-level handling (avoid double scoring / skipping two levels)
            levelEndHandled: false
        };

        // Mobile viewport stability helpers
        (function mobileViewportFix(){
            try {
                const setVH = () => {
                    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                    document.documentElement.style.setProperty('--vh', `${vh * 0.01}px`);
                };
                setVH();
                window.addEventListener('resize', setVH, { passive: true });
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', setVH, { passive: true });
                    window.visualViewport.addEventListener('scroll', setVH, { passive: true });
                }

                // Keep --pinned-controls-height in sync with actual bar size
                const updatePinned = () => {
                    const el = document.getElementById('gameControlsPinned');
                    if (!el) return;
                    const h = Math.max(56, el.offsetHeight || 0);
                    document.documentElement.style.setProperty('--pinned-controls-height', `${h}px`);
                };
                updatePinned();
                window.addEventListener('resize', updatePinned, { passive: true });
                const ro = window.ResizeObserver ? new ResizeObserver(updatePinned) : null;
                if (ro) ro.observe(document.body);
                if (ro) ro.observe(document.getElementById('gameControlsPinned'));
            } catch(_) { /* ignore */ }
        })();

    // 是否啟用外部經文載入（關閉則完全不嘗試抓取 external-verses.json）
    // Enable/disable external verses loading (skip fetching when disabled)
    const ENABLE_EXTERNAL_VERSES = true;

    // 嘗試載入外部經文資料（非同步、可快取），失敗則保留內建資料
    // Load external verses asynchronously with sessionStorage cache; fallback gracefully on errors
    // 嘗試載入外部題庫 JSON，正規化後放入全域 verseDatabase
    // Attempt to load external verse JSON, normalize, and set window.verseDatabase
    async function attemptLoadExternalVerses() {
            // 若不啟用外部載入，直接返回
            if (!ENABLE_EXTERNAL_VERSES) return;
            try {
                // 使用 sessionStorage 作為快取，避免重複讀取
                // Use sessionStorage cache to avoid redundant fetches
        const cacheKey = 'bibleChallenge.externalVerses.v2';
                const cached = sessionStorage.getItem(cacheKey);
                if (cached) {
                    const parsed = JSON.parse(cached);
                    if (Array.isArray(parsed) && parsed.length > 0) {
                        window.verseDatabase = parsed;
                        try { updateStartButtonState(); } catch(e) {}
                        try { refreshVerseMarqueeData(); } catch(e) {}
                        try {
                            const evt = new CustomEvent('externalVersesLoaded', { detail: { hasData: true, source: 'cache' } });
                            window.dispatchEvent(evt);
                        } catch(_) {}
                        return;
                    }
                }
                // 嘗試抓取同目錄的 external-verses.json（若不存在將拋錯）
                // Try fetching external-verses.json alongside the app
                const res = await fetch('external-verses.json', { cache: 'no-store' });
                let ok = res.ok;
                let data = [];
                if (ok) {
                    try { data = await res.json(); } catch(_) { data = []; }
                }
                // 若主檔不存在或為空，直接改用內建資料（不再嘗試不存在的備份檔）
                // If missing/empty, keep internal dataset (no further fallbacks)
                if (!ok || !Array.isArray(data) || data.length === 0) {
                    data = [];
                }
                if (Array.isArray(data) && data.length > 0) {
                    // 先存原始資料，實際使用時會再經 normalize 與驗證
                    window.verseDatabase = data;
                    try { sessionStorage.setItem(cacheKey, JSON.stringify(data)); } catch(e){}
                    try { updateStartButtonState(); } catch(e) {}
                    try { refreshVerseMarqueeData(); } catch(e) {}
                    try {
                        const evt = new CustomEvent('externalVersesLoaded', { detail: { hasData: true, source: 'fetch' } });
                        window.dispatchEvent(evt);
                    } catch(_) {}
                }
            } catch (e) {
                // 記錄失敗，以便 UI 顯示明確提示（例如 file:// 或 CORS/路徑問題）
                // Record error for UI hints (e.g., file:// access or CORS/path issues)
                try { window.externalVersesLoadError = (e && e.message) ? String(e.message) : 'unknown'; } catch(_) {}
                try { updateStartButtonState(); } catch(_) {}
                try {
                    const evt = new CustomEvent('externalVersesLoaded', { detail: { hasData: false, source: 'error', error: (e && e.message) || 'unknown' } });
                    window.dispatchEvent(evt);
                } catch(_) {}
            }
        }

        // 聖經書卷數據
        const bibleBooks = {
            old: ['創世記', '出埃及記', '利未記', '民數記', '申命記', '約書亞記', '士師記', '路得記', 
                  '撒母耳記上', '撒母耳記下', '列王紀上', '列王紀下', '歷代志上', '歷代志下', 
                  '以斯拉記', '尼希米記', '以斯帖記', '約伯記', '詩篇', '箴言', '傳道書', '雅歌', 
                  '以賽亞書', '耶利米書', '耶利米哀歌', '以西結書', '但以理書', '何西阿書', 
                  '約珥書', '阿摩司書', '俄巴底亞書', '約拿書', '彌迦書', '那鴻書', '哈巴谷書', 
                  '西番雅書', '哈該書', '撒迦利亞書', '瑪拉基書'],
            new: ['馬太福音', '馬可福音', '路加福音', '約翰福音', '使徒行傳', '羅馬書', 
                  '哥林多前書', '哥林多後書', '加拉太書', '以弗所書', '腓立比書', '歌羅西書', 
                  '帖撒羅尼迦前書', '帖撒羅尼迦後書', '提摩太前書', '提摩太後書', '提多書', 
                  '腓利門書', '希伯來書', '雅各書', '彼得前書', '彼得後書', '約翰一書', 
                  '約翰二書', '約翰三書', '猶大書', '啟示錄']
        };

        // 書卷簡稱對照表
        const bookAbbreviations = {
            '創世記': '創', '出埃及記': '出', '利未記': '利', '民數記': '民', '申命記': '申',
            '約書亞記': '書', '士師記': '士', '路得記': '得', '撒母耳記上': '撒上', '撒母耳記下': '撒下',
            '列王紀上': '王上', '列王紀下': '王下', '歷代志上': '代上', '歷代志下': '代下',
            '以斯拉記': '拉', '尼希米記': '尼', '以斯帖記': '斯', '約伯記': '伯', '詩篇': '詩',
            '箴言': '箴', '傳道書': '傳', '雅歌': '歌', '以賽亞書': '賽', '耶利米書': '耶',
            '耶利米哀歌': '哀', '以西結書': '結', '但以理書': '但', '何西阿書': '何',
            '約珥書': '珥', '阿摩司書': '摩', '俄巴底亞書': '俄', '約拿書': '拿', '彌迦書': '彌',
            '那鴻書': '鴻', '哈巴谷書': '哈', '西番雅書': '番', '哈該書': '該',
            '撒迦利亞書': '亞', '瑪拉基書': '瑪',
            '馬太福音': '太', '馬可福音': '可', '路加福音': '路', '約翰福音': '約',
            '使徒行傳': '徒', '羅馬書': '羅', '哥林多前書': '林前', '哥林多後書': '林後',
            '加拉太書': '加', '以弗所書': '弗', '腓立比書': '腓', '歌羅西書': '西',
            '帖撒羅尼迦前書': '帖前', '帖撒羅尼迦後書': '帖後', '提摩太前書': '提前',
            '提摩太後書': '提後', '提多書': '多', '腓利門書': '門', '希伯來書': '來',
            '雅各書': '雅', '彼得前書': '彼前', '彼得後書': '彼後', '約翰一書': '約一',
            '約翰二書': '約二', '約翰三書': '約三', '猶大書': '猶', '啟示錄': '啟'
        };

        // 將各種可能的書卷名稱（含簡稱）正規化為此程式所使用的「完整中文書名」
        function normalizeBookName(name) {
            try {
                if (!name) return name;
                const raw = String(name).trim();
                // 如果本就為完整中文書名且存在於清單中，直接回傳
                if ([...bibleBooks.old, ...bibleBooks.new].includes(raw)) return raw;

                // 嘗試用簡稱（如「太、林前、彼後、創、詩」）反查完整書名
                for (const [full, abbr] of Object.entries(bookAbbreviations)) {
                    if (raw === abbr) return full;
                }

                // 寬鬆處理：移除空白再比對一次
                const compact = raw.replace(/\s+/g, '');
                for (const [full, abbr] of Object.entries(bookAbbreviations)) {
                    if (compact === abbr) return full;
                    if (compact === full.replace(/\s+/g, '')) return full;
                }

                // 未辨識則回傳原值（後續過濾可能會略過此書名）
                return raw;
            } catch (e) {
                return name;
            }
        }

    // 內建題庫已移除，改用 external-verses.json 作為唯一資料來源

    // 清理經文：移除說明用括號內容與多餚空白（保留原文語句）
    // Clean verse text: remove parenthetical notes and extra whitespace (keep original sentences).
        function sanitizeVerseText(text) {
            try {
                if (text == null) return text;
                let s = String(text);
                // 反覆移除半形與全形括號內的內容（不跨越嵌套，迭代處理多段）
                const patterns = [/\([^()]*\)/g, /（[^（）]*）/g];
                let changed = true;
                while (changed) {
                    changed = false;
                    for (const re of patterns) {
                        const next = s.replace(re, '');
                        if (next !== s) { s = next; changed = true; }
                    }
                }
                // 收斂空白與標點周圍空白
                s = s.replace(/\s{2,}/g, ' ').replace(/\s*([，。！？…；;:：,\.\!\?])\s*/g, '$1').trim();
                return s;
            } catch (_) { return text; }
        }

    // 主題性偵測：盡量避開不具主題性的對話型經文（如「百姓回答說：…」）
    // Topicality check: favor verses with clear spiritual keywords; avoid generic dialogues.
        function hasTopicalKeywords(text) {
            try {
                if (!text) return false;
                const keywords = [
                    '耶和華','主','神','耶穌','基督','聖靈','信','愛','義','罪','救','救恩','恩典','福',
                    '讚美','稱謝','敬畏','盼望','永生','生命','聖潔','公義','真理','福音','喜樂','平安','智慧','祈求','禱告'
                ];
                return keywords.some(k => text.includes(k));
            } catch (_) { return false; }
        }

    // 判斷是否屬於不明確的對話開頭（可能缺乏明確主題）
    // Detect ambiguous conversational openings that are weak as standalone prompts.
    function looksLikeAmbiguousDialogue(text) {
            try {
                if (!text) return false;
                const t = String(text).trim().replace(/^^[「『\"]+/, '');
                // 通用對話觸發詞
                const genericSubjects = '(百姓|眾人|人們|他|他們|門徒|婦人|僕人|朋友|眾弟兄|眾民|長老|祭司|文士|法利賽人|官長|王|母親|父親|群眾|有人)';
                const say = '(說|回答說|回說|問|對)';
                // 1) 主語 + 對/問 + 說：
                const re1 = new RegExp('^' + genericSubjects + '[^，。！？:：]{0,8}?' + say + '[^，。！？:：]{0,6}?(說|)[：:]');
                // 2) 主語 + 回答說：
                const re2 = new RegExp('^' + genericSubjects + '(?:[^，。！？:：]{0,6})?回答說[：:]');
                // 3) 對他(們)說 / 問他(們)說：
                const re3 = /^(他|他們|眾人|百姓|人|門徒)[^，。！？:：]{0,6}(對|問)[^，。！？:：]{0,6}說[：:]/;
                return re1.test(t) || re2.test(t) || re3.test(t);
            } catch (_) { return false; }
        }

    // 主題性評估：過短或含糊對話且無關鍵詞 → 視為弱主題
    // Topicality decision: very short or ambiguous dialogue without keywords => weak topical.
    function isWeakTopicalVerse(text) {
            try {
                if (!text) return true;
                const cleaned = String(text).trim();
                const len = cleaned.replace(/[\s，。！？…；:：、\-—\(\)（）\u3000\'\"「」『』《》〈〉]/g, '').length;
                const dialogue = looksLikeAmbiguousDialogue(cleaned);
                const topical = hasTopicalKeywords(cleaned);
                // 規則：
                // - 若像是含糊對話且無明顯主題關鍵詞 → 視為弱主題
                // - 或者字數極短且無關鍵詞 → 視為弱主題
                if ((dialogue && !topical) || (len < 8 && !topical)) return true;
                // 放行例外：出現「耶穌」「主」「耶和華」「神」等即使是對話也常具主題性
                if (/耶穌|主|耶和華|神/.test(cleaned)) return false;
                return false;
            } catch (_) { return false; }
        }

        // --- 題庫整理與難度對應：統一出題來源、去重、罕見度標註、難度過濾 ---
    // 罕見度類別（UI 僅三種）：
    // - common    常見
    // - uncommon  少見（內部用；UI 已併入冷門）
    // - rare      冷門
            // 備註：可在 external-verses.json 直接提供 rarity 屬性（支援英文或中文：常見/中等/少見/冷門/全部）以覆蓋預設分類

    function classifyRarity(v) {
            try {
                if (v && typeof v.rarity === 'string') {
                    // 支援中英文標註
                    const raw = v.rarity.trim().toLowerCase();
                    const map = {
                        '常見': 'common', '中等': 'common', '少見': 'uncommon', '冷門': 'rare', '全部': 'all',
                        'common': 'common', 'medium': 'common', 'uncommon': 'uncommon', 'rare': 'rare', 'all': 'all'
                    };
                    const m = map[raw];
                    if (m) return m;
                }
            } catch (e) {}
            const key = `${v.book}|${v.chapter}`;
            // 章號擷取（支援 "章:節" 或 "章:起-迄"）
            function chapterNumber(ch) {
                try {
                    const s = String(ch || '');
                    const m = s.match(/^(\d+):/);
                    return m ? parseInt(m[1], 10) : NaN;
                } catch (_) { return NaN; }
            }
            // 常見名節（非完整清單，外部資料若標註則以外部為準）
            const COMMON = new Set([
                '約翰福音|3:16', '約翰福音|14:6', '約翰福音|1:1', '約翰福音|1:12',
                '約翰福音|10:11', '約翰福音|11:25', '約翰福音|15:5', '約翰福音|16:33',
                '腓立比書|4:13', '腓立比書|4:6', '腓立比書|4:7', '腓立比書|4:4',
                '羅馬書|8:28', '羅馬書|6:23', '羅馬書|8:1', '羅馬書|1:16',
                '馬太福音|6:33', '馬太福音|7:7', '馬太福音|5:3', '馬太福音|5:14', '馬太福音|28:19', '馬太福音|28:20',
                '詩篇|23:1', '詩篇|23:4', '詩篇|119:105', '詩篇|46:1', '詩篇|46:10',
                '箴言|3:5', '箴言|3:6', '創世記|1:1', '創世記|1:27',
                '以賽亞書|40:31', '耶利米書|29:11', '約書亞記|1:9', '民數記|6:24', '民數記|6:25', '民數記|6:26',
            ]);
            // 書卷層級預設：把較少出現於常見引文的書卷分散到 uncommon/rare
            const RARE_BOOKS = new Set([
                '俄巴底亞書','那鴻書','西番雅書','哈該書','約拿書',
                '腓利門書','約翰二書','約翰三書','猶大書'
            ]);
            const UNCOMMON_BOOKS = new Set([
                '何西阿書','約珥書','阿摩司書','彌迦書','哈巴谷書','撒迦利亞書','瑪拉基書',
                '以斯拉記','尼希米記','以斯帖記','耶利米哀歌','傳道書','雅歌',
                '歷代志上','歷代志下','列王紀上','列王紀下','利未記','民數記'
            ]);
            // 常見章節（整章視為常見，擴大常見池以支援簡單難度）
            const COMMON_CHAPTERS = {
                '詩篇': [23, 27, 46, 51, 91, 100, 121, 127, 139],
                '箴言': [3, 4, 16],
                '創世記': [1, 12, 22, 28, 50],
                '出埃及記': [20],
                '以賽亞書': [40, 41, 43, 53, 55],
                '耶利米書': [17, 29, 33],
                '約書亞記': [1],
                '馬太福音': [5, 6, 7, 11, 28],
                '馬可福音': [12],
                '路加福音': [2, 15],
                '約翰福音': [1, 3, 6, 10, 11, 13, 14, 15, 16],
                '使徒行傳': [1, 2],
                '羅馬書': [5, 6, 8, 10, 12],
                '哥林多前書': [10, 13, 15],
                '哥林多後書': [4, 5, 12],
                '加拉太書': [2, 5, 6],
                '以弗所書': [2, 3, 6],
                '腓立比書': [1, 3, 4],
                '歌羅西書': [3],
                '帖撒羅尼迦前書': [4, 5],
                '提摩太後書': [1, 3, 4],
                '希伯來書': [4, 11, 12, 13],
                '雅各書': [1, 4, 5],
                '彼得前書': [2, 5],
                '約翰一書': [1, 4, 5],
                '啟示錄': [3, 21, 22]
            };
            // 針對特定冷門名節仍保留（即便書卷不在最冷門清單）
            const RARE_KEYS = new Set([
                '俄巴底亞書|1:21','那鴻書|1:7','西番雅書|3:17','哈該書|2:9','哈該書|2:4',
                '約拿書|2:9','阿摩司書|5:24','彌迦書|6:8','何西阿書|2:19',
                '提多書|1:9','腓利門書|1:10','約翰二書|1:5','約翰三書|1:2',
                '以斯拉記|7:10','歷代志上|16:23'
            ]);
            if (COMMON.has(key)) return 'common';
            // 廣義常見章節提升為 common
            try {
                const chNum = chapterNumber(v.chapter);
                const list = COMMON_CHAPTERS[v.book];
                if (Array.isArray(list) && Number.isFinite(chNum) && list.includes(chNum)) {
                    return 'common';
                }
            } catch (_) {}
            if (RARE_KEYS.has(key)) return 'rare';
            if (RARE_BOOKS.has(v.book)) return 'rare';
            if (UNCOMMON_BOOKS.has(v.book)) return 'uncommon';
            return 'rare';
        }

        // 驗證題庫紀錄是否有效，避免「經文內夾雜其他經文參照或頁碼」等髒資料
        function isValidVerseRecord(v) {
            try {
                if (!v || typeof v !== 'object') return false;
                const book = String(v.book || '').trim();
                const chapter = String(v.chapter || '').trim();
                const verse = String(v.verse || '').trim();

                // 書卷需存在於清單
                const allBooks = [...bibleBooks.old, ...bibleBooks.new];
                if (!allBooks.includes(book)) return false;

                // 章節格式：N:N 或 N:N-N
                if (!/^\d+:\d+(?:-\d+)?$/.test(chapter)) return false;

                // 經文內不應再出現第二個書卷參照，例如「民數記 4:43-44」
                const bookNamePattern = /(創世記|出埃及記|利未記|民數記|申命記|約書亞記|士師記|路得記|撒母耳記上|撒母耳記下|列王紀上|列王紀下|歷代志上|歷代志下|以斯拉記|尼希米記|以斯帖記|約伯記|詩篇|箴言|傳道書|雅歌|以賽亞書|耶利米書|耶利米哀歌|以西結書|但以理書|何西阿書|約珥書|阿摩司書|俄巴底亞書|約拿書|彌迦書|那鴻書|哈巴谷書|西番雅書|哈該書|撒迦利亞書|瑪拉基書|馬太福音|馬可福音|路加福音|約翰福音|使徒行傳|羅馬書|哥林多前書|哥林多後書|加拉太書|以弗所書|腓立比書|歌羅西書|帖撒羅尼迦前書|帖撒羅尼迦後書|提摩太前書|提摩太後書|提多書|腓利門書|希伯來書|雅各書|彼得前書|彼得後書|約翰一書|約翰二書|約翰三書|猶大書|啟示錄)\s+\d+:\d+/;
                if (bookNamePattern.test(verse)) return false;

                // 破碎續行的負號段號，如「-40 從三十歲…」
                if (/^-\d+\b/.test(verse)) return false;

                // 明顯頁碼殘留：空白夾著 2-4 位數字（保守處理）
                if (/\s\d{2,4}\s/.test(verse)) return false;

                return true;
            } catch (_) {
                return false;
            }
        }

        function normalizeVerseDatabase(db) {
            const out = [];
            const seen = new Set();
            const defaultVersion = '新標點和合本 神版';
            if (!Array.isArray(db)) return out;
            for (const raw of db) {
                const v = raw || {};
                // 正規化書卷名稱以對齊本遊戲清單（避免外部資料使用簡稱或其他變體造成過濾失敗）
                try { v.book = normalizeBookName(v.book); } catch (e) {}
                // 將數字章轉成字串以統一選擇器與渲染（external JSON 可能為數字）
                try { if (typeof v.chapter === 'number') v.chapter = String(v.chapter); } catch(e){}
                // 先清理經文中的括號說明，提升可讀性與易分段性
                try { if (typeof v.verse === 'string') v.verse = sanitizeVerseText(v.verse); } catch(e){}
                // 先做資料面向的有效性驗證（在建立 key 之前）
                if (!isValidVerseRecord(v)) continue;
                // 過濾主題性較弱或含糊對話型的經文（例如：「百姓回答說：…」）
                try {
                    if (isWeakTopicalVerse(v.verse)) continue;
                } catch(_) {}
                const key = `${v.book}|${v.chapter}|${v.verse}|${v.version||''}`;
                if (seen.has(key)) continue;
                seen.add(key);
                // 保留外部提供的版本與稀有度；僅在缺失時回填預設與分類
                try { if (!v.version) v.version = defaultVersion; } catch(e){}
                try {
                    // 將外部提供的罕見度（支援中英文）統一到 canonical 值；若缺失則自動分類
                    const rawR = (v && v.rarity != null) ? String(v.rarity).trim().toLowerCase() : '';
                    if (rawR) {
                        const map = {
                            '常見': 'common', '中等': 'common', '少見': 'uncommon', '冷門': 'rare', '全部': 'all',
                            'common': 'common', 'medium': 'common', 'uncommon': 'uncommon', 'rare': 'rare', 'all': 'all'
                        };
                        v.rarity = map[rawR] || classifyRarity(v);
                    } else {
                        v.rarity = classifyRarity(v);
                    }
                } catch(e){}
                out.push(v);
            }
            return out;
        }

        function getActiveVerseDB() {
            // 改為只使用外部題庫（external-verses.json）；不再使用內建備援
            try {
                const active = (Array.isArray(window.verseDatabase) && window.verseDatabase.length) ? window.verseDatabase : [];
                return normalizeVerseDatabase(active);
            } catch (e) {
                return [];
            }
        }

    // 已棄用：舊版難度→罕見度過濾器（現行模型改為：練習=範圍優先、排行=罕見度優先）
    // function filterByDifficultyAndRarity(...) { /* removed */ }

    // 罕見度統計摘要（僅供除錯/顯示）
    // Summarize rarity counts for debugging/display
    function summarizeRarity(db) {
            const sum = { total: 0, common: 0, uncommon: 0, rare: 0 };
            for (const v of (db || [])) {
                sum.total++;
                const r = (v && v.rarity) || 'common';
                if (r === 'common' || r === 'uncommon' || r === 'rare') sum[r]++;
            }
            return sum;
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            initializeGame();
            // Trigger a non-blocking load of leaderboard (online adapter may resolve later)
            try { const r = loadLeaderboard(); if (r && typeof r.then === 'function') { r.then(()=>updateLeaderboardDisplay()); } } catch(_){ }
            initializeVerseMarquee();
            // 啟動起始遮罩：至少顯示 2 秒；待題庫載入完成後淡出約 1 秒
            try {
                const APP_VERSION = 'v0.9.2';
                const overlay = document.getElementById('startupOverlay');
                const ver = document.getElementById('startupVersion');
                const logoEl = document.getElementById('startupLogo');
                const wordEl = document.getElementById('startupWord');
                const loadingEl = document.getElementById('startupLoadingText');
                if (overlay) {
                    if (ver) ver.textContent = APP_VERSION;
                    // 隨機挑選四種版本：
                    // 1) 暗底 + logo1-light / word1-light
                    // 2) 暗底 + logo2-light / word2-light
                    // 3) 亮底 + logo1-dark  / word1-dark
                    // 4) 亮底 + logo2-dark  / word2-dark
                    try {
                        const isDark = (window.__startupIsDark === true);
                        const logoSrc = window.__startupLogoSrc;
                        const wordSrc = window.__startupWordSrc;
                        // 切換主題 class
                        overlay.classList.remove('theme-light','theme-dark');
                        overlay.classList.add(isDark ? 'theme-dark' : 'theme-light');
                        // 立即設定圖片來源（已由 <head> 預先決定並 preload）
                        if (logoEl && logoSrc) logoEl.src = logoSrc;
                        if (wordEl && wordSrc) {
                            wordEl.src = wordSrc;
                            const isWord2 = /word2-(light|dark)\.png$/i.test(wordSrc);
                            wordEl.classList.toggle('variant-word2', !!isWord2);
                        }
                        // Loading 文字固定英文
                        if (loadingEl) loadingEl.textContent = 'Loading...';
                        // 依主題微調 Loading/版本的可讀性
                        if (isDark) {
                            if (ver) ver.style.color = 'rgba(255,255,255,0.9)';
                            if (loadingEl) loadingEl.style.color = 'rgba(255,255,255,0.96)';
                        } else {
                            if (ver) ver.style.color = 'rgba(17,24,39,0.9)';
                            if (loadingEl) loadingEl.style.color = 'rgba(31,41,55,0.95)';
                        }
                    } catch (_) {}
                    const start = Date.now();
                    const minWait = 2000;

                    const waitMin = new Promise(resolve => setTimeout(resolve, minWait));
                    // 若資料已可用，直接視為已載入；否則等待事件
                    const waitLoaded = new Promise(resolve => {
                        try {
                            const hasDataNow = Array.isArray(window.verseDatabase) && window.verseDatabase.length > 0;
                            if (hasDataNow) return resolve();
                            const onLoaded = (ev) => {
                                // 無論成功或失敗，都解除遮罩，讓主畫面顯示相應提示
                                try {
                                    if (ev && ev.detail && typeof ev.detail.hasData !== 'undefined') resolve();
                                } catch(_) {}
                                window.removeEventListener('externalVersesLoaded', onLoaded);
                            };
                            window.addEventListener('externalVersesLoaded', onLoaded);
                            // 保險：若事件未觸發，最長等待 8 秒
                            setTimeout(resolve, 8000);
                        } catch(_) { resolve(); }
                    });

                    Promise.all([waitMin, waitLoaded]).then(() => {
                        // 觸發淡出；transition 結束後移除遮罩
                        overlay.style.opacity = '0';
                        const finalize = () => {
                            overlay.style.display = 'none';
                        };
                        overlay.addEventListener('transitionend', finalize, { once: true });
                        // 保險：若 transitionend 沒觸發，1.1 秒後隱藏
                        setTimeout(finalize, 1100);
                    });
                }
            } catch (e) { /* ignore overlay init errors */ }
        });

        function initializeGame() {
            // 預設：不選罕見度；練習模式預設為整本聖經（range=all），與罕見度互斥
            gameState.range = 'all';
            gameState.rarity = null;
            gameState.mode = null;
            // 初始更新計分規則顯示（時間與基礎分數）
            updateScoreRulesDisplay();
            // 顯式同步時間獎懲說明可視狀態
            const timeRewardNote = document.getElementById('timeRewardNote');
            if (timeRewardNote) timeRewardNote.style.display = gameState.showTimeReward ? 'block' : 'none';
            updateBaseScoreRuleDisplay();
            // ...existing code...
            // 開始畫面按鈕事件
            document.getElementById('startGameBtn').addEventListener('click', startGame);

            // 難度選擇事件
            document.querySelectorAll('.difficulty-option').forEach(option => {
                option.addEventListener('click', selectDifficulty);
                // keyboard activation (Enter / Space)
                option.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        option.click();
                    }
                });
            });

            // 出題範圍事件
            document.querySelectorAll('.range-option').forEach(option => {
                option.addEventListener('click', selectRange);
                // keyboard activation (Enter / Space)
                option.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        option.click();
                    }
                });
            });
            // 罕見度（排行模式）事件
            document.querySelectorAll('.rarity-option').forEach(option => {
                option.addEventListener('click', selectRarity);
                option.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        option.click();
                    }
                });
            });
            
            // 倒數顯示開關事件
            document.getElementById('countdownToggle').addEventListener('change', toggleCountdownDisplay);

            // 恢復使用者偏好設定（難度/罕見度/範圍/時間獎勵）
            // Suppress cute hints while applying saved selections to avoid popping on initial menu
            const __prevSuppress = window.__suppressCuteHints;
            window.__suppressCuteHints = true;
            try {
                const saved = JSON.parse(localStorage.getItem('bibleChallenge.prefs') || '{}');
                if (saved && typeof saved === 'object') {
                    // migrate deprecated rarity 'medium' -> 'common'
                    if (saved.rarity === 'medium') saved.rarity = 'common';
                    if (saved.difficulty) {
                        const btn = document.querySelector(`.difficulty-option[data-difficulty="${saved.difficulty}"]`);
                        if (btn && !btn.classList.contains('selected')) btn.click();
                    }
                    if (saved.rarity) {
                        const btn = document.querySelector(`.rarity-option[data-rarity="${saved.rarity}"]`);
                        if (btn && !btn.classList.contains('selected')) btn.click();
                        // 可能未觸發 click: 確保文字更新
                        updateBaseScoreRuleDisplay();
                    }
                    if (saved.range) {
                        const btn = document.querySelector(`.range-option[data-range="${saved.range}"]`);
                        if (btn && !btn.classList.contains('selected')) btn.click();
                    }
                    if (typeof saved.showTimeReward === 'boolean') {
                        const toggle = document.getElementById('countdownToggle');
                        const txt = document.getElementById('countdownToggleText');
                        if (toggle && txt) {
                            toggle.checked = saved.showTimeReward;
                            gameState.showTimeReward = saved.showTimeReward;
                            txt.textContent = saved.showTimeReward ? '開啟' : '關閉';
                            const note = document.getElementById('timeRewardNote');
                            if (note) note.style.display = saved.showTimeReward ? 'block' : 'none';
                            updateScoreRulesDisplay();
                            updateBaseScoreRuleDisplay();
                        }
                    }
                }
            } catch (e) { /* ignore */ }
            finally { window.__suppressCuteHints = __prevSuppress; }
            
            // 自訂書卷視窗事件
            document.getElementById('closeCustomModal').addEventListener('click', closeCustomModal);
            document.getElementById('cancelCustomSelection').addEventListener('click', closeCustomModal);
            document.getElementById('confirmCustomSelection').addEventListener('click', confirmCustomSelection);

            // 遊戲事件
            document.getElementById('hintBtn').addEventListener('click', useHint);

            document.getElementById('backToMenuFromGame').addEventListener('click', () => {
                document.getElementById('confirmBackModal').classList.remove('hidden');
            });
            document.getElementById('confirmBackBtn').addEventListener('click', () => {
                document.getElementById('confirmBackModal').classList.add('hidden');
                // 強制移除所有遊戲提示
                document.querySelectorAll('.game-instruction').forEach(inst => {
                    if (inst.parentElement) inst.parentElement.removeChild(inst);
                });
                // 停止星星雨效果
                try { stopStarRain(true); } catch(_) {}
                if (gameState.score > 0) {
                    // 中途退出，遊戲未完成
                    gameState.gameCompleted = false;
                    saveScore(gameState.score);
                }
                if (gameState.timerInterval) {
                    clearInterval(gameState.timerInterval);
                }
                showStartScreen();
            });
            document.getElementById('cancelBackBtn').addEventListener('click', () => {
                document.getElementById('confirmBackModal').classList.add('hidden');
            });
            document.getElementById('confirmNameBtn').addEventListener('click', confirmPlayerName);
            document.getElementById('clearAllBooks').addEventListener('click', clearAllBooks);
            
            // 排行榜標籤事件
            document.querySelectorAll('.leaderboard-tab').forEach(tab => {
                tab.addEventListener('click', selectLeaderboardTab);
            });

            // 使用標題左右圖示觸發清空排行榜：任一順序（左->右 或 右->左）在 500ms 內完成皆可
            let lastTitleIconClickedAt = 0;
            let lastTitleIcon = null; // 'left' 或 'right'
            const leftIcon = document.getElementById('titleLeftIcon');
            const rightIcon = document.getElementById('titleRightIcon');

            const openClearModal = () => {
                const modal = document.getElementById('clearLeaderboardModal');
                if (modal) modal.classList.remove('hidden');
                lastTitleIconClickedAt = 0;
                lastTitleIcon = null;
            };

            if (leftIcon) {
                leftIcon.style.cursor = 'pointer';
                leftIcon.addEventListener('click', () => {
                    const now = Date.now();
                    if (lastTitleIcon === 'right' && (now - lastTitleIconClickedAt) <= 700) {
                        openClearModal();
                        return;
                    }
                    lastTitleIcon = 'left';
                    lastTitleIconClickedAt = now;
                });
            }

            if (rightIcon) {
                rightIcon.style.cursor = 'pointer';
                rightIcon.addEventListener('click', () => {
                    const now = Date.now();
                    if (lastTitleIcon === 'left' && (now - lastTitleIconClickedAt) <= 700) {
                        openClearModal();
                        return;
                    }
                    lastTitleIcon = 'right';
                    lastTitleIconClickedAt = now;
                });
            }

            document.getElementById('cancelClearLeaderboard')?.addEventListener('click', () => {
                document.getElementById('clearLeaderboardModal')?.classList.add('hidden');
                lastTitleIconClickedAt = 0;
                lastTitleIcon = null;
            });

            document.getElementById('confirmClearLeaderboard')?.addEventListener('click', async () => {
                // 清除排行榜：先遠端、後本機；等待遠端完成再重繪，避免讀到舊資料
                const showBusy = (msg) => { try { showCuteHint(msg || '清除中…', 'rose', 2400, '🧹'); } catch(_) {} };
                const showDone = (msg) => { try { showCuteHint(msg || '已清除排行榜', 'green', 2200, '✅'); } catch(_) {} };
                showBusy('正在清除排行榜…');
                let remoteOk = true;
                if (window.Leaderboard && typeof window.Leaderboard.clear === 'function') {
                    try {
                        await window.Leaderboard.clear();
                    } catch (e) {
                        remoteOk = false;
                        console.warn('[LEADERBOARD] remote clear failed, will still clear local', e);
                    }
                }
                try { localStorage.removeItem('bibleGameLeaderboard'); } catch(_) {}
                await updateLeaderboardDisplay();
                document.getElementById('clearLeaderboardModal')?.classList.add('hidden');
                showDone(remoteOk ? '已清除排行榜（線上與本機）' : '已清除本機排行榜（線上可能未成功）');
                lastTitleIconClickedAt = 0;
                lastTitleIcon = null;
            });

            // 重新播放排行榜紀錄或使用相同題目再來一局的處理
            window.openLeaderboardRecordById = async function(id, difficulty) {
                const ldr = loadLeaderboard();
                const all = (ldr && typeof ldr.then === 'function') ? await ldr : ldr;
                if (!all || !all[difficulty]) return;
                const record = all[difficulty].find(r => String(r.id) === String(id));
                if (!record) return;

                // debug helper: surface whether timeReward was present/estimated for this record
                try {
                    console.log('[DEBUG] openLeaderboardRecordById record:', { id: record.id, score: record.score, timeReward: record.timeReward, timeRewardEstimated: record.timeRewardEstimated, hintsRemaining: record.hintsRemaining, totalHints: record.totalHints });
                } catch (e) {}

                // 填入結算視窗內容（從儲存紀錄填充，不會進行新的儲存）
                // Prefill text (will be animated after breakdown render)
                document.getElementById('finalScore').textContent = '0';
                const accuracy = record.totalQuestions ? Math.round(((record.correctAnswers||0)/record.totalQuestions)*100) : 0;
                document.getElementById('finalAccuracy').textContent = '0%';
                const ratioEl = document.getElementById('finalAccuracyRatio');
                if (ratioEl) ratioEl.innerHTML = `<strong>(${record.correctAnswers||0}/${record.totalQuestions||0})</strong>`;

                // 優先使用儲存的結語經文（若有），否則以遊戲結束相同的方式自動選詩句
                const closingTextEl = document.getElementById('closingVerseText');
                const closingRefEl = document.getElementById('closingVerseRef');
                if (record.closingVerse || record.closingVerseRef) {
                    applyClosingVerse(record.closingVerse, record.closingVerseRef, false);
                } else {
                    updateClosingVerse(accuracy);
                }
                // 計算該記錄在該難度排行榜中的名次（若存在）以供顯示標頭
                let computedRank = null;
                try {
                    const list = all[difficulty] || [];
                    for (let idx = 0; idx < list.length; idx++) {
                        const r = list[idx];
                        if (String(r.id) === String(record.id)) {
                            computedRank = idx + 1;
                            break;
                        }
                    }
                } catch (e) { computedRank = null; }

                // Show the player's name for this record
                document.getElementById('rankMessage').textContent = record.playerName || '匿名';
                const hdr = document.getElementById('leaderboardHeader');
                if (hdr) {
                    if (computedRank) {
                        hdr.innerHTML = `
                            <span style="font-weight:800; font-size:1.15rem; background:linear-gradient(90deg,#7c3aed,#ec4899); -webkit-background-clip:text; color:transparent;">第${computedRank}名</span>
                        `;
                    } else {
                        hdr.innerHTML = `<span style="font-weight:700;">檢視記錄</span>`;
                    }
                }

                // 填入隱藏欄位以便後續按鈕使用
                document.getElementById('currentViewedRecordId').value = record.id || '';

                // 填充計分詳細（使用統一的渲染器，與遊戲結束時相同的格式）
                const breakdown = document.getElementById('scoreBreakdownContent');
                if (breakdown) {
                    breakdown.innerHTML = '';
                    try {
                        // use unified renderer; if it throws, fall back to a minimal summary
                        renderScoreBreakdownFromRecord(record);
                    } catch (e) {
                        const rows = [];
                        rows.push(`<div>總分：<strong>${record.score || 0}</strong></div>`);
                        rows.push(`<div>答對：<strong>${(record.correctAnswers||0)}/${(record.totalQuestions||0)}</strong></div>`);
                        rows.push(`<div>失誤：<strong>${record.totalMistakes != null ? record.totalMistakes : '--'}</strong></div>`);
                        // omit time display for record view per UX request
                        breakdown.innerHTML = rows.map(r=>`<div class="text-xs text-gray-700">${r}</div>`).join('');
                    }
                }

                // 顯示 modal
                const modal = document.getElementById('playerNameModal');
                if (modal) {
                    // If modal is nested under a hidden parent (like #gameScreen), move it to document.body
                    if (modal.parentElement !== document.body) {
                        document.body.appendChild(modal);
                    }
                    // 標記為檢視模式，避免在關閉時再次儲存或修改名稱
                    modal.dataset.viewingRecord = 'true';
                    // 記錄當前檢視的排行榜難度，以便關閉後還原同一標籤
                    modal.dataset.viewingDifficulty = difficulty || gameState.difficulty || '';

                    // 隱藏名稱輸入區，禁止在首頁檢視時更改名稱
                    const nameInputSection = document.getElementById('nameInputSection');
                    if (nameInputSection) nameInputSection.classList.add('hidden');
                    const leaderboardMessage = document.getElementById('leaderboardMessage');
                    if (leaderboardMessage) leaderboardMessage.classList.remove('hidden');

                    // When viewing a saved leaderboard record (opened from leaderboard cards),
                    // show the same-question replay button so users can replay that saved snapshot.
                    const replayBtn = document.getElementById('replaySameQuestionsBtn');
                    if (replayBtn) {
                        replayBtn.classList.remove('hidden');
                    }

                    modal.classList.remove('hidden');
                    // lock background scroll for mobile comfort (match showPlayerNameModal)
                    lockBodyScroll();
                    // attach record object for later use
                    modal.dataset.currentRecord = JSON.stringify(record);
                }
            };

            // (removed) replayAgainBtn event listener - button removed from DOM

            // 同樣題目再來一局（不列入排行榜）：載入題組快照並開始遊戲，並設定 skipLeaderboardOnComplete 標誌
            document.getElementById('replaySameQuestionsBtn').addEventListener('click', async () => {
                const modal = document.getElementById('playerNameModal');
                // Detach Enter hotkey as we are leaving the modal context
                try { detachPlayerNameModalEnterHotkey(); } catch (e) {}
                const raw = modal.dataset.currentRecord;
                if (!raw) return;
                const record = JSON.parse(raw);
                // 若沒有快照則無法執行
                if (!record.questionSnapshot) {
                    alert('此紀錄不包含題組快照，無法使用相同題目再來一局。');
                    return;
                }

                // 如果該紀錄已儲存到排行榜（有 id）且玩家名稱為空或為匿名，先提醒使用者
                const nameIsEmptyOrAnonymous = !record.playerName || record.playerName === '匿名';
                const isSavedRecord = !!record.id;
                console.log('[REPLAY] clicked replaySameQuestionsBtn', { recordId: record.id, playerName: record.playerName, isSavedRecord, nameIsEmptyOrAnonymous });
                // 需求：匿名玩家排行榜卡片 → 同題重玩不再跳出確認視窗，直接進行
                // 因此當為匿名紀錄時不顯示任何確認。若未來需對具名紀錄提示，可在此加入額外條件與詢問。

                // 載入快照（快照可能為新格式 { questionData, levelResults, totalQuestions } 或舊格式的陣列）
                gameState.difficulty = record.difficulty || gameState.difficulty;
                gameState.range = record.range || gameState.range;
                gameState.testament = record.testament || gameState.testament;
                gameState.customBooks = record.customBooks || gameState.customBooks;

                // 將題組替換為快照（優先使用 snapshot.questionData），並設定不要儲存排行榜的旗標
                try {
                    const snapshot = (record.questionSnapshot && typeof record.questionSnapshot === 'object' && record.questionSnapshot.questionData) ? record.questionSnapshot.questionData : record.questionSnapshot;
                    gameState.questionData = JSON.parse(JSON.stringify(snapshot || []));
                } catch (e) {
                    // 退回至原值
                    const snapshot = (record.questionSnapshot && record.questionSnapshot.questionData) ? record.questionSnapshot.questionData : record.questionSnapshot;
                    gameState.questionData = snapshot || [];
                }
                gameState.skipLeaderboardOnComplete = true;
                // remember the original record so end-of-replay modal can reuse its static fields (closing verse, date/time)
                gameState.replaySourceRecord = record;
                console.log('[REPLAY] initialized replay flags', { skipLeaderboardOnComplete: gameState.skipLeaderboardOnComplete, replaySourceRecordId: gameState.replaySourceRecord && gameState.replaySourceRecord.id });

                // 關閉 modal 並開始遊戲介面（直接顯示 gameScreen 並初始化狀態為該快照）
                document.getElementById('playerNameModal').classList.add('hidden');
                // ensure background scrolling is restored on mobile
                try { unlockBodyScroll(); } catch(e) {}
                // 手動進入遊戲畫面，避免重新生成題組
                hideAllScreens();
                document.getElementById('gameScreen').classList.remove('hidden');

                // 初始化遊戲狀態 but keep questionData
                gameState.currentLevel = 1;
                gameState.currentQuestion = 1;
                gameState.score = 0;
                gameState.hintsUsed = 0;
                gameState.levelPerfect = true;
                gameState.questionAttempts = {};
                gameState.usedHints = new Set();
                gameState.gameStartTime = Date.now();
                gameState.gameCompleted = false;
                gameState.isFirstQuestionOfLevel = true;
                gameState.consecutiveMistakes = 0;
                gameState.hintReminderShown = false;
                gameState.levelHintReminderShown = false;
                gameState.totalCorrectAnswers = 0;
                gameState.totalQuestions = record.totalQuestions || (gameState.questionData ? gameState.questionData.length : 0);
                // initialize attempts per question so UI logic (selecting / coloring) works
                (function initAttemptsForReplay() {
                    const maxAttemptsMap = { easy: 3, normal: 3, hard: 3 };
                    const perQuestion = maxAttemptsMap[gameState.difficulty] || 3;
                    if (Array.isArray(gameState.questionData)) {
                        gameState.questionData.forEach((q, i) => {
                            gameState.questionAttempts[i] = perQuestion;
                        });
                    }
                    // restore hint counts according to difficulty so hint button behaves
                    const hintCounts = { easy: 3, normal: 3, hard: 3 };
                    gameState.hintsRemaining = hintCounts[gameState.difficulty] || 3;
                })();
                gameState.totalMistakes = 0;
                // For a replay we must start with fresh level results so progress ovals reflect the new run
                gameState.levelResults = {};
                // Reset one-time per-run toast flag for the replayed session
                gameState.firstNoScoreMissToastShown = false;
                // Reset per-level failed counter for the replay session
                gameState.levelFailedCount = 0;

                // 初始化題目相關 UI
                updateGameUI();
                displayQuestions();
                updateQuestionOvals();

                // start level timer so time-reward and score updates work for the replayed session
                try {
                    gameState.levelStartTime = Date.now();
                    startLevelTimer();
                } catch (e) {
                    console.warn('Unable to start level timer after replay:', e);
                }
            });
            
            // 書卷搜尋和快速選擇事件
            document.getElementById('bookSearch').addEventListener('input', filterBooks);
            document.getElementById('selectAllBooks').addEventListener('click', selectAllBooksInModal);
            document.getElementById('selectOldTestament').addEventListener('click', selectOldTestamentBooks);
            document.getElementById('selectNewTestament').addEventListener('click', selectNewTestamentBooks);
            
            // 擴展卡片搜尋功能
            document.getElementById('bookSearchExpand').addEventListener('input', filterBooksInExpandCard);
            document.getElementById('selectAllBooksExpand').addEventListener('click', selectAllBooksInExpandCard);
            document.getElementById('clearAllBooksExpand').addEventListener('click', clearAllBooksInExpandCard);

            // 初始化自訂書卷選項
            initializeCustomBooks();
            
            // 初始化排行榜顯示
            updateLeaderboardDisplay();
            try {
                const note = document.getElementById('leaderboardOnlineNote');
                if (note) {
                    if (window.Leaderboard && typeof window.Leaderboard.load === 'function') {
                        note.textContent = '線上排行榜已啟用（Supabase）。';
                    } else {
                        note.textContent = '目前使用本機排行榜（僅此裝置可見）。';
                    }
                }
            } catch(_) {}
            
            // 初始化設定顯示
            updateSettingsDisplay();
            updateStartButtonState();
            updateScoreRulesDisplay();
            // mobile score badge setup: clones encouragement text into front/back titles on narrow viewports
            try { setupMobileScoreBadges(); } catch (e) { console.warn('setupMobileScoreBadges failed', e); }
        }

        // Mobile badge behavior caused duplicate encouragement text on some devices.
        // To preserve the original single `#encouragementText` behavior we clean up
        // any previously-created mobile badges and disconnect observers.
        function setupMobileScoreBadges() {
            try {
                // remove any existing mobile badge elements created previously
                document.querySelectorAll('.mobile-center-badge, .mobile-score-badge').forEach(el => {
                    try {
                        if (el.__hideTimer) {
                            clearTimeout(el.__hideTimer);
                            el.__hideTimer = null;
                        }
                    } catch (e) {}
                    try { if (el.parentElement) el.parentElement.removeChild(el); } catch(e) {}
                });

                // disconnect any mutation observers attached to the encouragement element
                const encEl = document.getElementById('encouragementText');
                if (encEl && encEl.__mobileBadgeObserver) {
                    try { encEl.__mobileBadgeObserver.disconnect(); } catch(e) {}
                    try { delete encEl.__mobileBadgeObserver; } catch(e) {}
                }

                // ensure the original encouragement text is visible and left to its original logic
                try { if (encEl) encEl.style.visibility = ''; } catch(e) {}
            } catch (e) {
                console.warn('setupMobileScoreBadges cleanup failed', e);
            }
            // intentionally do not create badges here — original element will control display
            return;
        }

        function showStartScreen() {
            // 直接顯示開始畫面
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('verseMarquee').style.display = 'block';
            // Ensure body scroll is restored when showing the start screen
            try { unlockBodyScroll(); } catch (e) {}
            // Hide any lingering cute hint when returning to start screen
            try { hideCuteHint(); } catch (e) {}
            // ...existing code...
            // 解鎖所有主畫面按鈕
            lockMainScreenButtons(false);
            
            // 重置開始按鈕狀態
            const startBtn = document.getElementById('startGameBtn');
            startBtn.style.border = '';
            startBtn.style.boxShadow = '';
            startBtn.disabled = false;
            startBtn.style.opacity = '';
            startBtn.style.cursor = '';
            startBtn.style.pointerEvents = '';
            
            // 更新按鈕狀態
            updateStartButtonState();
            
            // 預設不強制切換排行榜難度（保留使用者當前檢視）
            updateLeaderboardDisplay();
        }
        
    // 副標題功能已移除

        function hideAllScreens() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('verseMarquee').style.display = 'none';
        }

    // Cute hint bar helpers and message pools
    let cuteHintTimer = null;
    let cuteHintIdCounter = 0; // increments on each show to guard against stale hides
    // Global flag to suppress cute hints during programmatic initialization
    window.__suppressCuteHints = window.__suppressCuteHints || false;
        const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
        const randBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const formatTemplate = (tpl, data) => tpl.replace(/\{(\w+)\}/g, (_, k) => (data && k in data) ? data[k] : _);

        const HINTS = {
            difficulty: {
                easy: [
                    '耶～簡單入門！配對經文暖暖上手～',
                    '簡單模式啟動，先感受一下節奏吧～'
                ],
                normal: [
                    '普通模式來囉！配對書卷，挑戰剛剛好～',
                    '中等挑戰開啟，穩穩來最厲害～'
                ],
                hard: [
                    '困難模式點亮！配對章節，高手請進～',
                    '進階挑戰開打，深呼吸～衝！'
                ],
                cancel: [
                    '先不選難度也可以～慢慢挑喔！'
                ]
            },
            rarity: {
                common: [
                    '選了常見經文～經典不敗，讚讚！',
                    '常見池上線，熟悉的味道來了～'
                ],
                rare: [
                    '挑戰冷門經文！小眾也很寶貴～',
                    '冷門＆少見集合，準備挖寶囉～'
                ],
                all: [
                    '全範圍任你挑～豐富又好玩！',
                    '全部經文開放，出題更有驚喜～'
                ],
                cancel: [
                    '先不排排行也行～之後再選！'
                ]
            },
            range: {
                all: [
                    '整本聖經走起～冒險從創世記到啟示錄！'
                ],
                old: [
                    '鎖定舊約～智慧與歷史滿滿的祝福！'
                ],
                new: [
                    '新約專區～福音與書信給你力量！'
                ],
                custom: [
                    '自訂範圍上線～照你的步調就對了！'
                ],
                cancel: [
                    '先選出題範圍吧～我在這裡等你！'
                ]
            },
            time: {
                on: [
                    '時間獎懲開啟！快狠準再加分～',
                    '計時啟動～把握節奏更刺激！'
                ],
                off: [
                    '時間獎懲關閉～專心沉浸不趕時間～',
                    '先不計時也很棒～慢慢享受文字～'
                ]
            },
            hintReminder: [
                '卡住沒關係～提示在這裡等你喔！',
                '需要小幫手嗎？點提示一起前進～'
            ],
            customConfirm: [
                '已選 {count} 本書卷～客製化最貼心！',
                '自訂範圍完成：{count} 本，讚讚！'
            ],
            play: {
                introEasy: [
                    '先挑一段經文吧～出發！',
                    '選一段喜歡的經文，開始暖身～'
                ],
                introOther: [
                    '先挑一段經文吧～準備配對囉！',
                    '請先選一段經文～等等要來配對了！'
                ],
                pairEasy: [
                    '把它跟另一半配對起來～加油！',
                    '找找看後半段在哪裡～你可以的！'
                ],
                pairOther: [
                    '選出正確的章節～穩穩拿分！',
                    '章節在哪裡呢？鎖定它！'
                ]
            }
        };

        function showCuteHint(messageOrArray, theme = 'purple', duration, icon = '✨') {
            // Skip toasts when suppressed (e.g., on initial default selections)
            if (window.__suppressCuteHints) return;
            const bar = document.getElementById('cuteHintBar');
            if (!bar) return;

            const message = Array.isArray(messageOrArray) ? pick(messageOrArray) : messageOrArray;
            const showMs = typeof duration === 'number' ? (duration <= 0 ? null : duration) : randBetween(2600, 3000);

            // Apply content and theme
            bar.className = `cute-hint ${theme}`;
            bar.querySelector('.cute-hint-icon').textContent = icon;
            bar.querySelector('.cute-hint-text').textContent = message;

            // Show with slide-up + fade-in
            if (cuteHintTimer) { clearTimeout(cuteHintTimer); cuteHintTimer = null; }
            const thisId = String(++cuteHintIdCounter);
            try { bar.dataset.hintId = thisId; } catch (_) {}
            bar.style.display = 'flex';
            // force reflow then add .show
            void bar.offsetWidth; 
            bar.classList.add('show');

            // Auto hide with fade-out then display:none (skip when duration<=0)
            if (showMs !== null) {
                cuteHintTimer = setTimeout(() => {
                    // Only hide if this is still the active hint
                    if (bar.dataset && bar.dataset.hintId === thisId) {
                        bar.classList.remove('show');
                        const hideDelay = 220; // match CSS transition
                        setTimeout(() => {
                            // Ensure we are still hiding the same hint
                            if (bar.dataset && bar.dataset.hintId === thisId) {
                                bar.style.display = 'none';
                            }
                        }, hideDelay);
                    }
                }, showMs);
            }
        }

        // Hide the cute hint immediately (used when user已經進入下一步或作答)
        function hideCuteHint() {
            const bar = document.getElementById('cuteHintBar');
            if (!bar) return;
            if (cuteHintTimer) { try { clearTimeout(cuteHintTimer); } catch (_) {} cuteHintTimer = null; }
            const prevId = (bar.dataset && bar.dataset.hintId) ? bar.dataset.hintId : '';
            try { bar.classList.remove('show'); } catch (_) {}
            // After transition, hide only if the same hint is still current
            setTimeout(() => {
                try {
                    if (!bar.dataset || bar.dataset.hintId === prevId) {
                        bar.style.display = 'none';
                    }
                } catch (_) { /* ignore */ }
            }, 200);
        }

        // New: level encouragement via cute toast (replaces overlay encouragement)
        function showLevelEncouragementCute() {
            try {
                const result = gameState.levelResults && gameState.levelResults[gameState.currentLevel];
                let msgs;
                let theme = 'green';
                let icon = '🎉';
                if (result === 'perfect') {
                    msgs = ['完美！太強了！', '無懈可擊！讚爆！'];
                    theme = 'amber'; icon = '🏆';
                } else if (result === 'complete') {
                    msgs = ['全對！漂亮！', '厲害～繼續保持！'];
                    theme = 'green'; icon = '✅';
                } else {
                    msgs = ['不錯不錯～下一關加油！', '穩穩來～越玩越順！'];
                    theme = 'blue'; icon = '💪';
                }
                showCuteHint(pick(msgs), theme, 2600, icon);
            } catch (_) { /* ignore */ }
        }

    // 切換難度（簡單/普通/困難）；維護選取樣式與偏好
    // Select difficulty; updates selection state and persists preference
    function selectDifficulty(e) {
            const clickedOption = e.currentTarget;
            const isCurrentlySelected = clickedOption.classList.contains('selected');
            
            // 移除所有選中/高亮相關狀態，並還原為每種難度的原始淺色背景與細邊框
            document.querySelectorAll('.difficulty-option').forEach(opt => {
                // remove any possible selected/highlight classes (including color variants)
                opt.classList.remove(
                    'selected', 'border-amber-500', 'border-4', 'shadow-lg',
                    'border-green-600', 'border-yellow-600', 'border-red-600',
                    'bg-green-100', 'bg-yellow-100', 'bg-red-100'
                );

                // 恢復原始邊框與背景（淺色）
                if (opt.dataset.difficulty === 'easy') {
                    opt.classList.add('border-green-300', 'border-2', 'bg-gradient-to-br', 'from-green-50', 'to-green-100');
                } else if (opt.dataset.difficulty === 'normal') {
                    opt.classList.add('border-yellow-300', 'border-2', 'bg-gradient-to-br', 'from-yellow-50', 'to-yellow-100');
                } else if (opt.dataset.difficulty === 'hard') {
                    opt.classList.add('border-red-300', 'border-2', 'bg-gradient-to-br', 'from-red-50', 'to-red-100');
                }
            });
            
            if (isCurrentlySelected) {
                // 如果點擊的是已選中的選項，則取消選擇
                gameState.difficulty = null;
                showCuteHint(HINTS.difficulty.cancel, 'purple', undefined, '🎯');
            } else {
                // 選中新的選項
                if (clickedOption.dataset.difficulty === 'easy') {
                    clickedOption.classList.add('selected', 'border-green-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-green-300', 'border-2');
                    showCuteHint(HINTS.difficulty.easy, 'green', undefined, '🌱');
                } else if (clickedOption.dataset.difficulty === 'normal') {
                    clickedOption.classList.add('selected', 'border-yellow-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-yellow-300', 'border-2');
                    showCuteHint(HINTS.difficulty.normal, 'amber', undefined, '⭐');
                } else if (clickedOption.dataset.difficulty === 'hard') {
                    clickedOption.classList.add('selected', 'border-red-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-red-300', 'border-2');
                    showCuteHint(HINTS.difficulty.hard, 'red', undefined, '🔥');
                }
                gameState.difficulty = clickedOption.dataset.difficulty;
            }
            
            updateSettingsDisplay();
            updateStartButtonState();
            // 儲存偏好
            persistPrefs({ difficulty: gameState.difficulty });
        }

    function updateSettingsDisplay() {
            // 更新遊戲中的設定顯示
            const difficultyText = { easy: '簡單（配對經文）', normal: '普通（配對書卷）', hard: '困難（配對章節）' };
            const gameDifficultyDisplay = document.getElementById('gameDifficultyDisplay');
            const gameRangeDisplay = document.getElementById('gameRangeDisplay');
            
            if (gameDifficultyDisplay && gameState.difficulty) {
                gameDifficultyDisplay.textContent = difficultyText[gameState.difficulty];
                
                // 更新難度卡片顏色
                const difficultyCard = gameDifficultyDisplay.parentElement;
                difficultyCard.className = 'rounded-lg p-2 border flex-1';
                
                if (gameState.difficulty === 'easy') {
                    // 清除任何潛在的錯誤類別再套用綠色樣式
                    clearErrorState(difficultyCard);
                    difficultyCard.classList.add('bg-green-100', 'border-green-200');
                    gameDifficultyDisplay.className = 'font-bold text-green-700 text-base';
                } else if (gameState.difficulty === 'normal') {
                    difficultyCard.classList.add('bg-yellow-100', 'border-yellow-200');
                    gameDifficultyDisplay.className = 'font-bold text-yellow-700 text-base';
                } else if (gameState.difficulty === 'hard') {
                    difficultyCard.classList.add('bg-red-100', 'border-red-200');
                    gameDifficultyDisplay.className = 'font-bold text-red-700 text-base';
                }
            }
            
            if (gameRangeDisplay) {
                // 練習模式：顯示出題範圍（舊約/新約/自訂/整本）
                let rangeText = '整本聖經';
                if (gameState.range === 'testament') {
                    rangeText = gameState.testament === 'old' ? '舊約' : '新約';
                } else if (gameState.range === 'custom') {
                    rangeText = `自訂 (${gameState.customBooks.length}本)`;
                }
                // 若選擇排行模式（選了罕見度），於此也提示罕見度
                if (gameState.rarity) {
                    const rarityLabel = { common: '常見', rare: '冷門', all: '全部' }[gameState.rarity] || '';
                    gameRangeDisplay.textContent = `排行：${rarityLabel}`;
                } else {
                    gameRangeDisplay.textContent = rangeText;
                }
                
                // 更新範圍卡片顏色
                const rangeCard = gameRangeDisplay.parentElement;
                rangeCard.className = 'rounded-lg p-2 border flex-1';
                
                if (gameState.rarity) {
                    // 排行模式色系沿用紫色
                    rangeCard.classList.add('bg-purple-100', 'border-purple-200');
                    gameRangeDisplay.className = 'font-bold text-purple-700 text-sm';
                } else if (gameState.range === 'all') {
                    rangeCard.classList.add('bg-purple-100', 'border-purple-200');
                    gameRangeDisplay.className = 'font-bold text-purple-700 text-sm';
                } else if (gameState.range === 'testament') {
                    rangeCard.classList.add('bg-blue-100', 'border-blue-200');
                    gameRangeDisplay.className = 'font-bold text-blue-700 text-sm';
                } else if (gameState.range === 'custom') {
                    rangeCard.classList.add('bg-orange-100', 'border-orange-200');
                    gameRangeDisplay.className = 'font-bold text-orange-700 text-sm';
                }
            }
        }

    // 切換排行模式的經文罕見度（常見/冷門/全部）
    // Select rarity for leaderboard mode (common/rare/all)
    function selectRarity(e) {
            const clicked = e.currentTarget;
            const isSelected = clicked.classList.contains('selected');
            // reset visual state
            document.querySelectorAll('.rarity-option').forEach(opt => {
                opt.classList.remove('selected', 'border-purple-600', 'border-4', 'shadow-lg');
                opt.setAttribute('aria-pressed', 'false');
                opt.classList.add('border-purple-300', 'border-2');
            });
            if (isSelected) {
                gameState.rarity = null;
                gameState.mode = null;
                clicked.setAttribute('aria-pressed', 'false');
                showCuteHint(HINTS.rarity.cancel, 'purple', undefined, '🏆');
            } else {
                clicked.classList.add('selected', 'border-purple-600', 'border-4', 'shadow-lg');
                clicked.classList.remove('border-purple-300', 'border-2');
                clicked.setAttribute('aria-pressed', 'true');
                gameState.rarity = clicked.dataset.rarity;
                gameState.mode = 'ranking';
                // rarity hints
                const r = gameState.rarity;
                const pool = (r === 'common') ? HINTS.rarity.common
                           : (r === 'rare') ? HINTS.rarity.rare
                           : HINTS.rarity.all;
                showCuteHint(pool, 'purple', undefined, '🔎');
                // 與練習範圍互斥：清除任何範圍選擇
                document.querySelectorAll('.range-option').forEach(opt => {
                    opt.classList.remove('selected', 'border-purple-600', 'border-blue-600', 'border-orange-600', 'border-4', 'shadow-lg');
                    opt.setAttribute('aria-pressed', 'false');
                    // 恢復原始邊框樣式
                    if (opt.dataset.range === 'all') {
                        opt.classList.add('border-purple-300', 'border-2');
                    } else if (opt.dataset.range === 'testament') {
                        opt.classList.add('border-blue-300', 'border-2');
                    } else if (opt.dataset.range === 'custom') {
                        opt.classList.add('border-orange-300', 'border-2');
                    }
                });
                gameState.range = null;
            }
            // 清除自訂擴展卡片顯示（避免同時展開）
            document.getElementById('rangeWarning')?.classList.add('hidden');
            document.getElementById('customBooksExpandCard')?.classList.add('hidden');
            updateSettingsDisplay();
            updateBaseScoreRuleDisplay();
            updateStartButtonState();
            persistPrefs({ rarity: gameState.rarity, range: gameState.range });
        }

    // 設定排行榜標籤的啟用狀態與 ARIA 屬性
    // Activate leaderboard tab UI and ARIA attributes
    function setActiveLeaderboardTabByDifficulty(diff) {
            const palette = {
                // Use gentle gradients to match difficulty theme
                easy:   { g1: '#ECFDF5', g2: '#D1FAE5', text: '#065F46', border: '#34D399' }, // green-50 -> green-200
                normal: { g1: '#FFFBEB', g2: '#FEF3C7', text: '#92400E', border: '#F59E0B' }, // amber-50 -> amber-200
                hard:   { g1: '#FEF2F2', g2: '#FEE2E2', text: '#991B1B', border: '#EF4444' }  // red-50 -> red-200
            };
            document.querySelectorAll('.leaderboard-tab').forEach(tab => {
                const isActive = tab.dataset.difficulty === diff;
                // reset inline styles to avoid class conflicts
                tab.style.backgroundColor = '';
                tab.style.backgroundImage = '';
                tab.style.color = '';
                tab.style.border = '';
                tab.style.boxShadow = '';
                tab.classList.remove('text-white','text-gray-600','bg-blue-500');
                if (isActive) {
                    const p = palette[diff] || palette.easy;
                    tab.style.backgroundImage = `linear-gradient(135deg, ${p.g1}, ${p.g2})`;
                    tab.style.backgroundColor = 'transparent';
                    tab.style.color = p.text;
                    tab.style.border = `2px solid ${p.border}`;
                    tab.style.boxShadow = '0 2px 8px rgba(0,0,0,0.08)';
                } else {
                    tab.style.backgroundImage = 'linear-gradient(135deg, #F9FAFB, #F3F4F6)';
                    tab.style.backgroundColor = 'transparent';
                    tab.style.color = '#6B7280';
                    tab.style.border = '1px solid #E5E7EB';
                    tab.style.boxShadow = 'none';
                }
            });
        }

    // 點擊排行榜標籤以切換難度頁籤
    // Handle leaderboard tab click to switch difficulty view
    function selectLeaderboardTab(e) {
            // 取消動畫、避免連續觸發；僅在目標不同時切換
            // No animation; block while animating; only switch when target differs
            if (window.__lbTransitioning) return; // block while animating
            const selectedDifficulty = e.currentTarget.dataset.difficulty;
            const order = ['easy','normal','hard'];
            const prev = window.__lbCurrentDifficulty || 'easy';
            if (selectedDifficulty === prev) return; // no-op if same tab
            const dir = order.indexOf(selectedDifficulty) > order.indexOf(prev) ? 'left' : 'right';
            setActiveLeaderboardTabByDifficulty(selectedDifficulty);
            // No animation: switch instantly
            updateLeaderboardDisplay(selectedDifficulty);
        }

    // 啟用滑動切換排行榜難度（無動畫，並加上過程防呆）
    // Enable swipe gesture to switch leaderboard difficulty (no animation, guarded)
    // 排行榜左右滑動切換（行動裝置）
    // Enable swipe navigation between leaderboard difficulty panes
    function setupLeaderboardSwipe() {
            const container = document.getElementById('leaderboardList');
            if (!container) return;
            let startX = 0, startY = 0, dx = 0, dy = 0, tracking = false;
            const order = ['easy','normal','hard'];
            const threshold = 48; // px
            const onStart = (x, y) => { startX = x; startY = y; dx = 0; dy = 0; tracking = true; };
            const onMove = (x, y) => { if (!tracking) return; dx = x - startX; dy = y - startY; };
            const onEnd = () => {
        if (window.__lbTransitioning) { tracking = false; return; }
                if (!tracking) return;
                tracking = false;
                // horizontal swipe dominant and exceed threshold
                if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
                    const cur = window.__lbCurrentDifficulty || 'easy';
                    const idx = order.indexOf(cur);
                    if (dx < 0 && idx < order.length - 1) {
                        const next = order[idx + 1];
            if (window.__lbTransitioning) return;
                        setActiveLeaderboardTabByDifficulty(next);
                        // No animation
                        updateLeaderboardDisplay(next);
                    } else if (dx > 0 && idx > 0) {
                        const prev = order[idx - 1];
            if (window.__lbTransitioning) return;
                        setActiveLeaderboardTabByDifficulty(prev);
                        // No animation
                        updateLeaderboardDisplay(prev);
                    }
                }
            };

            // Touch events
            container.addEventListener('touchstart', (e) => {
                if (!e.touches || !e.touches.length) return;
                const t = e.touches[0];
                onStart(t.clientX, t.clientY);
            }, { passive: true });
            container.addEventListener('touchmove', (e) => {
                if (!e.touches || !e.touches.length) return;
                const t = e.touches[0];
                onMove(t.clientX, t.clientY);
            }, { passive: true });
            container.addEventListener('touchend', onEnd, { passive: true });

            // Mouse events (desktop)
            container.addEventListener('mousedown', (e) => { onStart(e.clientX, e.clientY); });
            container.addEventListener('mousemove', (e) => { onMove(e.clientX, e.clientY); });
            container.addEventListener('mouseleave', () => { tracking = false; });
            container.addEventListener('mouseup', onEnd);
        }

        function selectRange(e) {
            const clickedOption = e.currentTarget;
            const isCurrentlySelected = clickedOption.classList.contains('selected');
            
            // 移除所有選中狀態
            document.querySelectorAll('.range-option').forEach(opt => {
                opt.classList.remove('selected', 'border-purple-600', 'border-blue-600', 'border-orange-600', 'border-4', 'shadow-lg');
                opt.setAttribute('aria-pressed', 'false');
                // 恢復原始邊框樣式
                if (opt.dataset.range === 'all') {
                    opt.classList.add('border-purple-300', 'border-2');
                } else if (opt.dataset.range === 'testament' && opt.dataset.testament === 'old') {
                    opt.classList.add('border-blue-300', 'border-2');
                } else if (opt.dataset.range === 'testament' && opt.dataset.testament === 'new') {
                    opt.classList.add('border-blue-300', 'border-2');
                } else if (opt.dataset.range === 'custom') {
                    opt.classList.add('border-orange-300', 'border-2');
                }
            });

            // 與排行罕見度互斥：清除罕見度選擇
            document.querySelectorAll('.rarity-option').forEach(opt => {
                opt.classList.remove('selected', 'border-purple-600', 'border-4', 'shadow-lg');
                opt.classList.add('border-purple-300', 'border-2');
                opt.setAttribute('aria-pressed', 'false');
            });
            gameState.rarity = null;
            gameState.mode = null;

            // 隱藏警告訊息和自訂擴展卡片
            document.getElementById('rangeWarning').classList.add('hidden');
            document.getElementById('customBooksExpandCard').classList.add('hidden');
            
            if (isCurrentlySelected) {
                // 如果點擊的是已選中的選項，則取消選擇
                gameState.range = null;
                gameState.testament = 'old'; // 重置為預設值
                clickedOption.setAttribute('aria-pressed', 'false');
                showCuteHint(HINTS.range.cancel, 'blue', undefined, '📚');
            } else {
                // 選中新的選項
                if (clickedOption.dataset.range === 'all') {
                    clickedOption.classList.add('selected', 'border-purple-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-purple-300', 'border-2');
                    showCuteHint(HINTS.range.all, 'purple', undefined, '📖');
                } else if (clickedOption.dataset.range === 'testament') {
                    clickedOption.classList.add('selected', 'border-blue-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-blue-300', 'border-2');
                    const t = clickedOption.dataset.testament === 'old' ? HINTS.range.old : HINTS.range.new;
                    showCuteHint(t, 'blue', undefined, '🧭');
                } else if (clickedOption.dataset.range === 'custom') {
                    clickedOption.classList.add('selected', 'border-orange-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-orange-300', 'border-2');
                    showCuteHint(HINTS.range.custom, 'amber', undefined, '🧩');
                }
                gameState.range = clickedOption.dataset.range;
                clickedOption.setAttribute('aria-pressed', 'true');
                
                // 處理不同範圍類型
                if (gameState.range === 'testament') {
                    gameState.testament = clickedOption.dataset.testament;
                } else if (gameState.range === 'custom') {
                    // 顯示自訂書卷擴展卡片
                    showCustomBooksExpandCard();
                }
            }
            
            updateSettingsDisplay();
            updateBaseScoreRuleDisplay();
            updateStartButtonState();
            // 儲存偏好
            persistPrefs({ range: gameState.range, rarity: gameState.rarity });
        }



    // 切換「時間獎懲」顯示與狀態（UI + 偏好儲存）
    // Toggle time-reward visibility/state (UI + persist preference)
    // 切換「時間獎懲」顯示與規則文字
    // Toggle time-reward option and update rule text
    function toggleCountdownDisplay() {
            const toggle = document.getElementById('countdownToggle');
            const toggleText = document.getElementById('countdownToggleText');
            
            gameState.showTimeReward = toggle.checked;
            toggleText.textContent = gameState.showTimeReward ? '開啟' : '關閉';
            // cute hint for time reward toggle
            if (gameState.showTimeReward) {
                showCuteHint(HINTS.time.on, 'blue', 2400, '⏱️');
            } else {
                showCuteHint(HINTS.time.off, 'blue', 2400, '😌');
            }
            
            // 更新計分說明顯示
            updateScoreRulesDisplay();
            
            // 如果在遊戲中，立即更新顯示
            if (!document.getElementById('gameScreen').classList.contains('hidden')) {
                updateTimeRewardVisibility();
            }
            // 儲存偏好
            persistPrefs({ showTimeReward: gameState.showTimeReward });
        }

    // 將使用者偏好（難度/範圍/罕見度/時間獎懲）存入 localStorage
    // Persist user preferences to localStorage
    function persistPrefs(partial) {
            try {
                const key = 'bibleChallenge.prefs';
                const saved = JSON.parse(localStorage.getItem(key) || '{}') || {};
                const next = { ...saved, ...partial };
                localStorage.setItem(key, JSON.stringify(next));
            } catch (e) { /* ignore */ }
        }

    // 依 time-reward 狀態顯示/隱藏進度與提示文字
    // Show/hide time-reward widgets based on state
    // 依勾選狀態顯示/隱藏時間獎懲說明
    // Show/hide time reward note based on toggle
    function updateTimeRewardVisibility() {
            const currentScoreDisplay = document.getElementById('currentScoreDisplay');
            const timeRewardProgressContainer = document.getElementById('timeRewardProgressContainer');
            const timeRewardProgressText = document.getElementById('timeRewardProgressText');
            
            if (gameState.showTimeReward) {
                if (currentScoreDisplay) currentScoreDisplay.style.display = 'block';
                if (timeRewardProgressContainer) timeRewardProgressContainer.style.display = 'block';
                if (timeRewardProgressText) timeRewardProgressText.style.display = 'block';
            } else {
                if (currentScoreDisplay) currentScoreDisplay.style.display = 'none';
                if (timeRewardProgressContainer) timeRewardProgressContainer.style.display = 'none';
                if (timeRewardProgressText) timeRewardProgressText.style.display = 'none';
            }
        }

    // 更新規則說明區塊（含時間獎懲說明）
    // Update rules section (including time-reward info)
    // 更新「時間獎懲」說明行（依目前設定）
    // Update time reward rule line text
    function updateScoreRulesDisplay() {
            const timeRewardRule = document.getElementById('timeRewardRule');
            const timeRewardNote = document.getElementById('timeRewardNote');
            
            if (gameState.showTimeReward) {
                if (timeRewardRule) timeRewardRule.style.display = 'flex';
                if (timeRewardNote) timeRewardNote.style.display = 'block';
                // 排行模式每題基礎分：common=100, rare=150, all=200（顯示於下方規則區）
            } else {
                if (timeRewardRule) timeRewardRule.style.display = 'none';
                if (timeRewardNote) timeRewardNote.style.display = 'none';
            }
        }

        // 更新「基礎分數」說明字樣，會隨罕見度按鈕切換
    // 更新「基礎分數」說明行（依罕見度）
    // Update base score rule line based on rarity
    function updateBaseScoreRuleDisplay() {
            const el = document.getElementById('baseScoreRuleValue');
            if (!el) return;
            const labelMap = { common: '常見', rare: '冷門', all: '全部' };
            // 練習模式（有 range）一律顯示 100；排行模式時依罕見度
            const inPractice = !!gameState.range;
            const perQMap = { common: 100, rare: 125, all: 150 };
            if (inPractice) {
                el.textContent = '+100分/題';
                return;
            }
            if (gameState.rarity && perQMap[gameState.rarity]) {
                const perQ = perQMap[gameState.rarity];
                el.textContent = `+${perQ}分/題`;
            } else {
                el.textContent = '+100/125/150分/題';
            }
        }



    // 展開「自訂書卷」快速選擇卡片（行內展開）
    // Show inline expand-card for quick custom book selection.
    // 展開卡：在首頁顯示簡版自訂書卷選擇
    // Expand-card view for quick custom books selection
    function showCustomBooksExpandCard() {
            const expandCard = document.getElementById('customBooksExpandCard');
            expandCard.classList.remove('hidden');
            // 初始化書卷選項
            initializeCustomBooksInExpandCard();
        }

    // 開啟自訂書卷的完整清單（彈窗模式）
    // Open the full custom books list in a modal.
    // 開啟完整自訂書卷對話框
    // Open the full custom-books modal
    function openCustomModal() {
            document.getElementById('customBooksModal').classList.remove('hidden');
            // 重新初始化書卷選項
            initializeCustomBooksInModal();
        }

    // 關閉自訂書卷彈窗；若無選擇任何書卷，撤銷自訂範圍
    // Close modal; if no selection remains, cancel custom range.
    // 關閉自訂書卷對話框
    // Close the custom-books modal
    function closeCustomModal() {
            document.getElementById('customBooksModal').classList.add('hidden');
            // 如果沒有選擇任何書卷，取消自訂範圍選擇
            if (gameState.customBooks.length === 0) {
                gameState.range = null;
                document.querySelectorAll('.range-option').forEach(opt => {
                    opt.classList.remove('selected', 'border-purple-500', 'border-4', 'shadow-lg');
                    opt.classList.add('border-gray-300', 'border-2');
                });
                updateSettingsDisplay();
                updateStartButtonState();
            }
        }

    // 確認自訂範圍選擇（依難度有最少數量要求）
    // Confirm custom selection; enforce minimal choices by difficulty.
    // 確認自訂選擇並回寫到遊戲狀態
    // Confirm selection and write into gameState
    function confirmCustomSelection() {
            // 檢查各難度的最低書卷要求
            if (gameState.difficulty === 'normal' && gameState.customBooks.length < 3) {
                showCuteHint('普通難度：自訂範圍至少選 3 本書卷', 'rose', undefined, '⚠️');
                return;
            }
            if ((gameState.difficulty === 'easy' || gameState.difficulty === 'hard') && gameState.customBooks.length < 1) {
                showCuteHint(`${gameState.difficulty === 'easy' ? '簡單' : '困難'}難度：自訂範圍至少選 1 本書卷`, 'rose', undefined, '⚠️');
                return;
            }
            
            // 確認選擇，關閉視窗
            showCuteHint(formatTemplate(pick(HINTS.customConfirm), { count: gameState.customBooks.length }), 'amber', undefined, '✅');
            closeCustomModal();
            updateSettingsDisplay();
            updateStartButtonState();
        }

    // 初始化自訂書卷 UI 與事件
    // Initialize custom-books UI and events
    function initializeCustomBooks() {
            // 這個函數現在只是為了保持兼容性，實際初始化在各自的函數中進行
        }

    // 初始化展開卡片中的自訂書卷按鈕（響應式網格與觸控友善）
    // Initialize buttons for expand-card grid; mobile-friendly.
    // 初始化展開卡清單與勾選狀態
    // Initialize expand-card list and checks
    function initializeCustomBooksInExpandCard() {
            const container = document.querySelector('#customBooksExpandCard #customBooksExpand');
            container.innerHTML = '';
            const allBooks = [...bibleBooks.old, ...bibleBooks.new];
            allBooks.forEach(book => {
                const isSelected = gameState.customBooks.includes(book);
                const abbreviation = bookAbbreviations[book] || book;
                const btn = document.createElement('button');
                btn.type = 'button';
                // larger tappable target, centered abbreviation, visual selected state
                // don't force full width so grid can place multiple items per row on small screens
                btn.className = `inline-flex items-center justify-center px-3 py-2 rounded-lg border text-sm font-medium transition-all duration-150 ${isSelected ? 'bg-orange-400 text-white border-orange-600 shadow-md scale-105' : 'bg-white text-gray-700 border-gray-300 hover:bg-orange-50'}`;
                btn.style.minWidth = '64px';
                btn.style.width = 'auto';
                btn.title = book;
                btn.textContent = abbreviation;
                btn.setAttribute('data-book', book);
                btn.addEventListener('click', function() {
                    // toggle selection state
                    if (gameState.customBooks.includes(book)) {
                        gameState.customBooks = gameState.customBooks.filter(b => b !== book);
                    } else {
                        gameState.customBooks.push(book);
                    }
                    // re-render to reflect selection
                    initializeCustomBooksInExpandCard();
                    updateSettingsDisplay();
                    updateStartButtonState();
                });
                container.appendChild(btn);
            });
            // ensure the container uses an auto-fit responsive grid so many items can appear per row on narrow screens
            container.style.gridTemplateColumns = 'repeat(auto-fit, minmax(64px, 1fr))';
        }

    // 初始化彈窗中的自訂書卷清單（tile 網格 + checkbox）
    // Initialize modal tile grid with checkboxes for books.
    // 初始化對話框清單與勾選狀態
    // Initialize modal list and checks
    function initializeCustomBooksInModal() {
            const container = document.querySelector('#customBooksModal #customBooks');
            container.innerHTML = ''; // 清空容器

            // render as responsive auto-fit grid of tiles for easier mobile tapping
            container.className = 'grid gap-2 mb-4 max-h-64 overflow-y-auto';
            container.style.gridTemplateColumns = 'repeat(auto-fit, minmax(80px, 1fr))';

            const allBooks = [...bibleBooks.old, ...bibleBooks.new];

            allBooks.forEach(book => {
                const isSelected = gameState.customBooks.includes(book);
                const tile = document.createElement('label');
                // use inline-flex so tiles can size to the grid cell and allow multiple per row
                tile.className = `relative cursor-pointer select-none inline-flex items-center justify-center rounded-lg p-2 text-center border ${isSelected ? 'bg-orange-400 text-white border-orange-600 shadow-md' : 'bg-white text-gray-800 border-gray-200 hover:bg-gray-50'}`;
                tile.style.minHeight = '44px';
                tile.style.alignItems = 'center';
                tile.style.justifyContent = 'center';
                tile.setAttribute('data-book', book);

                tile.innerHTML = `
                    <input type="checkbox" class="absolute left-2 top-2" data-book="${book}" ${isSelected ? 'checked' : ''} />
                    <div class="flex items-center justify-center h-full">
                        <div class="text-sm font-medium truncate" title="${book}">${book}</div>
                    </div>
                `;

                container.appendChild(tile);

                // toggle when clicking tile or checkbox
                const input = tile.querySelector('input');
                input.addEventListener('change', () => {
                    updateCustomBooks();
                });
                tile.addEventListener('click', (e) => {
                    // avoid double-toggling when clicking the checkbox
                    if (e.target === input) return;
                    input.checked = !input.checked;
                    updateCustomBooks();
                });
            });

            // 更新選擇數量顯示
            updateSelectedCount();
        }

    // 從展開卡片（按鈕）同步自訂選擇到狀態
    // Sync selected books from expand-card buttons into state.
    // 由展開卡回寫選擇
    // Sync selections from expand card to state
    function updateCustomBooksFromExpandCard() {
            const checkboxes = document.querySelectorAll('#customBooksExpandCard #customBooksExpand input[type="checkbox"]');
            gameState.customBooks = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.book);
            
            updateSettingsDisplay();
            updateStartButtonState();
        }

    // 從彈窗（checkbox）同步自訂選擇到狀態
    // Sync selected books from modal checkboxes into state.
    // 統一回寫自訂書卷選擇（modal/expand）
    // Persist custom books selections into state
    function updateCustomBooks() {
            const checkboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');
            gameState.customBooks = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.book);
            
            updateSelectedCount();
        }

    // 更新彈窗中「已選 N 本」的計數顯示
    // Update the selected-count badge text in modal.
    // 更新己選書卷數顯示
    // Update selected-count badge
    function updateSelectedCount() {
            const countElement = document.querySelector('#customBooksModal #selectedCount');
            if (countElement) {
                countElement.textContent = `已選: ${gameState.customBooks.length}本`;
            }
        }

    // 清除所有自訂選擇（依所在介面：展開卡片或彈窗）
    // Clear all selected books from either expand-card or modal.
    // 清空所有勾選
    // Clear all selected books
    function clearAllBooks() {
            // 檢查是在擴展卡片還是模態視窗中
            const expandCardCheckboxes = document.querySelectorAll('#customBooksExpandCard #customBooksExpand input[type="checkbox"]');
            const modalCheckboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');
            
            if (expandCardCheckboxes.length > 0) {
                expandCardCheckboxes.forEach(cb => cb.checked = false);
                gameState.customBooks = [];
                updateSettingsDisplay();
                updateStartButtonState();
                
                // 如果沒有選擇任何書卷，隱藏擴展卡片
                if (gameState.customBooks.length === 0) {
                    document.getElementById('customBooksExpandCard').classList.add('hidden');
                    // 取消自訂範圍選擇
                    gameState.range = null;
                    document.querySelectorAll('.range-option').forEach(opt => {
                        opt.classList.remove('selected', 'border-purple-500', 'border-4', 'shadow-lg');
                        opt.classList.add('border-gray-300', 'border-2');
                    });
                    updateSettingsDisplay();
                    updateStartButtonState();
                }
            } else if (modalCheckboxes.length > 0) {
                modalCheckboxes.forEach(cb => cb.checked = false);
                gameState.customBooks = [];
                updateSelectedCount();
            }
        }
        
    // 在彈窗與展開卡片中以輸入框關鍵字過濾書卷清單
    // Filter book tiles/buttons by search term.
    // 對話框內過濾書卷清單
    // Filter book list inside modal
    function filterBooks() {
            const searchTerm = document.getElementById('bookSearch').value.toLowerCase();
            // target both modal tiles (label) and expand-card buttons
            const modalTiles = document.querySelectorAll('#customBooksModal #customBooks label');
            const expandBtns = document.querySelectorAll('#customBooksExpandCard #customBooksExpand button');
            modalTiles.forEach(tile => {
                const bookName = (tile.getAttribute('data-book') || tile.textContent || '').toLowerCase();
                tile.style.display = bookName.includes(searchTerm) ? '' : 'none';
            });
            expandBtns.forEach(btn => {
                const bookName = (btn.getAttribute('data-book') || btn.textContent || '').toLowerCase();
                btn.style.display = bookName.includes(searchTerm) ? '' : 'none';
            });
        }
        
    // 一鍵選取舊約所有書卷（支援展開卡片與彈窗兩種 UI）
    // Select all Old Testament books across both UIs.
    // 快速勾選舊約
    // Quick select Old Testament
    function selectOldTestamentBooks() {
            // 支援兩種 UI：擴展卡片（按鈕）與模態（勾選框）
            const expandButtons = document.querySelectorAll('#customBooksExpandCard #customBooksExpand button[data-book]');
            const modalCheckboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');

            if (expandButtons.length > 0) {
                const set = new Set(gameState.customBooks);
                bibleBooks.old.forEach(b => set.add(b));
                gameState.customBooks = Array.from(set);
                initializeCustomBooksInExpandCard();
                updateSettingsDisplay();
                updateStartButtonState();
            }
            if (modalCheckboxes.length > 0) {
                modalCheckboxes.forEach(cb => {
                    if (bibleBooks.old.includes(cb.dataset.book)) {
                        cb.checked = true;
                    }
                });
                updateCustomBooks();
            }
        }
        
    // 一鍵選取新約所有書卷（支援展開卡片與彈窗兩種 UI）
    // Select all New Testament books across both UIs.
    // 快速勾選新約
    // Quick select New Testament
    function selectNewTestamentBooks() {
            // 支援兩種 UI：擴展卡片（按鈕）與模態（勾選框）
            const expandButtons = document.querySelectorAll('#customBooksExpandCard #customBooksExpand button[data-book]');
            const modalCheckboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');

            if (expandButtons.length > 0) {
                const set = new Set(gameState.customBooks);
                bibleBooks.new.forEach(b => set.add(b));
                gameState.customBooks = Array.from(set);
                initializeCustomBooksInExpandCard();
                updateSettingsDisplay();
                updateStartButtonState();
            }
            if (modalCheckboxes.length > 0) {
                modalCheckboxes.forEach(cb => {
                    if (bibleBooks.new.includes(cb.dataset.book)) {
                        cb.checked = true;
                    }
                });
                updateCustomBooks();
            }
        }

    // 彈窗：全選所有書卷（checkbox）
    // Modal: select-all all books via checkboxes.
    // 一鍵全選（對話框）
    // Select all books in modal
    function selectAllBooksInModal() {
            const modalCheckboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');
            modalCheckboxes.forEach(cb => cb.checked = true);
            updateCustomBooks();
        }

    // 展開卡片：全選所有書卷（按鈕）
    // Expand-card: select-all by toggling all buttons to selected state.
    // 一鍵全選（展開卡）
    // Select all books in expand card
    function selectAllBooksInExpandCard() {
            const allBooks = [...bibleBooks.old, ...bibleBooks.new];
            gameState.customBooks = allBooks.slice();
            initializeCustomBooksInExpandCard();
            updateSettingsDisplay();
            updateStartButtonState();
        }
        
    // 展開卡片：依搜尋框即時過濾按鈕
    // Expand-card: filter buttons with instant search.
    // 展開卡過濾書卷清單
    // Filter book list in expand card
    function filterBooksInExpandCard() {
            const searchTerm = document.getElementById('bookSearchExpand').value.toLowerCase();
            // expand card uses buttons, target those
            const btns = document.querySelectorAll('#customBooksExpandCard #customBooksExpand button');
            btns.forEach(btn => {
                const bookName = (btn.getAttribute('data-book') || btn.textContent || '').toLowerCase();
                if (bookName.includes(searchTerm)) btn.style.display = '';
                else btn.style.display = 'none';
            });
        }
        
    // 展開卡片：清空所有選擇並收起卡片，且撤銷自訂範圍
    // Expand-card: clear selections, hide card, and reset custom range.
    // 清空展開卡勾選
    // Clear all selections in expand card
    function clearAllBooksInExpandCard() {
            // 擴展卡片使用按鈕，不存在 checkbox；直接清空選擇
            gameState.customBooks = [];
            initializeCustomBooksInExpandCard();
            updateSettingsDisplay();
            updateStartButtonState();

            // 隱藏擴展卡片並重置自訂範圍
            document.getElementById('customBooksExpandCard').classList.add('hidden');
            gameState.range = null;
            document.querySelectorAll('.range-option').forEach(opt => {
                opt.classList.remove('selected', 'border-purple-500', 'border-4', 'shadow-lg');
                opt.classList.add('border-gray-300', 'border-2');
            });
            updateSettingsDisplay();
            updateStartButtonState();
        }

    // 根據目前設定與題庫可用性，更新「開始遊戲」按鈕的可用狀態與提示
    // Update start button enabled/disabled state based on selections and data availability.
    // 依設定與選擇狀態決定「開始遊戲」可用性
    // Enable/disable Start button based on selections
    function updateStartButtonState() {
            const startBtn = document.getElementById('startGameBtn');
            const hintElement = document.getElementById('gameStartHint');
            const activeDB = getActiveVerseDB();
            const hasData = Array.isArray(activeDB) && activeDB.length > 0;
            // 可以以「排行模式（選罕見度）」或「練習模式（選範圍）」開始
            const hasRanking = !!gameState.rarity;
            const hasPractice = !!gameState.range;
            let canStart = !!(gameState.difficulty && (hasRanking || hasPractice) && hasData);
            
            // 檢查可開始條件：所有模式至少需有基本題數；「自訂範圍」在普通 >=3，本；簡單/困難 >=1 本
            if (canStart && hasPractice) {
                const availableVerses = getAvailableVerses();
                if (gameState.range === 'custom') {
                    if (gameState.difficulty === 'normal' && gameState.customBooks.length < 3) {
                        canStart = false;
                    }
                    if ((gameState.difficulty === 'easy' || gameState.difficulty === 'hard') && gameState.customBooks.length < 1) {
                        canStart = false;
                    }
                }
                canStart = canStart && availableVerses.length >= 5;
            }
            
            if (canStart) {
                // 可以開始遊戲，添加縮放提醒效果
                startBtn.classList.add('start-button-pulse');
                startBtn.disabled = false;
                startBtn.style.cursor = 'pointer';
                startBtn.style.opacity = '1';
                hintElement.style.opacity = '0';
            } else {
                // 不能開始遊戲，移除提醒效果並顯示提示
                startBtn.classList.remove('start-button-pulse');
                startBtn.disabled = true;
                startBtn.style.cursor = 'not-allowed';
                startBtn.style.opacity = '0.6';
                hintElement.style.opacity = '1';
                
                // 根據缺少的選項更新提示文字
                if (!hasData) {
                    // 若以 file:// 開啟，瀏覽器會阻擋 fetch JSON；引導使用本機伺服器
                    if (location && location.protocol === 'file:') {
                        hintElement.textContent = '需要透過本機伺服器開啟（如 VS Code Live Server 或 python -m http.server），file:// 無法載入題庫。';
                    } else if (window && window.externalVersesLoadError) {
                        hintElement.textContent = '題庫載入失敗，請重新整理（Ctrl+F5），或確認 external-verses.json 路徑/CORS 設定。';
                    } else {
                        hintElement.textContent = '正在載入題庫…';
                    }
                } else if (!gameState.difficulty && !hasRanking && !hasPractice) {
                    hintElement.textContent = '請先選擇難度與出題範圍';
                } else if (!gameState.difficulty) {
                    hintElement.textContent = '請先選擇遊戲難度';
                } else if (!hasRanking && !hasPractice) {
                    hintElement.textContent = '請選擇「排行模式」或「練習模式」';
                } else if (gameState.range === 'custom') {
                    if (gameState.difficulty === 'normal' && gameState.customBooks.length < 3) {
                        hintElement.textContent = '普通難度：自訂範圍至少選 3 本書卷';
                    } else if ((gameState.difficulty === 'easy' || gameState.difficulty === 'hard') && gameState.customBooks.length < 1) {
                        hintElement.textContent = `${gameState.difficulty === 'easy' ? '簡單' : '困難'}難度：自訂範圍至少選 1 本書卷`;
                    } else {
                        hintElement.textContent = '此設定可用經文不足，請調整罕見度或擴大範圍';
                    }
                } else {
                    hintElement.textContent = '此設定可用經文不足，請調整罕見度或擴大範圍';
                }
            }
        }

        function startGame() {
        // 檢查是否已選擇難度，且有「排行模式（罕見度）」或「練習模式（範圍）」
        if (!gameState.difficulty || (!gameState.rarity && !gameState.range)) {
                return;
            }
            
        // 練習模式：檢查自訂範圍是否有足夠的書卷
        if (gameState.range === 'custom') {
                // 各難度的自訂範圍最低書卷數
                if (gameState.difficulty === 'normal' && gameState.customBooks.length < 3) {
                    const warn = document.getElementById('rangeWarning');
                    if (warn) {
                        warn.textContent = '⚠️ 普通難度：自訂範圍至少選 3 本書卷';
                        warn.classList.remove('hidden');
                    }
                    return;
                }
                if ((gameState.difficulty === 'easy' || gameState.difficulty === 'hard') && gameState.customBooks.length < 1) {
                    const warn = document.getElementById('rangeWarning');
                    if (warn) {
                        warn.textContent = `⚠️ ${gameState.difficulty === 'easy' ? '簡單' : '困難'}難度：自訂範圍至少選 1 本書卷`;
                        warn.classList.remove('hidden');
                    }
                    return;
                }
                
                // 檢查選擇的書卷是否有對應的經文
                const availableVerses = getAvailableVerses();
                if (availableVerses.length < 5) {
            document.getElementById('rangeWarning').innerHTML = '⚠️ 可用經文不足（至少需要 5 篇），請擴大範圍或改選罕見度/範圍！';
                    document.getElementById('rangeWarning').classList.remove('hidden');
                    return;
                }
            }
            
            // 開始倒數
            startCountdown();
        }
        
    function startCountdown() {
            // 顯示開始遊戲提示視窗
            showGameStartModal();
            
            // 鎖定所有主畫面按鈕
            lockMainScreenButtons(true);
            
            const startBtn = document.getElementById('startGameBtn');
            startBtn.style.border = '4px solid #f59e0b';
            startBtn.style.boxShadow = '0 0 20px rgba(245, 158, 11, 0.5)';

            // Unique start button effect (aurora rings + particles)
            try { triggerStartButtonBurst(startBtn.getBoundingClientRect()); } catch(_) {}
            
            let countdown = 3;
            let hasSwitched = false; // 已在全黑時切換畫面的旗標
            const originalText = startBtn.innerHTML;
            // 倒數文字立即顯示（快速呈現）
            try { updateGameStartModal(countdown); } catch(_) {}
            // 保留「一開始的瞬間黑屏」效果：先讓初始微暗化完成，再進入長時間漸暗
            try {
                const veil = document.getElementById('gameStartVeil');
                if (veil) {
                    const totalMs = Math.max(300, countdown * 1000 - 100);
                    const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                    const startRamp = () => {
                        veil.style.transition = `opacity ${prefersReduce ? 200 : totalMs}ms linear`;
                        requestAnimationFrame(() => { veil.style.opacity = '1'; });
                    };
                    const current = parseFloat(getComputedStyle(veil).opacity) || 0;
                    if (current >= 0.35) {
                        // 初始微暗化已完成或接近完成，稍後啟動長時間漸暗
                        setTimeout(startRamp, 30);
                    } else {
                        // 等待首次 opacity 變化完成後再開始長時間漸暗（保留原本瞬間黑屏的感覺）
                        let started = false;
                        const onInitialEnd = (e) => {
                            if (e.propertyName !== 'opacity' || started) return;
                            started = true;
                            veil.removeEventListener('transitionend', onInitialEnd);
                            startRamp();
                        };
                        veil.addEventListener('transitionend', onInitialEnd);
                        // 後備：若 transitionend 未觸發，320ms 後啟動
                        setTimeout(() => {
                            if (!started) {
                                veil.removeEventListener('transitionend', onInitialEnd);
                                startRamp();
                            }
                        }, 320);
                    }
                }
            } catch(_) {}
            
            const countdownInterval = setInterval(() => {
                if (countdown > 0) {
                    // 只更新提示視窗的倒數，不改變按鈕文字
                    updateGameStartModal(countdown);
                } else {
                    // 倒數結束，顯示「開始」，並準備進行全黑切換
                    updateGameStartModal(0);
                    if (!hasSwitched) {
                        hasSwitched = true;
                        try {
                            const veil = document.getElementById('gameStartVeil');
                            if (veil) {
                                const proceed = () => {
                                    try { actuallyStartGame(); } catch(_) {}
                                    // 全黑後 1 秒內淡出，避免延誤計時
                                    try {
                                        const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                                        const outMs = prefersReduce ? 200 : 800;
                                        // 同步淡出「準備開始遊戲」與倒數/開始字樣
                                        const content = document.getElementById('gameStartContent');
                                        if (content) {
                                            content.style.transition = `opacity ${outMs}ms ease-out`;
                                            content.style.opacity = '0';
                                            content.style.pointerEvents = 'none';
                                        }
                                        // 黑幕淡出
                                        veil.style.transition = `opacity ${outMs}ms ease-out`;
                                        requestAnimationFrame(() => { veil.style.opacity = '0'; });
                                        const onReveal = () => { veil.removeEventListener('transitionend', onReveal); hideGameStartModal(); };
                                        veil.addEventListener('transitionend', onReveal);
                                    } catch(_) { hideGameStartModal(); }
                                };
                                // 若已幾乎全黑，直接切換；否則等達到全黑
                                const current = parseFloat(getComputedStyle(veil).opacity) || 0;
                                if (current >= 0.98) {
                                    proceed();
                                } else {
                                    const onFullBlack = (e) => {
                                        if (e.propertyName !== 'opacity') return;
                                        if ((parseFloat(getComputedStyle(veil).opacity) || 0) >= 0.98) {
                                            veil.removeEventListener('transitionend', onFullBlack);
                                            proceed();
                                        }
                                    };
                                    veil.addEventListener('transitionend', onFullBlack);
                                    // 保險：目標設為全黑（若尚未設過）
                                    requestAnimationFrame(() => { veil.style.opacity = '1'; });
                                }
                            } else {
                                // 後備路徑：直接切換
                                actuallyStartGame();
                                hideGameStartModal();
                            }
                        } catch(_) {
                            // 防禦：任何異常都直接切換
                            try { actuallyStartGame(); } catch(_) {}
                            try { hideGameStartModal(); } catch(_) {}
                        }
                    }
                }
                countdown--;
                // 一旦觸發切換即可清除定時器，避免重複觸發
                if (hasSwitched) {
                    clearInterval(countdownInterval);
                } else if (countdown < -1) {
                    // 防守性：若未能觸發切換則直接開始
                    clearInterval(countdownInterval);
                    try { actuallyStartGame(); } catch(_) {}
                    try { hideGameStartModal(); } catch(_) {}
                }
            }, 1000);
        }
        
        function showGameStartModal() {
            // 創建提示視窗
            const modal = document.createElement('div');
            modal.id = 'gameStartModal';
            modal.className = 'fixed inset-0 flex items-center justify-center z-50';
            
            modal.innerHTML = `
                <div id="gameStartVeil" aria-hidden="true" style="position:absolute; inset:0; background:#000; opacity:0; transition: opacity 280ms ease-out;"></div>
                <div id="gameStartContent" class="text-center relative" style="z-index:1;">
                    <div class="mb-8">
                        <h2 class="text-5xl font-black bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent mb-8 drop-shadow-2xl animate-pulse" style="text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);">
                            準備開始遊戲
                        </h2>
                        <div id="countdownDisplay" class="text-[8rem] font-black bg-gradient-to-r from-yellow-400 via-amber-400 to-yellow-500 bg-clip-text text-transparent drop-shadow-2xl mb-6 transition-all duration-300 min-h-[180px] flex items-center justify-center" style="text-shadow: 0 0 50px rgba(255, 215, 0, 1), 0 0 100px rgba(255, 215, 0, 0.8);">
                        </div>
                        <div id="countdownText" class="text-3xl bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent font-bold min-h-[40px] flex items-center justify-center" style="text-shadow: 0 0 30px rgba(255, 255, 255, 0.8); display: none;">
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            // 預先暗化背景（淡入），恢復原本的初始黑度與瞬間感
            try {
                const veil = document.getElementById('gameStartVeil');
                if (veil) requestAnimationFrame(() => { veil.style.opacity = '0.4'; });
            } catch(_) {}
        }
        
        function updateGameStartModal(countdown) {
            const countdownDisplay = document.getElementById('countdownDisplay');
            const countdownText = document.getElementById('countdownText');
            
            if (countdownDisplay && countdownText) {
                if (countdown > 0) {
                    countdownDisplay.textContent = countdown;
                    countdownDisplay.className = 'text-[8rem] font-black bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent drop-shadow-2xl mb-6 transition-all duration-300 min-h-[180px] flex items-center justify-center countdown-float';
                    countdownDisplay.style.textShadow = '0 0 30px rgba(255, 255, 255, 0.8)';
                    // 隱藏輔助文字，不顯示「秒後開始」
                    countdownText.style.display = 'none';
                } else {
                    countdownDisplay.textContent = '開始';
                    countdownDisplay.className = 'text-[8rem] font-black bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent drop-shadow-2xl mb-6 transition-all duration-300 min-h-[180px] flex items-center justify-center';
                    countdownDisplay.style.textShadow = '0 0 30px rgba(255, 255, 255, 0.8)';
                    // 隱藏輔助文字
                    countdownText.style.display = 'none';
                }
            }
        }
        
        function hideGameStartModal() {
            const modal = document.getElementById('gameStartModal');
            if (modal) {
                modal.remove();
            }
        }

        function lockMainScreenButtons(lock) {
            // 鎖定/解鎖所有難度選擇按鈕
            document.querySelectorAll('.difficulty-option').forEach(btn => {
                btn.style.pointerEvents = lock ? 'none' : 'auto';
            });
            
            // 鎖定/解鎖所有範圍選擇按鈕
            document.querySelectorAll('.range-option').forEach(btn => {
                btn.style.pointerEvents = lock ? 'none' : 'auto';
            });
            
            // 鎖定/解鎖時間獎勵開關
            const toggle = document.getElementById('countdownToggle');
            const toggleContainer = toggle.parentElement.parentElement;
            toggleContainer.style.pointerEvents = lock ? 'none' : 'auto';
            
            // 鎖定/解鎖排行榜區域
            const leaderboardSection = document.getElementById('leaderboardSection');
            if (leaderboardSection) {
                leaderboardSection.style.pointerEvents = lock ? 'none' : 'auto';
            }
            
            // 鎖定/解鎖自訂書卷區域
            const customBooksExpandCard = document.getElementById('customBooksExpandCard');
            if (customBooksExpandCard) {
                customBooksExpandCard.style.pointerEvents = lock ? 'none' : 'auto';
            }
            
            // 鎖定/解鎖開始遊戲按鈕
            const startBtn = document.getElementById('startGameBtn');
            startBtn.disabled = lock;
            startBtn.classList.toggle('start-button-pulse', !lock);
            startBtn.style.cursor = lock ? 'not-allowed' : 'pointer';
            startBtn.style.pointerEvents = lock ? 'none' : 'auto';
        }
        
        function actuallyStartGame() {
            // 重置遊戲狀態
            gameState.currentLevel = 1;
            gameState.currentQuestion = 1;
            gameState.score = 0;
            gameState.hintsUsed = 0;
            gameState.levelPerfect = true;
            gameState.questionAttempts = {};
            gameState.usedHints = new Set();
            gameState.gameStartTime = Date.now(); // 記錄遊戲開始時間
            gameState.gameCompleted = false;
            gameState.isFirstQuestionOfLevel = true;
            gameState.consecutiveMistakes = 0;
            gameState.hintReminderShown = false;
            gameState.levelHintReminderShown = false;
            gameState.firstNoScoreMissToastShown = false;
            gameState.levelFailedCount = 0;
            gameState.totalCorrectAnswers = 0; // 重置答對數
            gameState.totalQuestions = 0; // 重置總題數
            gameState.totalMistakes = 0; // 重置失誤次數
            gameState.levelResults = {}; // 重置關卡結果

            // track used verses across the entire game to avoid duplicates between levels
            try { gameState.usedVerses = new Set(); } catch (e) { gameState.usedVerses = new Set(); }

            // Ensure any replay-related flags are cleared for a fresh game started from the home screen
            gameState.skipLeaderboardOnComplete = false;
            gameState.replaySourceRecord = null;
            console.log('[GAME] actuallyStartGame: cleared replay flags', { skipLeaderboardOnComplete: gameState.skipLeaderboardOnComplete, replaySourceRecord: gameState.replaySourceRecord });
            // If the player-name modal was left in viewing mode, reset it so normal save flow works
            try {
                const modal = document.getElementById('playerNameModal');
                if (modal) {
                    modal.dataset.viewingRecord = '';
                    modal.dataset.viewingDifficulty = '';
                }
            } catch (e) {}

            // 強制分數顯示歸零
            const scoreElement = document.getElementById('centerScore');
            if (scoreElement) scoreElement.textContent = '0';

            // 設置提示次數
            const hintCounts = { easy: 3, normal: 3, hard: 3 };
            gameState.hintsRemaining = hintCounts[gameState.difficulty];

            hideAllScreens();
            document.getElementById('gameScreen').classList.remove('hidden');

            generateLevel();
            updateGameUI();

            // 應用時間獎勵顯示設定
            updateTimeRewardVisibility();
        }

    // 生成一個關卡（抽題、重置狀態、更新 UI）
    // Generate a new level: pick questions, reset per-level state, update UI
    function generateLevel() {
            // 所有難度都是5題/關
            let questionCount = 5;
            // 取得可用經文（已自動補足）
            let availableVerses = getAvailableVerses();
            // Debug: log available and used verses
            try {
                const usedKey = (v) => `${v.book}|${v.chapter}|${v.verse}`;
                const usedVersesSet = gameState.usedVerses || new Set();
                const usedCount = usedVersesSet.size;
                const availableCount = availableVerses.length;
                const unusedCount = availableVerses.filter(v => !usedVersesSet.has(usedKey(v))).length;
                console.log(`[DEBUG] generateLevel: available=${availableCount}, used=${usedCount}, unused=${unusedCount}, currentLevel=${gameState.currentLevel}`);
            } catch (e) { console.warn('[DEBUG] generateLevel: logging failed', e); }
            // 依難度決定題型分布
            let selectedVerses = [];
            if (gameState.difficulty === 'hard') {
                // 只用最多三個書卷，題型分布機率 50/35/10/5
                const allBooks = [...new Set(availableVerses.map(v => v.book))];
                let bookCombos = [];
                if (allBooks.length <= 3) {
                    bookCombos = [allBooks];
                } else {
                    for (let i = 0; i < allBooks.length; i++)
                      for (let j = i+1; j < allBooks.length; j++)
                        for (let k = j+1; k < allBooks.length; k++)
                          bookCombos.push([allBooks[i], allBooks[j], allBooks[k]]);
                }
                const patterns = [
                    { dist: [2,2,1], prob: 0.5 },
                    { dist: [3,2,0], prob: 0.35 },
                    { dist: [4,1,0], prob: 0.10 },
                    { dist: [5,0,0], prob: 0.05 }
                ];
                const books = bookCombos[Math.floor(Math.random()*bookCombos.length)];
                const r = Math.random();
                let acc = 0, chosenPattern = patterns[0];
                for (const p of patterns) { acc += p.prob; if (r < acc) { chosenPattern = p; break; } }
                // 隨機化三書卷的順序，避免固定順序帶來偏差
                const booksOrdered = books.slice().sort(() => Math.random() - 0.5);
                let poolByBook = booksOrdered.map(b => availableVerses.filter(v => v.book === b));
                for (let i = 0; i < 3; ++i) {
                    for (let j = 0; j < chosenPattern.dist[i]; ++j) {
                        if (poolByBook[i] && poolByBook[i].length > 0) {
                            const idx = Math.floor(Math.random()*poolByBook[i].length);
                            selectedVerses.push(poolByBook[i][idx]);
                            poolByBook[i].splice(idx,1);
                        }
                    }
                }
                if (selectedVerses.length < questionCount) {
                    const used = new Set(selectedVerses.map(v => `${v.book}|${v.chapter}|${v.verse}`));
                    const rest = availableVerses.filter(v => !used.has(`${v.book}|${v.chapter}|${v.verse}`));
                    while (selectedVerses.length < questionCount && rest.length > 0) {
                        const idx = Math.floor(Math.random()*rest.length);
                        selectedVerses.push(rest[idx]);
                        rest.splice(idx,1);
                    }
                }
            } else if (gameState.difficulty === 'normal') {
                // 至少三個書卷，題型分布 40/35/25
                const allBooks = [...new Set(availableVerses.map(v => v.book))];
                const patterns = [
                    { dist: [2,2,1], prob: 0.4 },
                    { dist: [2,1,1,1], prob: 0.35 },
                    { dist: [1,1,1,1,1], prob: 0.25 }
                ];
                const r = Math.random();
                let acc = 0, chosenPattern = patterns[0];
                for (const p of patterns) { acc += p.prob; if (r < acc) { chosenPattern = p; break; } }
                // 依分布長度動態抽書卷數（3/4/5），不足時降級為可用的書卷數
                const needBooks = chosenPattern.dist.length;
                const shuffledBooks = allBooks.slice().sort(() => Math.random() - 0.5);
                const pickedBooks = shuffledBooks.slice(0, Math.min(needBooks, shuffledBooks.length));
                let poolByBook = pickedBooks.map(b => availableVerses.filter(v => v.book === b));
                for (let i = 0; i < Math.min(chosenPattern.dist.length, pickedBooks.length); ++i) {
                    for (let j = 0; j < chosenPattern.dist[i]; ++j) {
                        if (poolByBook[i] && poolByBook[i].length > 0) {
                            const idx = Math.floor(Math.random()*poolByBook[i].length);
                            selectedVerses.push(poolByBook[i][idx]);
                            poolByBook[i].splice(idx,1);
                        }
                    }
                }
                if (selectedVerses.length < questionCount) {
                    const used = new Set(selectedVerses.map(v => `${v.book}|${v.chapter}|${v.verse}`));
                    const rest = availableVerses.filter(v => !used.has(`${v.book}|${v.chapter}|${v.verse}`));
                    while (selectedVerses.length < questionCount && rest.length > 0) {
                        const idx = Math.floor(Math.random()*rest.length);
                        selectedVerses.push(rest[idx]);
                        rest.splice(idx,1);
                    }
                }
            }
            // 其他難度維持原本邏輯
            // 簡單模式預先過濾出「可拆分」的題庫，盡可能擴大可用池
            if (gameState.difficulty === 'easy') {
                const before = availableVerses.length;
                // 僅接受「在標點切分」的可拆分題目（避免中間硬切造成語意不順）
                availableVerses = availableVerses.filter(v => trySplitVerseText(v.verse, true));
                const after = availableVerses.length;
                if (after < before) {
                    console.log(`簡單模式：可拆分題庫 ${after}/${before}`);
                }

                // 若可拆分的題庫仍不足 5 題，嘗試合併相鄰經文（同章的相鄰節）生成較長文本
                if (availableVerses.length < questionCount) {
                    const extended = synthesizeCombinedVerses(getAvailableVerses());
                    if (extended.length) {
                        // 僅保留可拆分的合併結果
                        const addable = extended.filter(v => trySplitVerseText(v.verse, true));
                        // 合併去重（避免與原本可拆分的重複）
                        const key = v => `${v.book}|${v.chapter}|${v.verse}`;
                        const seen = new Set(availableVerses.map(key));
                        for (const it of addable) {
                            const k = key(it);
                            if (!seen.has(k)) {
                                availableVerses.push(it);
                                seen.add(k);
                            }
                            if (availableVerses.length >= questionCount * 2) break; // 適度擴充，避免過大
                        }
                        console.log(`簡單模式：合併相鄰經文後，可拆分題庫 = ${availableVerses.length}`);
                    }
                }
            }
            
            // 檢查可用經文數量
            console.log(`可用經文數量: ${availableVerses.length}`);
            console.log(`選擇的書卷:`, gameState.customBooks);
            
            // 確保有足夠的經文（至少 5 題）
            if (availableVerses.length < questionCount) {
                console.warn('[DEBUG] generateLevel: insufficient availableVerses', { available: availableVerses.length, required: questionCount, range: gameState.range, rarity: gameState.rarity, customBooks: gameState.customBooks });
                // 防止因早期 return 導致互動長時間被鎖住
                try { setLevelInteractionLock(false); } catch(_) {}
                alert('此難度可用經文不足（至少需要 5 篇），請擴大範圍或改選其他難度！');
                return;
            }
            
        if (gameState.difficulty === 'easy') {
            // ...existing code for easy模式...
            gameState.questionData = [];
            let attempts = 0;
            const maxAttempts = Math.max(availableVerses.length * 3, 30);
            const usedKey = (v) => `${v.book}|${v.chapter}|${v.verse}`;
            const usedVersesSet = gameState.usedVerses || new Set();
            let versesToChooseFrom = availableVerses.filter(v => !usedVersesSet.has(usedKey(v)));
            if (versesToChooseFrom.length < questionCount) {
                versesToChooseFrom = [...availableVerses];
            }
            while (gameState.questionData.length < questionCount && attempts < maxAttempts) {
                attempts++;
                if (versesToChooseFrom.length === 0) break;
                const randomIndex = Math.floor(Math.random() * versesToChooseFrom.length);
                let selectedVerse = versesToChooseFrom[randomIndex];
                const alreadyInThisLevel = gameState.questionData.some(q => q.book === selectedVerse.book && q.chapter === selectedVerse.chapter && q.verse === selectedVerse.verse);
                const alreadyUsedInGame = usedVersesSet.has(usedKey(selectedVerse));
                if (alreadyInThisLevel || alreadyUsedInGame) {
                    versesToChooseFrom.splice(randomIndex, 1);
                    continue;
                }
                const verseClean = sanitizeVerseText(selectedVerse.verse);
                const split = trySplitVerseText(verseClean, true);
                if (split) {
                    const cleanFront = stripOuterCornerQuotes(split.front);
                    const cleanBack = stripOuterCornerQuotes(split.back);
                    gameState.questionData.push({
                        pairId: `${selectedVerse.book}_${selectedVerse.chapter}_${selectedVerse.verse.slice(0,8).replace(/\s+/g,'')}`,
                        book: selectedVerse.book,
                        chapter: selectedVerse.chapter,
                        front: cleanFront,
                        back: cleanBack,
                        original: selectedVerse
                    });
                } else {
                    versesToChooseFrom.splice(randomIndex, 1);
                    continue;
                }
                try { usedVersesSet.add(usedKey(selectedVerse)); } catch (e) {}
                versesToChooseFrom.splice(randomIndex, 1);
            }
        } else if (selectedVerses.length > 0) {
            gameState.questionData = selectedVerses;
            const usedKey = (v) => `${v.book}|${v.chapter}|${v.verse}`;
            const usedVersesSet = gameState.usedVerses || new Set();
            for (const v of selectedVerses) try { usedVersesSet.add(usedKey(v)); } catch(e) {}
            gameState.usedVerses = usedVersesSet;
        }
        console.log(`最終生成 ${gameState.questionData.length} 道題目`);
        gameState.currentQuestion = 1;
        gameState.levelPerfect = true;
        gameState.questionAttempts = {};
        gameState.totalQuestions += gameState.questionData.length;
        gameState.isFirstQuestionOfLevel = true;
        gameState.questionData.forEach((_, index) => {
            const maxAttempts = { easy: 3, normal: 3, hard: 3 };
            gameState.questionAttempts[index] = maxAttempts[gameState.difficulty];
        });
        displayQuestions();
        setTimeout(() => {
            gameState.levelStartTime = Date.now();
            startLevelTimer();
        }, 100);
        }

    // 依目前的範圍/罕見度/自訂書卷過濾可用經文
    // Filter available verses based on range/rarity/custom books
    function getAvailableVerses() {
        let availableBooks = [];
        switch (gameState.range) {
            case 'all':
                availableBooks = [...bibleBooks.old, ...bibleBooks.new];
                break;
            case 'testament':
                availableBooks = bibleBooks[gameState.testament];
                break;
            case 'custom':
                availableBooks = gameState.customBooks;
                break;
        }
        if (availableBooks.length === 0) availableBooks = [...bibleBooks.old, ...bibleBooks.new];
        let pool = getActiveVerseDB().filter(v => availableBooks.includes(v.book));
        const need = 5;
        const inPractice = !!gameState.range;
        let isRarityMode = !inPractice && gameState.rarity && (gameState.rarity === 'rare' || gameState.rarity === 'common');
        if (isRarityMode) {
            let filtered = pool;
            if (gameState.rarity === 'rare') {
                filtered = pool.filter(v => v.rarity === 'rare' || v.rarity === 'uncommon');
            } else if (gameState.rarity === 'common') {
                filtered = pool.filter(v => v.rarity === 'common');
            }
            if (filtered.length < need) {
                let result = [...filtered];
                let allPool = getActiveVerseDB();
                const seen = new Set(result.map(v => `${v.book}|${v.chapter}|${v.verse}`));
                for (const v of allPool) {
                    const k = `${v.book}|${v.chapter}|${v.verse}`;
                    if (!seen.has(k)) {
                        result.push(v);
                        seen.add(k);
                        if (result.length >= need) break;
                    }
                }
                pool = result;
            } else {
                pool = filtered;
            }
        }
        return pool.sort(() => Math.random() - 0.5);
        }

    // 合併相鄰（同書卷同章、連續節數）產生較長文本（供簡單模式切前/後段）
    // Merge adjacent verses (same book+chapter, consecutive verse numbers) to form longer text
    // for easy mode split. Only expands easy pool; preserves original book/chapter in UI.
        // 由相鄰/連續節號嘗試合併成更完整的題目
        // Combine adjacent verses to form richer prompts when appropriate
        function synthesizeCombinedVerses(candidates) {
            try {
                const arr = Array.isArray(candidates) ? [...candidates] : [];
                if (arr.length === 0) return [];
                // 將章節字串分離章:節; 僅處理單節（不含 '-' 範圍）的情形
                function parseChap(ch) {
                    const s = String(ch || '').trim();
                    const m = s.match(/^(\d+):(\d+)$/);
                    if (!m) return null;
                    return { c: parseInt(m[1], 10), v: parseInt(m[2], 10), raw: s };
                }
                // 先排序，才能在同書卷同章中尋找「節數相鄰」的配對
                // Sort by book, chapter, and verse to find adjacent pairs.
                arr.sort((a,b) => {
                    if (a.book !== b.book) return a.book.localeCompare(b.book);
                    const pa = parseChap(a.chapter) || { c: 0, v: 0 };
                    const pb = parseChap(b.chapter) || { c: 0, v: 0 };
                    if (pa.c !== pb.c) return pa.c - pb.c;
                    return pa.v - pb.v;
                });
                const out = [];
                for (let i = 0; i < arr.length - 1; i++) {
                    const cur = arr[i];
                    const nxt = arr[i+1];
                    const p1 = parseChap(cur.chapter);
                    const p2 = parseChap(nxt.chapter);
                    if (!p1 || !p2) continue;
                    // 同書卷、同章、且下一節的節數 = 當前節 + 1
                    // Same book+chapter and verse number is consecutive => merge a pair.
                    if (cur.book === nxt.book && p1.c === p2.c && p2.v === p1.v + 1) {
                        // 合併文本時，若前文末尾無結尾句號，適度加入空格
                        const sep = /[。！？….!?；;:]$/.test(cur.verse) ? '' : ' ';
                        const mergedText = `${cur.verse}${sep}${nxt.verse}`.trim();
                        // UI 仍使用第一節的 chapter 文本；完整原文對保存在 originalCombined 以供除錯/回放
                        // Keep first verse's chapter string for display; store originals in originalCombined.
                        const rarity = cur.rarity || nxt.rarity || 'common';
                        out.push({
                            book: cur.book,
                            chapter: cur.chapter, // 顯示以首節為主
                            verse: mergedText,
                            version: cur.version || nxt.version,
                            rarity,
                            originalCombined: [cur, nxt]
                        });
                    }
                }
                return out;
            } catch (e) {
                return [];
            }
        }

    // 嘗試將經文在合理位置拆成前後兩段（優先在標點或空白處切分）
    // Try to split a verse into front/back segments at natural punctuation/whitespace.
    // 嘗試把過長的經文按斷句拆分（保留語意）
    // Try splitting a long verse into sentence-like parts
    function trySplitVerseText(text, strictPunctuation = false) {
            // 盡可能擴充可用題庫：放寬最短字數門檻，但仍確保兩段都有可讀長度
            if (!text) return null;
            const raw = String(text).trim();
            if (raw.length < 16) return null; // 太短的不拆分

            // 強/弱標點分級：先找強標點（句號/問號/驚嘆號/分號/冒號/省略號），再退回弱標點（逗號/頓號/空白）
            const STRONG = new Set(['。','！','？','；','：','…','.','!','?',';',':']);
            const WEAK = new Set(['，','、',',',' ']);
            const isPunct = (ch) => STRONG.has(ch) || WEAK.has(ch);
            const mid = Math.floor(raw.length / 2);
            const searchRange = 16;

            // 幫助：建立切分 pair，並將後半段的前導標點適度移到前半段尾端，避免以標點開頭
            const buildPair = (cutIdxInclusive) => {
                let front = raw.slice(0, cutIdxInclusive + 1).trim();
                let back = raw.slice(cutIdxInclusive + 1).trim();
                const leading = back.match(/^[\s，。、！？…!？，.;；:："'“”『』（）()【】\[\]\-—–、，。！？…]+/);
                if (leading) {
                    const lead = leading[0];
                    const nf = (front + lead).trim();
                    const nb = back.slice(lead.length).trim();
                    if (nf.length >= 6 && nb.length >= 6) { front = nf; back = nb; }
                }
                // 進一步避免兩段頭尾落在引號或逗號等不佳位置（需同時滿足最小長度）
                const badEnd = /[“”"'『』，、,]$/;
                const badStart = /^[“”"'『』，、,]/;
                if (front.length >= 6 && back.length >= 6 && !badEnd.test(front) && !badStart.test(back)) return { front, back };
                return null;
            };

            // 1) 強標點優先，從中間向外擴散尋找
            for (let d = 0; d <= searchRange; d++) {
                const L = mid - d, R = mid + d;
                if (L > 2) {
                    const ch = raw[L];
                    if (STRONG.has(ch)) {
                        const pair = buildPair(L);
                        if (pair) return pair;
                    }
                }
                if (R < raw.length - 2) {
                    const ch = raw[R];
                    if (STRONG.has(ch)) {
                        const pair = buildPair(R);
                        if (pair) return pair;
                    }
                }
            }

            // 2) 退而求其次：弱標點（逗號/頓號/空白）
            for (let d = 0; d <= searchRange; d++) {
                const L = mid - d, R = mid + d;
                if (L > 2) {
                    const ch = raw[L];
                    if (WEAK.has(ch)) {
                        const pair = buildPair(L);
                        if (pair) return pair;
                    }
                }
                if (R < raw.length - 2) {
                    const ch = raw[R];
                    if (WEAK.has(ch)) {
                        const pair = buildPair(R);
                        if (pair) return pair;
                    }
                }
            }

            // 3) 最後手段：若允許，直接在中位數切分並修正後段前導標點（strict 模式下跳過）
            if (strictPunctuation) return null;
            const cut = mid;
            let front = raw.slice(0, cut).trim();
            let back = raw.slice(cut).trim();
            const leading = back.match(/^[\s，。、！？…!？，.;；:："'“”『』（）()【】\[\]\-—–、，。！？…]+/);
            if (leading) {
                const lead = leading[0];
                const nf = (front + lead).trim();
                const nb = back.slice(lead.length).trim();
                if (nf.length >= 6 && nb.length >= 6) { front = nf; back = nb; }
            }
            if (front.length >= 6 && back.length >= 6) return { front, back };
            return null;
        }

    // 小工具：移除字串頭尾的中文引號（「」/『』）與英引號；僅用於簡單難度前/後段的視覺清潔
    // Helper: strip leading/trailing Chinese/English quotes for easy-mode segment display only.
    // 去除外層中文引號（「…」/『…』）包裹
    // Strip outer Chinese corner quotes if present
    function stripOuterCornerQuotes(s) {
            if (s == null) return s;
            const str = String(s);
            // 只清除頭尾連續的引號符號，不影響中間內容
            return str
                .replace(/^[「」『』“”"']+/, '')
                .replace(/[「」『』“”"']+$/, '')
                .trim();
        }

        // --- In-page confirm modal helper (used to replace native confirm for reliability) ---
    // 遊戲中途返回的確認對話框（若不存在則動態建立）
    // Ensure the in-game confirm modal exists; create lazily
    function ensureConfirmModalExists() {
            if (document.getElementById('inPageConfirmModal')) return;
            const div = document.createElement('div');
            div.id = 'inPageConfirmModal';
            div.className = 'fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-60';
            div.innerHTML = `
                <div class="cute-card bg-white p-6 max-w-lg mx-4 text-center rounded-xl">
                    <div id="inPageConfirmMessage" class="text-base text-gray-800 mb-4"></div>
                    <div class="flex gap-3 justify-center mt-4">
                        <button id="inPageConfirmYes" class="cute-button bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-bold">繼續</button>
                        <button id="inPageConfirmNo" class="cute-button bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded-lg font-bold">取消</button>
                    </div>
                </div>
            `;
            document.body.appendChild(div);
            document.getElementById('inPageConfirmYes').addEventListener('click', () => {
                div.dataset.choice = 'yes';
                div.classList.add('hidden');
            });
            document.getElementById('inPageConfirmNo').addEventListener('click', () => {
                div.dataset.choice = 'no';
                div.classList.add('hidden');
            });
        }

    // 顯示一個頁內確認提示（非阻塞），供返回/關鍵操作使用
    // Show a lightweight in-page confirm for return/critical actions
    function showInPageConfirm(message) {
            return new Promise((resolve) => {
                ensureConfirmModalExists();
                const modal = document.getElementById('inPageConfirmModal');
                const msg = document.getElementById('inPageConfirmMessage');
                modal.dataset.choice = '';
                if (msg) msg.textContent = message || '';
                modal.classList.remove('hidden');

                // poll for choice (simple approach to avoid complex event plumbing)
                const interval = setInterval(() => {
                    const choice = modal.dataset.choice;
                    if (choice === 'yes' || choice === 'no') {
                        clearInterval(interval);
                        resolve(choice === 'yes');
                    }
                }, 100);
            });
        }

    // ...existing code...

    // 渲染本關題目卡片（經文卡＋章節卡）
    // Render question cards for the current level
    function displayQuestions() {
            const versesContainer = document.getElementById('gameVerses');
            const chaptersContainer = document.getElementById('gameChapters');
            // 不主動清除吐司提示，避免剛顯示就被隱藏造成閃動；
            // 新提示會直接覆蓋內容並保持顯示。
            // 根據難度動態顯示標題：簡單顯示「前 段 經 文 / 後 段 經 文」，其餘難度保持原本「經 文 內 容 / 章 節 選 擇」
            const verseTitleEl = document.getElementById('verseTitle');
            const chapterTitleEl = document.getElementById('chapterTitle');
            if (verseTitleEl && chapterTitleEl) {
                if (gameState.difficulty === 'easy') {
                    verseTitleEl.innerHTML = `<span class="text-4xl animate-pulse mr-4">📜</span><span class="tracking-widest bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">前 段 經 文</span><span class="text-4xl animate-pulse ml-4">📜</span>`;
                    chapterTitleEl.innerHTML = `<span class="text-4xl animate-pulse mr-4">📍</span><span class="tracking-widest bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">後 段 經 文</span><span class="text-4xl animate-pulse ml-4">📍</span>`;
                } else {
                    verseTitleEl.innerHTML = `<span class="text-4xl animate-pulse mr-4">📜</span><span class="tracking-widest bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">經 文 內 容</span><span class="text-4xl animate-pulse ml-4">📜</span>`;
                    chapterTitleEl.innerHTML = `<span class="text-4xl animate-pulse mr-4">📍</span><span class="tracking-widest bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">章 節 選 擇</span><span class="text-4xl animate-pulse ml-4">📍</span>`;
                }
            }

            versesContainer.innerHTML = '';
            chaptersContainer.innerHTML = '';
            
            // 顯示經文 (簡單難度為前段；其他為整段經文)
            gameState.questionData.forEach((item, index) => {
                // 簡單難度：移除頭尾「」符號（舊快照亦在此保險處理）
                const verseText = (gameState.difficulty === 'easy') ? stripOuterCornerQuotes(item.front) : item.verse;
                const verseCard = createVerseCard(verseText, index);
                versesContainer.appendChild(verseCard);
            });
            
            // 顯示章節選項（打亂順序）
            // 章節 / 後段顯示（簡單模式顯示後段經文作為選項）
            const shuffledChapters = [...gameState.questionData].sort(() => Math.random() - 0.5);
            shuffledChapters.forEach((item, index) => {
                let chapterText;
                if (gameState.difficulty === 'easy') {
                    // 簡單難度選項顯示後段經文，同樣移除頭尾「」
                    chapterText = stripOuterCornerQuotes(item.back);
                } else {
                    chapterText = (gameState.difficulty === 'easy' || gameState.difficulty === 'normal') ? item.book : `${item.book} ${item.chapter}`;
                }
                const chapterCard = createChapterCard(chapterText, item);
                chaptersContainer.appendChild(chapterCard);
            });
            
            // 進場動畫：不規則從右側滑入（使用隨機 delay/位移/角度/時長）
            try {
                const allCards = [
                    ...versesContainer.querySelectorAll('.verse-card'),
                    ...chaptersContainer.querySelectorAll('.chapter-card')
                ];
                const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                const baseDelay = 10; // 毫秒（原 40 → 10，讓下一關更快進場）
                allCards.forEach((el, i) => {
                    const jitter = (min, max) => Math.random() * (max - min) + min;
                    const delay = prefersReduce ? 0 : Math.round(i * baseDelay + jitter(0, 24));
                    const dx = Math.round(jitter(80, 160));
                    const dy = Math.round(jitter(-10, 12));
                    // 普通/綠色卡片不傾斜：進場時不旋轉
                    const dr = '0deg';
                    const dur = prefersReduce ? 0 : Math.round(jitter(460, 620));
                    el.style.setProperty('--enterDelay', `${delay}ms`);
                    el.style.setProperty('--enterX', `${dx}px`);
                    el.style.setProperty('--enterY', `${dy}px`);
                    el.style.setProperty('--enterR', dr);
                    el.style.setProperty('--enterDur', `${dur}ms`);
                    el.classList.add('card-enter');
                });
            } catch (_) { /* non-fatal */ }
            
            // 僅在第一關的第一題顯示遊戲提示（可愛語氣吐司提示，不自動關閉）
            if (gameState.currentLevel === 1 && gameState.isFirstQuestionOfLevel) {
                const introPool = (gameState.difficulty === 'easy') ? HINTS.play.introEasy : HINTS.play.introOther;
                // 顯示首個指示 2.8 秒
                gameState._fadeVerseInstruction = showGameInstruction(pick(introPool), 2800);
            }
        }

        // 返回對應的文字大小 class（共用給章節卡與簡單模式的前段經文）
    // 根據經文長度決定卡片字級
    // Pick font-size class based on verse length
    function getCardTextSize(text) {
            if (!text) return 'text-lg';
            if (text.length <= 8) return 'text-xl';
            if (text.length <= 15) return 'text-lg';
            if (text.length <= 25) return 'text-base';
            return 'text-sm';
        }

    // 產生經文卡片（依嘗試次數顯示顏色；行動裝置於 carousel 中以 full-width 呈現）
    // Create verse card with color by attempts; on mobile carousel use full-width layout.
    // 建立經文卡片（可點選）
    // Create a verse card element
    function createVerseCard(verse, index) {
            const card = document.createElement('div');
            const attempts = gameState.questionAttempts[index];
            const maxAttempts = { easy: 3, normal: 3, hard: 3 };
            const originalAttempts = maxAttempts[gameState.difficulty];
            
            // 若該經文還未作答（嘗試次數等於原始次數），一律顯示藍色
            let bgColor = 'bg-blue-50 border-blue-200';
            if (attempts < originalAttempts) {
                // 已經作答過但還有機會，根據剩餘次數顯示不同顏色
                if (attempts === 2) bgColor = 'bg-yellow-100 border-yellow-300';
                else if (attempts === 1) bgColor = 'bg-orange-100 border-orange-300';
                else if (attempts === 0) bgColor = 'bg-red-100 border-red-300';
            }
            
            // 根據是否在 carousel 內調整卡片樣式：carousel 僅在手機視窗下啟用
            const inCarousel = !!document.getElementById('versesCarousel') && window.matchMedia('(max-width: 760px)').matches;
            let widthClass = inCarousel ? 'w-full' : 'w-64'; // 使用 full-width 作為 carousel 的預設
            let heightClass = inCarousel ? 'min-h-[64px]' : 'min-h-[120px]';

            if (!inCarousel) {
                if (verse.length <= 30) {
                    widthClass = 'w-48';
                    heightClass = 'min-h-[80px]';
                } else if (verse.length <= 60) {
                    widthClass = 'w-56';
                    heightClass = 'min-h-[90px]';
                } else if (verse.length <= 100) {
                    widthClass = 'w-72';
                    heightClass = 'min-h-[100px]';
                } else {
                    widthClass = 'w-80';
                    heightClass = 'min-h-[110px]';
                }
            }

            // 在 carousel 情況下，不使用 flex-shrink-0 並改為垂直對齊
            card.className = inCarousel
                ? `verse-card ${bgColor} border-2 p-2 ${heightClass} ${widthClass} flex items-center justify-between` 
                : `verse-card ${bgColor} border-2 p-2 ${heightClass} ${widthClass} flex items-center justify-center flex-shrink-0`;
            card.dataset.index = index;
            // 綱一致化：所有難度使用與簡單模式相同的文字大小/字重規則，並以藍色文字顯示經文內容
            const textSize = getCardTextSize(verse);
            card.innerHTML = `<div class="font-normal text-blue-800 ${textSize} leading-tight break-words text-center max-w-full">${verse}</div>`;
            
            // 鍵盤可達性
            card.setAttribute('tabindex', '0');
            card.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); selectVerse(index); }
            });
            // 添加點擊事件 + subtle click effect
        card.addEventListener('click', (ev) => {
                // visual: small blue-themed star burst from the card
                try {
                    // If clicking the same selected verse, treat as deselect: no particle effect
                    if (gameState.selectedVerseIndex === index) {
                        selectVerse(index);
                        return;
                    }
                    const rect = card.getBoundingClientRect();
                    const attemptsLeft = gameState.questionAttempts[index];
            // palette: blue/cyan; simpler sparkle glyph, fewer, closer
            let colors = ['#93C5FD','#60A5FA','#3B82F6','#06B6D4','#67E8F9'];
            if (attemptsLeft === 1) colors = ['#F59E0B','#FBBF24','#FDE68A'];
            if (attemptsLeft === 0) colors = ['#F87171','#FB7185','#FCA5A5'];
            // extremely subtle front-verse click effect: almost invisible
            spawnScoreParticles(5, rect, { colors, glyph: '·', count: 1, distanceMin: 4, distanceMax: 10, durationMs: 380, opacity: 0.18, sizeMin: 6, sizeMax: 8 });
                } catch(_) {}
                selectVerse(index);
            });
            
            return card;
        }

    // 產生章節/後段卡片（手機 carousel 與桌面版不同尺寸；含配對用 data-* 標記）
    // Create chapter/back card; mobile carousel uses compact size; includes data for matching.
    // 建立章節卡片（作為配對目標）
    // Create a chapter card element as match target
    function createChapterCard(chapterText, originalData) {
            const card = document.createElement('div');
            
            // 在 carousel 中使用 full-width 垂直列表樣式（僅在手機視窗）
            const inCarousel = !!document.getElementById('versesCarousel') && window.matchMedia('(max-width: 760px)').matches;
            let widthClass = inCarousel ? 'w-full' : 'w-48';
            if (!inCarousel) {
                if (chapterText.length <= 8) widthClass = 'w-36';
                else if (chapterText.length <= 15) widthClass = 'w-44';
                else if (chapterText.length <= 25) widthClass = 'w-52';
                else widthClass = 'w-60';
            }
            const textSize = getCardTextSize(chapterText);

            // On mobile (carousel) use the same compact sizing as verse cards so front/back panels match
            card.className = inCarousel
                ? `chapter-card bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-300 p-2 text-center min-h-[64px] ${widthClass} flex items-center justify-between shadow-sm transition-all duration-150`
                : `chapter-card bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-300 p-4 text-center min-h-[80px] ${widthClass} flex items-center justify-center flex-shrink-0 shadow-lg hover:shadow-xl transition-all duration-300`;
            // 標記配對資訊（若為 easy 模式，originalData 包含 front/back/pairId）
            if (gameState.difficulty === 'easy' && originalData.pairId) {
                card.dataset.pairId = originalData.pairId;
                card.dataset.book = originalData.book;
                card.dataset.chapter = originalData.chapter;
            } else {
                card.dataset.book = originalData.book;
                card.dataset.chapter = originalData.chapter;
            }
            // 顯示原始章節文字（保留標點），章節文字使用紫色系
            card.innerHTML = `<div class="font-normal text-purple-800 ${textSize} leading-tight break-words text-center max-w-full">${chapterText}</div>`;
            
            // 鍵盤可達性
            card.setAttribute('tabindex', '0');
            card.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); handleChapterClick(card, originalData); }
            });
    card.addEventListener('click', () => {
        // Only show particles when selection is correct (handled inside handleChapterClick)
        handleChapterClick(card, originalData);
        });
            
            return card;
        }

    // 選取前段經文卡：設定選中樣式、顯示教學提示（僅第一關第一題），並在手機自動滑到後段面板
    // Select a verse: mark selected, possibly show first-level guide, and auto-slide to back panel on mobile.
    // 進入某一題（選定經文卡）；鎖定前面面板
    // Select a verse index and show its matching options
    function selectVerse(index) {
            // 移除之前選中的經文樣式
            document.querySelectorAll('.verse-card').forEach(card => {
                card.classList.remove('selected-verse');
            });
            
            // 選中當前經文
            const selectedCard = document.querySelector(`[data-index="${index}"]`);
            if (selectedCard && gameState.questionAttempts[index] > 0) {
                selectedCard.classList.add('selected-verse');
                gameState.selectedVerseIndex = index;

                // 僅在第一關的第一題顯示選擇章節/配對的提示
                if (gameState.currentLevel === 1 && gameState.isFirstQuestionOfLevel) {
                        // 先淡出上一個提示，再延遲顯示下一個提示，避免同時被隱藏
                        if (gameState._fadeVerseInstruction) {
                            gameState._fadeVerseInstruction();
                            gameState._fadeVerseInstruction = null;
                        }
                        const pairPool = (gameState.difficulty === 'easy') ? HINTS.play.pairEasy : HINTS.play.pairOther;
                        setTimeout(() => {
                            // 顯示第二段 2.8 秒
                            gameState._fadeChapterInstruction = showGameInstruction(pick(pairPool), 2800);
                        }, 260); // 等待上一個淡出動畫
                        gameState.isFirstQuestionOfLevel = false;
                }
                // 如果是在手機並存在 carousel，將視圖自動滑到後段章節面板，協助使用者選擇
                const carousel = document.getElementById('versesCarousel');
                if (carousel && window.innerWidth <= 760) {
                    // 僅水平滑動到第二個面板 (back)，避免影響垂直位置
                    const panels = carousel.querySelectorAll('.panel');
                    if (panels && panels.length > 1) {
                        const backPanel = panels[1];
                        try {
                            const carRect = carousel.getBoundingClientRect();
                            const backRect = backPanel.getBoundingClientRect();
                            const targetLeft = (backRect.left - carRect.left) + carousel.scrollLeft;
                            carousel.scrollTo({ left: targetLeft, behavior: 'smooth' });
                        } catch (_) {
                            // fallback
                            carousel.scrollLeft = backPanel.offsetLeft;
                        }
                    }
                }
            }
        }

        // 手機環境下，將焦點與視窗回到前段經文面板並嘗試聚焦第一張經文卡
    // 手機：將 carousel 視角滑回前段面板，並盡量把焦點放回第一張經文卡（確保可達性）
    // Mobile: scroll carousel back to the front panel and focus first verse for accessibility.
    // 將前面板滾動到視口中（行動裝置優化）
    // Scroll the front panel into view for mobile
    function scrollToFrontPanel() {
            const carousel = document.getElementById('versesCarousel');
            if (!carousel || window.innerWidth > 760) return;
            const panels = carousel.querySelectorAll('.panel');
            if (!panels || panels.length === 0) return;
            const frontPanel = panels[0];
            try {
                // 僅水平滑動回前段面板，保持目前的垂直位置不變
                const carRect = carousel.getBoundingClientRect();
                const frontRect = frontPanel.getBoundingClientRect();
                const targetLeft = (frontRect.left - carRect.left) + carousel.scrollLeft;
                carousel.scrollTo({ left: targetLeft, behavior: 'smooth' });

                // 優先嘗試聚焦第一張經文卡，若不存在則聚焦 panel 本身（使用 tabindex -1 確保可聚焦）
                const firstVerse = frontPanel.querySelector('.verse-card');
                if (firstVerse) {
                    if (!firstVerse.hasAttribute('tabindex')) firstVerse.setAttribute('tabindex', '-1');
                    firstVerse.focus({ preventScroll: true });
                } else {
                    if (!frontPanel.hasAttribute('tabindex')) frontPanel.setAttribute('tabindex', '-1');
                    frontPanel.focus({ preventScroll: true });
                }
            } catch (e) {
                // defensive: ignore focus errors
            }
        }

    // 啟動關卡計時器（供時間獎懲與顯示）
    // Start per-level timer for time reward and display
    function startLevelTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            gameState.timerInterval = setInterval(() => {
                updateCurrentScore();
            }, 100); // 每100ms更新一次
        }

    // 更新頂部分數顯示（含動畫）
    // Update the center score display with counting animation
    function updateCurrentScore() {
            const elapsed = (Date.now() - gameState.levelStartTime) / 1000; // 秒
            let timeRewardScore = 0;
            const TIME_SCALE = 10; // scale time reward by 10x (original ±5 -> now ±50)
            
            if (gameState.showTimeReward) {
                // New piecewise rules (display range: +50 ... -50)
                //  - elapsed <= 8s => +50
                //  - 8s < elapsed <= 40s => linear from +50 down to 0
                //  - 40s < elapsed <= 120s => linear from 0 down to -50
                //  - elapsed > 120s => -50
                const POS_MAX = 50;
                const NEG_MIN = -50;

                if (elapsed <= 8) {
                    timeRewardScore = POS_MAX;
                } else if (elapsed <= 40) {
                    // map [8,40] -> [50,0]
                    const t = (elapsed - 8) / (40 - 8);
                    timeRewardScore = POS_MAX * (1 - t);
                } else if (elapsed <= 120) {
                    // map (40,120] -> (0,-50]
                    const t = (elapsed - 40) / (120 - 40);
                    timeRewardScore = (0) + (NEG_MIN * t);
                } else {
                    timeRewardScore = NEG_MIN;
                }

                // ensure numeric and clamp
                timeRewardScore = Math.max(NEG_MIN, Math.min(POS_MAX, timeRewardScore));
                const displayScore = Math.round(timeRewardScore);

                // 更新分數顯示（整數）
                const scoreElement = document.getElementById('currentQuestionScore');
                if (scoreElement) {
                    scoreElement.textContent = displayScore;
                    // color: positive -> green->yellow, zero -> orange, negative -> red shades
                    if (displayScore > 0) {
                        const ratio = displayScore / POS_MAX; // 0..1
                        const red = Math.floor(255 * (1 - ratio * 0.8));
                        const green = 255;
                        const blue = 0;
                        scoreElement.style.color = `rgb(${red}, ${green}, ${blue})`;
                    } else if (displayScore === 0) {
                        scoreElement.style.color = 'rgb(255,165,0)';
                    } else {
                        const ratio = Math.min(1, Math.abs(displayScore) / Math.abs(NEG_MIN));
                        const red = 255;
                        const green = Math.floor(100 * (1 - ratio));
                        const blue = Math.floor(100 * (1 - ratio));
                        scoreElement.style.color = `rgb(${red}, ${green}, ${blue})`;
                    }
                }

                // 更新進度條（範圍 -50..+50 對應 0..100）
                const scoreProgressFill = document.getElementById('scoreProgressFill');
                if (scoreProgressFill) {
                    const totalProgress = Math.max(0, Math.min(100, (((POS_MAX) - timeRewardScore) / (POS_MAX - NEG_MIN)) * 100));

                    // choose color by thresholds (preserve existing visual cues roughly)
                    let barColor = 'bg-green-500';
                    if (timeRewardScore >= 30) {
                        barColor = 'bg-green-500';
                    } else if (timeRewardScore >= 10) {
                        barColor = 'bg-lime-500';
                    } else if (timeRewardScore >= 0) {
                        barColor = 'bg-yellow-500';
                    } else if (timeRewardScore >= -25) {
                        barColor = 'bg-orange-500';
                    } else {
                        barColor = 'bg-red-600';
                    }

                    scoreProgressFill.className = scoreProgressFill.className.replace(/bg-\w+-\d+/g, '');
                    scoreProgressFill.classList.add(barColor, 'h-full', 'rounded-full', 'transition-all', 'duration-100', 'shadow-sm');
                    scoreProgressFill.style.width = `${100 - totalProgress}%`;

                    // 更新刻度高亮
                    const scaleContainer = scoreProgressFill.parentElement.nextElementSibling;
                    if (scaleContainer) {
                        const scaleNumbers = scaleContainer.querySelectorAll('span');
                        const nearestIndexRaw = Math.round((displayScore + POS_MAX) / (POS_MAX / 5));
                        const nearestIndex = Math.max(0, Math.min(scaleNumbers.length - 1, nearestIndexRaw));
                        scaleNumbers.forEach((span, index) => {
                            span.className = 'text-xs text-gray-500';
                            if (index === nearestIndex) {
                                if (displayScore > 0) span.className = 'text-xs text-white font-bold bg-green-600 px-1 rounded shadow-md';
                                else if (displayScore === 0) span.className = 'text-xs text-white font-bold bg-yellow-600 px-1 rounded shadow-md';
                                else span.className = 'text-xs text-white font-bold bg-red-600 px-1 rounded shadow-md';
                            }
                        });
                    }
                }

                return displayScore;
            }

            return 0;
        }

        // 共用：清除元素上可能阻礙「答對變綠」的錯誤/動畫/紅色類別
    // 清除卡片錯誤樣式
    // Clear error styles from a card element
    function clearErrorState(el) {
            if (!el) return;
            // 移除常見會造成錯誤視覺或阻礙變色的類別
            el.classList.remove('shake-error', 'bg-red-100', 'border-red-300');
            // 若元素內有文字節點，亦清除會覆蓋文字顏色的類別
            try {
                const inner = el.querySelector && el.querySelector('div');
                if (inner) {
                    inner.classList.remove('text-red-800', 'text-yellow-800', 'text-orange-800', 'text-blue-800', 'text-purple-800');
                }
            } catch (e) {
                // defensive: 如果不是 element 或 querySelector 發生例外，忽略
            }
        }

    // 使用者點擊章節卡時的核心判題/計分流程
    // Core answer handler when a chapter card is clicked
    function handleChapterClick(chapterCard, chapterData) {
            // 必須先選擇經文
            if (gameState.selectedVerseIndex === null) {
                return;
            }
            
            const selectedQuestion = gameState.questionData[gameState.selectedVerseIndex];
            
            // 檢查是否正確：
            // - easy：使用 pairId（前段/後段配對）
            // - normal：僅比對書卷名稱
            // - hard：比對書卷與章節
            let isCorrect = false;
            if (gameState.difficulty === 'easy') {
                isCorrect = !!(selectedQuestion.pairId && chapterCard.dataset.pairId && selectedQuestion.pairId === chapterCard.dataset.pairId);
            } else if (gameState.difficulty === 'normal') {
                isCorrect = selectedQuestion.book === chapterData.book;
            } else {
                isCorrect = selectedQuestion.book === chapterData.book && selectedQuestion.chapter === chapterData.chapter;
            }
            
            if (isCorrect) {
                // 淡出遊戲提示
                const existingInstructions = document.querySelectorAll('.game-instruction');
                existingInstructions.forEach(inst => {
                    inst.style.animation = 'instructionFadeOut 1s ease-out forwards';
                    setTimeout(() => {
                        if (inst.parentElement) {
                            inst.parentElement.removeChild(inst);
                        }
                    }, 1000);
                });
                // 同步隱藏可愛吐司提示
                try { hideCuteHint(); } catch (_) {}

                // 取消舊規則：不在答對時根據連續錯誤數顯示提示提醒（改採每關兩題完全答錯觸發）

                // 若該題有提示效果，立即移除（easy 模式使用 pairId）
                const hintVerseCard = document.querySelector(`[data-index="${gameState.selectedVerseIndex}"]`);
                if (hintVerseCard) hintVerseCard.classList.remove('hint-flash');
                if (gameState.difficulty === 'easy') {
                    const hintChapterCard = document.querySelector(`[data-pair-id="${selectedQuestion.pairId}"]`);
                    if (hintChapterCard) hintChapterCard.classList.remove('hint-flash');
                } else {
                    const hintChapterCard = document.querySelector(`[data-book="${chapterData.book}"][data-chapter="${chapterData.chapter}"]`);
                    if (hintChapterCard) hintChapterCard.classList.remove('hint-flash');
                }

                // 記錄答對時的失誤次數（用於進度條顏色判斷）
                const maxAttempts = { easy: 3, normal: 2, hard: 1 };
                const originalAttempts = maxAttempts[gameState.difficulty];
                const currentAttempts = gameState.questionAttempts[gameState.selectedVerseIndex];
                const hadMistakes = currentAttempts < originalAttempts;

                // 答對了
                let scoreGained = 0;
                if (gameState.questionAttempts[gameState.selectedVerseIndex] > 0) {
                    // 基礎分數：練習模式固定 100；排行模式依罕見度（常見/冷門/全部）100/125/150；每次失誤扣50分
                    const mistakeCount = originalAttempts - currentAttempts;
                    const inPractice = !!gameState.range;
                    const rarityBaseMap = { common: 100, rare: 125, all: 150 };
                    const basePerQuestion = inPractice ? 100 : (rarityBaseMap[gameState.rarity] || 100);
                    let totalScore = basePerQuestion - (mistakeCount * 50);
                    
                    // 如果開啟時間獎勵，額外加上時間獎勵分數
                    if (gameState.showTimeReward) {
                        const timeRewardScore = updateCurrentScore();
                        totalScore += timeRewardScore;
                    }
                    // 每題最低分數限制為 0（不允許負分）
                    totalScore = Math.max(0, totalScore);
                    
                    gameState.score += totalScore;
                    scoreGained = totalScore;
                    gameState.totalCorrectAnswers++;
                }
                
                // 標記為正確，並清除任何殘留的錯誤/動畫/紅色類別，確保文字能正確變成綠色
                chapterCard.classList.add('bg-green-100', 'border-green-300');
                chapterCard.classList.remove('bg-gradient-to-br', 'from-purple-50', 'to-purple-100', 'border-purple-300', 'chapter-arrow');
                // 清除可能殘留的錯誤／震動／紅色樣式，統一使用 helper
                clearErrorState(chapterCard);
                // 正確卡片給予輕微彈跳，不與平移衝突（縮放動畫）
                chapterCard.classList.remove('correct-pop');
                void chapterCard.offsetWidth; // reflow to restart
                chapterCard.classList.add('correct-pop');
                // 將章節文字改為綠色
                const chapterInner = chapterCard.querySelector('div');
                if (chapterInner) {
                    chapterInner.classList.remove('text-red-800', 'text-blue-800', 'text-purple-800');
                    chapterInner.classList.add('text-green-800');
                }
                
                // 移除經文卡片的選中狀態和點擊事件
                const verseCard = document.querySelector(`[data-index="${gameState.selectedVerseIndex}"]`);
                    if (verseCard) {
                    // mark verse correct and clear any lingering error/shake/red classes via helper
                    clearErrorState(verseCard);
                    verseCard.classList.remove('bg-blue-50', 'border-blue-200', 'bg-yellow-100', 'border-yellow-300', 'bg-orange-100', 'border-orange-300', 'selected-verse');
                    verseCard.classList.add('bg-green-100', 'border-green-300');
                    verseCard.style.pointerEvents = 'none';
                    verseCard.classList.remove('correct-pop');
                    void verseCard.offsetWidth;
                    verseCard.classList.add('correct-pop');
                    // 經文文字變綠表示答對
                    const innerText = verseCard.querySelector('div');
                    if (innerText) {
                        innerText.classList.remove('text-red-800', 'text-blue-800', 'text-purple-800');
                        innerText.classList.add('text-green-800');
                    }

                    // 簡單/普通難度：在該題前段/整段經文卡片下方顯示「書卷 章節」（例如：馬太福音 5:9）
                    if (gameState.difficulty === 'easy' || gameState.difficulty === 'normal') {
                        try {
                            const already = verseCard.querySelector('.verse-ref-label');
                            if (!already) {
                                const ref = document.createElement('div');
                                ref.className = 'verse-ref-label text-xs text-gray-700 font-semibold text-center';
                                ref.textContent = `${selectedQuestion.book || ''} ${selectedQuestion.chapter || ''}`.trim();
                                // 淡入效果
                                ref.style.opacity = '0';
                                ref.style.transition = 'opacity 260ms ease';
                                verseCard.appendChild(ref);
                                requestAnimationFrame(() => { ref.style.opacity = '1'; });
                                // 顯示 5 秒後淡出並移除
                                try { if (ref.__hideTimer) clearTimeout(ref.__hideTimer); } catch (e) {}
                                ref.__hideTimer = setTimeout(() => {
                                    try {
                                        ref.style.opacity = '0';
                                        const onEnd = () => {
                                            ref.removeEventListener('transitionend', onEnd);
                                            try { if (ref.parentElement) ref.parentElement.removeChild(ref); } catch (e2) {}
                                        };
                                        ref.addEventListener('transitionend', onEnd);
                                    } catch (e3) {}
                                }, 3000);
                            } else {
                                // 已存在：重置淡出計時並確保可見
                                already.style.transition = already.style.transition || 'opacity 260ms ease';
                                already.style.opacity = '1';
                                try { if (already.__hideTimer) clearTimeout(already.__hideTimer); } catch (e) {}
                                already.__hideTimer = setTimeout(() => {
                                    try {
                                        already.style.opacity = '0';
                                        const onEnd = () => {
                                            already.removeEventListener('transitionend', onEnd);
                                            try { if (already.parentElement) already.parentElement.removeChild(already); } catch (e2) {}
                                        };
                                        already.addEventListener('transitionend', onEnd);
                                    } catch (e3) {}
                                }, 3000);
                            }
                        } catch (e) { /* ignore label errors */ }
                    }
                }
                
                // 重置選中狀態
                gameState.selectedVerseIndex = null;
                
                // 更新題目進度顯示
                updateQuestionOvals();
                
                // 檢查是否完成所有題目
                setTimeout(() => checkLevelComplete(), 500);
                
                // 答題結束後，在手機上將焦點回到前段經文面板
                scrollToFrontPanel();

                if (scoreGained > 0) {
                    showScoreAnimation(`+${scoreGained}分`, false, verseCard);
                    // Emit subtle green-only particles to celebrate correct selection; count halved
                    try {
                        const rect = chapterCard.getBoundingClientRect();
                        const greens = ['#22C55E','#16A34A','#4ADE80','#86EFAC','#BBF7D0'];
                        spawnScoreParticles(null, rect, { colors: greens, glyph: '✹', count: 6, distanceMin: 50, distanceMax: 140, durationMs: 1800 });
                    } catch(_) { /* ignore */ }
                }
                
            } else {
                // 答錯了
                gameState.questionAttempts[gameState.selectedVerseIndex]--;
                gameState.levelPerfect = false;
                gameState.consecutiveMistakes++;
                gameState.totalMistakes++; // 增加失誤計數
                
                // 淡出遊戲提示
                const existingInstructions = document.querySelectorAll('.game-instruction');
                existingInstructions.forEach(inst => {
                    inst.style.animation = 'instructionFadeOut 1s ease-out forwards';
                    setTimeout(() => {
                        if (inst.parentElement) {
                            inst.parentElement.removeChild(inst);
                        }
                    }, 1000);
                });
                // 同步隱藏可愛吐司提示
                try { hideCuteHint(); } catch (_) {}
                
                // 顯示失誤扣分動畫
                const verseCard = document.querySelector(`[data-index="${gameState.selectedVerseIndex}"]`);
                if (verseCard) {
                    showScoreAnimation('-50', false, verseCard);
                }
                
                // 取消舊規則：不再使用「連續 3 次失誤」作為提示提醒觸發條件
                
                // 添加震動效果到選錯的章節卡片（作用於內層以避免與位移動畫衝突）
                (function(){
                    const inner = chapterCard.querySelector('div') || chapterCard;
                    inner.classList.remove('shake-error');
                    void inner.offsetWidth; // reflow
                    inner.classList.add('shake-error');
                    setTimeout(() => { inner.classList.remove('shake-error'); }, 600);
                })();
                
                if (gameState.questionAttempts[gameState.selectedVerseIndex] <= 0) {
                    // 沒有機會了，標記經文為錯誤
                    const verseCard = document.querySelector(`[data-index="${gameState.selectedVerseIndex}"]`);
                    if (verseCard) {
                        verseCard.classList.add('bg-red-100', 'border-red-300');
                        const vInner = verseCard.querySelector('div') || verseCard;
                        vInner.classList.remove('shake-error');
                        void vInner.offsetWidth; // reflow
                        vInner.classList.add('shake-error');
                        verseCard.classList.remove('bg-blue-50', 'border-blue-200', 'bg-yellow-100', 'border-yellow-300', 'bg-orange-100', 'border-orange-300', 'selected-verse');
                        verseCard.style.pointerEvents = 'none';
                        
                        // 將經文內容文字也改為紅色，表示此題已鎖定無法得分
                        const innerText = verseCard.querySelector('div');
                        if (innerText) {
                            innerText.classList.remove('text-blue-800', 'text-purple-800', 'text-green-800');
                            innerText.classList.add('text-red-800');
                        }

                        // 移除震動效果
                        setTimeout(() => { vInner.classList.remove('shake-error'); }, 600);
                    }
                    
                    // 找到正確答案並標記為紅色（只標記正確答案，不標記選錯的章節）
                    let correctChapter = null;
                    const allChapters = document.querySelectorAll('.chapter-card');
                    
                    for (let chapter of allChapters) {
                        // easy: 使用 pairId 比對
                        if (gameState.difficulty === 'easy' && selectedQuestion.pairId) {
                            if (chapter.dataset.pairId && chapter.dataset.pairId === selectedQuestion.pairId) {
                                correctChapter = chapter;
                                break;
                            }
                        } else if (gameState.difficulty === 'normal') {
                            if (chapter.dataset.book === selectedQuestion.book) {
                                correctChapter = chapter;
                                break;
                            }
                        } else {
                            if (chapter.dataset.book === selectedQuestion.book && chapter.dataset.chapter === selectedQuestion.chapter) {
                                correctChapter = chapter;
                                break;
                            }
                        }
                    }
                    
                    // 只將正確答案標記為紅色，不標記選錯的章節
                    if (correctChapter) {
                        correctChapter.classList.add('bg-red-100', 'border-red-300');
                        const cInner = correctChapter.querySelector('div') || correctChapter;
                        cInner.classList.remove('shake-error');
                        void cInner.offsetWidth; // reflow
                        cInner.classList.add('shake-error');
                        correctChapter.classList.remove('bg-gradient-to-br', 'from-purple-50', 'to-purple-100', 'border-purple-300');
                        correctChapter.style.pointerEvents = 'none';
                        // 答案文字也改為紅色以示提示
                        const correctInner = correctChapter.querySelector('div');
                        if (correctInner) {
                            correctInner.classList.remove('text-blue-800', 'text-purple-800', 'text-green-800');
                            correctInner.classList.add('text-red-800');
                        }
                        
                        // 移除震動效果
                        setTimeout(() => { cInner.classList.remove('shake-error'); }, 600);
                    }
                    
                    // 取消舊規則：不再於「該題無法再得分」時彈出提示提醒（避免在困難模式首次失誤即觸發）

                    // 新規則：統計本關「完全答錯」題數；同一關中任兩題完全答錯時，若本局尚未提醒且仍有提示次數，顯示一次提醒
                    // Hint rule: count per-level fully-wrong questions; on the 2nd fully wrong,
                    // show a one-time hint reminder for this run if hints remain.
                    try {
                        gameState.levelFailedCount = (gameState.levelFailedCount || 0) + 1;
                        if (gameState.levelFailedCount >= 2 && !gameState.firstNoScoreMissToastShown && gameState.hintsRemaining > 0) {
                            showCuteHint('卡關了嗎？可以試試提示功能喔～', 'amber', 3200, '💡');
                            gameState.firstNoScoreMissToastShown = true;
                        }
                    } catch (_) {}

            // 新規則：當本關「剩 2 題」時，若其中一題被判定為錯（本段即處理該題），
            // 另一題將直接判定為答錯，並進入下一關（無額外扣分動畫）
            // New rule: when a level has 2 questions remaining and one just became wrong,
            // auto-mark the other remaining question as wrong and proceed (no extra penalty animation)
                    try {
                        const total = Array.isArray(gameState.questionData) ? gameState.questionData.length : 0;
                        if (total > 0) {
                            const remaining = [];
                            for (let i = 0; i < total; i++) {
                                const vc = document.querySelector(`[data-index="${i}"]`);
                                if (!vc) continue;
                                const isDoneWrong = vc.classList.contains('bg-red-100');
                                const isDoneRight = vc.classList.contains('bg-green-100');
                                if (!isDoneWrong && !isDoneRight) remaining.push(i);
                            }
                // 若在本題被判錯後只剩 1 題未完成，表示原先剩 2 題，依規則將最後一題直接判錯
                if (remaining.length === 1) {
                                const remIdx = remaining[0];
                                const q = gameState.questionData[remIdx];
                                // 將剩餘題目直接標記為錯誤（不顯示扣分動畫，不更動分數）
                                gameState.questionAttempts[remIdx] = 0;
                                const remVerseCard = document.querySelector(`[data-index="${remIdx}"]`);
                                if (remVerseCard) {
                                    clearErrorState(remVerseCard);
                                    remVerseCard.classList.remove('bg-blue-50','border-blue-200','bg-yellow-100','border-yellow-300','bg-orange-100','border-orange-300','selected-verse');
                                    remVerseCard.classList.add('bg-red-100','border-red-300');
                                    remVerseCard.style.pointerEvents = 'none';
                                    const inner = remVerseCard.querySelector('div');
                                    if (inner) {
                                        inner.classList.remove('text-blue-800','text-yellow-800','text-orange-800','text-green-800');
                                        inner.classList.add('text-red-800');
                                    }
                                }
                                // 同步標示正確答案章節（紅色）
                                try {
                                    let correctChapter = null;
                                    const allChapters = document.querySelectorAll('.chapter-card');
                                    for (let chapter of allChapters) {
                                        if (gameState.difficulty === 'easy' && q.pairId) {
                                            if (chapter.dataset.pairId && chapter.dataset.pairId === q.pairId) { correctChapter = chapter; break; }
                                        } else if (gameState.difficulty === 'normal') {
                                            if (chapter.dataset.book === q.book) { correctChapter = chapter; break; }
                                        } else {
                                            if (chapter.dataset.book === q.book && chapter.dataset.chapter === q.chapter) { correctChapter = chapter; break; }
                                        }
                                    }
                                    if (correctChapter) {
                                        correctChapter.classList.add('bg-red-100','border-red-300');
                                        correctChapter.classList.remove('bg-gradient-to-br','from-purple-50','to-purple-100','border-purple-300');
                                        correctChapter.style.pointerEvents = 'none';
                                        const ci = correctChapter.querySelector('div');
                                        if (ci) {
                                            ci.classList.remove('text-blue-800','text-purple-800','text-green-800');
                                            ci.classList.add('text-red-800');
                                        }
                                    }
                                } catch(_) {}

                                // 清理狀態並刷新進度（後續會有統一的完成檢查排程）
                                gameState.selectedVerseIndex = null;
                                updateQuestionOvals();
                                // 視圖回到前段面板
                                scrollToFrontPanel();
                            }
                        }
                    } catch(_) {}

                    // 移除選中狀態
                    gameState.selectedVerseIndex = null;
                    
                    // 更新題目進度顯示
                    updateQuestionOvals();
                    
                    // 檢查是否所有題目都完成
                    setTimeout(() => checkLevelComplete(), 500);

                    // 若該題次數用盡，將視圖回到前段面板，方便使用者查看下一題
                    scrollToFrontPanel();
                } else {
                    // 還有機會，更新經文卡片顏色並保持選中狀態
                    updateVerseCardColor(gameState.selectedVerseIndex);
                }
            }
        }

    // 依答題狀態改變經文卡顏色（對/錯/未答）
    // Update verse card color based on answer state
    function updateVerseCardColor(index) {
            const verseCard = document.querySelector(`[data-index="${index}"]`);
            if (!verseCard) return;
            
            const attempts = gameState.questionAttempts[index];
            const maxAttempts = { easy: 3, normal: 3, hard: 3 };
            const originalAttempts = maxAttempts[gameState.difficulty];
            
            // 移除所有顏色類別
            verseCard.classList.remove('bg-blue-50', 'border-blue-200', 'bg-yellow-100', 'border-yellow-300', 'bg-orange-100', 'border-orange-300', 'bg-red-100', 'border-red-300');
            
            // 若該經文還未作答（嘗試次數等於原始次數），一律顯示藍色
            if (attempts === originalAttempts) {
                verseCard.classList.add('bg-blue-50', 'border-blue-200');
                // 文字回復藍色
                const inner = verseCard.querySelector('div');
                if (inner) {
                    inner.classList.remove('text-red-800', 'text-purple-800', 'text-green-800');
                    inner.classList.add('text-blue-800');
                }
            } else {
                // 已經作答過但還有機會，根據剩餘次數顯示不同顏色
                if (attempts === 2) {
                    verseCard.classList.add('bg-yellow-100', 'border-yellow-300');
                    const inner = verseCard.querySelector('div');
                    if (inner) {
                        inner.classList.remove('text-red-800', 'text-blue-800', 'text-green-800');
                        inner.classList.add('text-yellow-800');
                    }
                } else if (attempts === 1) {
                    verseCard.classList.add('bg-orange-100', 'border-orange-300');
                    const inner = verseCard.querySelector('div');
                    if (inner) {
                        inner.classList.remove('text-red-800', 'text-blue-800', 'text-green-800');
                        inner.classList.add('text-orange-800');
                    }
                } else if (attempts === 0) {
                    verseCard.classList.add('bg-red-100', 'border-red-300');
                    const inner = verseCard.querySelector('div');
                    if (inner) {
                        inner.classList.remove('text-blue-800', 'text-yellow-800', 'text-orange-800', 'text-green-800');
                        inner.classList.add('text-red-800');
                    }
                }
            }
            
            // 更新題目進度顯示
            updateQuestionOvals();
        }

    // 檢查本關是否完成，結算 perfect/complete/partial/failed 狀態
    // Check if level is finished and set result state
    function checkLevelComplete() {
            // 確保有題目數據
            if (!gameState.questionData || gameState.questionData.length === 0) {
                console.log('沒有題目數據，無法檢查關卡完成狀態');
                return;
            }
            // 若本關結束流程已處理過，直接跳出避免重入
            // If end-of-level has been handled already, return early to prevent re-entry
            if (gameState.levelEndHandled) {
                return;
            }
            
            const completedQuestions = gameState.questionData.filter((_, index) => {
                const verseCard = document.querySelector(`[data-index="${index}"]`);
                return verseCard && (verseCard.classList.contains('bg-green-100') || verseCard.classList.contains('bg-red-100'));
            }).length;
            
            console.log(`已完成題目: ${completedQuestions}/${gameState.questionData.length}`);
            
            if (completedQuestions === gameState.questionData.length) {
                // 標記：本關結束流程已處理，避免重複觸發
                // Mark: handled to avoid duplicate transitions/scoring
                gameState.levelEndHandled = true;
                // 停止計時器
                if (gameState.timerInterval) {
                    clearInterval(gameState.timerInterval);
                    gameState.timerInterval = null;
                }
                
                // 檢查獎勵
                const correctQuestions = gameState.questionData.filter((_, index) => {
                    const verseCard = document.querySelector(`[data-index="${index}"]`);
                    return verseCard && verseCard.classList.contains('bg-green-100');
                }).length;
                
                const allCorrect = correctQuestions === gameState.questionData.length;
                console.log(`答對題目: ${correctQuestions}/${gameState.questionData.length}, 全對: ${allCorrect}`);
                
                // 記錄關卡結果
                // 檢查是否有使用過提示的題目（僅考慮本關的提示記錄）
                const levelUsedHints = Array.from(gameState.usedHints).some(h => {
                    const s = String(h);
                    // new format: "<level>|<questionIndex>"
                    if (s.indexOf('|') !== -1) return s.startsWith(`${gameState.currentLevel}|`);
                    // fallback: numeric entries (legacy) - treat as belonging to this level only if they look like an index
                    const n = Number(s);
                    return !isNaN(n) && n < gameState.questionData.length;
                });
                
                if (gameState.levelPerfect && !levelUsedHints && allCorrect) {
                    // 完美關卡（全對且無提示且無失誤）
                    gameState.levelResults[gameState.currentLevel] = 'perfect';
                    gameState.score += 300;
                    showScoreAnimation('完美+300分', true);
                    // 桌面：啟動持續星星雨
                    try { startStarRain(); } catch(_) {}
                    // 震撼特效（金色）
                    try { triggerLevelEffect('perfect'); } catch(_) {}
                    console.log('完美關卡！');
                } else if (allCorrect) {
                    // 全對關卡（全對但可能用了提示或有失誤）
                    gameState.levelResults[gameState.currentLevel] = 'complete';
                    gameState.score += 100;
                    showScoreAnimation('全對+100分', true);
                    // 非完美：停止星星雨
                    try { stopStarRain(false); } catch(_) {}
                    // 震撼特效（綠色）
                    try { triggerLevelEffect('complete'); } catch(_) {}
                    console.log('全對關卡！');
                } else {
                    // 部分正確或全錯
                    if (correctQuestions === 0) {
                        // 題目全錯：標記為失敗（紅色）
                        gameState.levelResults[gameState.currentLevel] = 'failed';
                        // 震撼特效（紅色）
                        try { triggerLevelEffect('failed'); } catch(_) {}
                        console.log('全錯關卡');
                    } else {
                        gameState.levelResults[gameState.currentLevel] = 'partial';
                        console.log('部分正確關卡');
                    }
                    // 非完美：停止星星雨
                    try { stopStarRain(false); } catch(_) {}
                }
                
                // 立即更新關卡進度顯示
                updateLevelOvals();
                // 小螢幕：將視角移到最上方的分數卡，讓玩家看見得分與動畫
                try { scrollScoreIntoView(); } catch (e) { /* ignore */ }
                
                // 進/出場動畫：先讓紅色錯題卡片進行零散掉落；
                // 之後再讓其他卡片（綠色或未作答）不規則向左滑出。
                try {
                    const verses = Array.from(document.querySelectorAll('#gameVerses .verse-card'));
                    const chapters = Array.from(document.querySelectorAll('#gameChapters .chapter-card'));
                    const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                    let slideWait = 0; // 綠卡/未作答滑出總時長
                    let fallWait = 0;  // 紅卡掉落總時長（不影響切關時間）
                    // Wrong cards: fall scattered first
                    const wrongGroup = [
                        ...verses.filter(el => el.classList.contains('bg-red-100')),
                        ...chapters.filter(el => el.classList.contains('bg-red-100'))
                    ];
                    const wrongStartOffset = 0; // 紅卡優先立即掉落
                    wrongGroup.forEach((el, i) => {
                        const jitter = (min, max) => Math.random() * (max - min) + min;
                        const fx = Math.round(jitter(-40, 80));
                        const fy = Math.round(jitter(180, 320));
                        const fr = `${jitter(-24, 36).toFixed(2)}deg`;
                        const fd = Math.round(jitter(700, 1000));
                        // 更明顯的掉落時間差：加大每張卡的基礎間距與隨機抖動
                        const fdly = Math.round(wrongStartOffset + i * 90 + jitter(0, 260));
                        el.style.setProperty('--fallDelay', `${fdly}ms`);
                        el.style.setProperty('--fx', `${fx}px`);
                        el.style.setProperty('--fy', `${fy}px`);
                        el.style.setProperty('--fr', fr);
                        el.style.setProperty('--fallDur', `${fd}ms`);
                        // 移除可能存在的進/出場 class 以避免衝突
                        el.classList.remove('card-enter', 'card-exit');
                        el.classList.add('card-fall-scatter');
                        fallWait = Math.max(fallWait, fdly + fd);
                    });

                    // Correct or untouched cards: slide out left with stagger (1s duration)
                    const slideGroup = [];
                    verses.forEach((el) => {
                        const isWrong = el.classList.contains('bg-red-100');
                        if (!isWrong) slideGroup.push(el);
                    });
                    chapters.forEach((el) => {
                        const isWrong = el.classList.contains('bg-red-100');
                        if (!isWrong) slideGroup.push(el);
                    });
                    const slideStartOffset = prefersReduce ? 200 : 240; // 讓紅卡先明顯開始
                    slideGroup.forEach((el, i) => {
                        const jitter = (min, max) => Math.random() * (max - min) + min;
                        const delay = Math.round(slideStartOffset + i * 40 + jitter(0, 160));
                        const ex = Math.round(jitter(0, 80));
                        const ey = Math.round(jitter(-12, 12));
                        // 綠色與未作答卡片不傾斜：退出時不旋轉
                        const er = '0deg';
                        const dur = 1000; // 指定 1 秒
                        el.style.setProperty('--exitDelay', `${delay}ms`);
                        el.style.setProperty('--exitX', `${ex}px`);
                        el.style.setProperty('--exitY', `${ey}px`);
                        el.style.setProperty('--exitR', er);
                        el.style.setProperty('--exitDur', `${dur}ms`);
                        // 移除進場效果避免干擾
                        el.classList.remove('card-enter', 'card-fall-scatter', 'correct-pop');
                        el.classList.add('card-exit');
                        slideWait = Math.max(slideWait, delay + dur);
                    });

                    // 全紅情境：若無任何可滑出的卡片（全部為紅色），則等待紅卡掉落全程再切關；
                    // 其他情境：只等待綠卡/未作答滑出完成，保留極短緩衝即可銜接下一關
                    let pause = 0;
                    if (prefersReduce) {
                        pause = 0;
                    } else if (slideGroup.length === 0) {
                        // 等待紅卡掉落完成，並加上小緩衝
                        pause = Math.max(0, fallWait + 30);
                    } else {
                        pause = Math.max(0, slideWait + 5);
                    }
                    gameState.__levelAnimDelay = pause;
                    // 切關等待期間鎖定互動
                    setLevelInteractionLock(true);
                } catch (_) { gameState.__levelAnimDelay = 800; }

                // 使用更短的延遲並確保執行（加入動畫暫停時間）
                // 加入 watchdog，避免偶發例外或動畫干擾導致無法切關
                try { if (gameState.__handoffGuard) { clearTimeout(gameState.__handoffGuard); } } catch(_) {}
                const handoffLevel = gameState.currentLevel;
                gameState.__handoffDone = false;
                const runHandoff = () => {
                    // 避免重複執行
                    if (gameState.__handoffDone) return;
                    console.log(`當前關卡: ${gameState.currentLevel}`);
                    const safeCall = (fn) => {
                        try { fn(); } catch (e) { console.error('關卡切換發生例外，嘗試保護性解鎖', e); }
                        finally {
                            gameState.__handoffDone = true;
                            // 保護性解鎖（nextLevel/completeGame 正常會自行解鎖）
                            try { setLevelInteractionLock(false); } catch(_) {}
                        }
                    };
                    if (gameState.currentLevel >= 5) {
                        console.log('遊戲完成！');
                        try { showLevelEncouragementCute(); } catch (e) {}
                        setTimeout(() => { console.log('執行完成遊戲'); safeCall(() => completeGame()); }, 30);
                    } else {
                        console.log('進入下一關');
                        try { showLevelEncouragementCute(); } catch (e) {}
                        setTimeout(() => { console.log('執行下一關'); safeCall(() => nextLevel()); }, 30);
                    }
                };

                setTimeout(runHandoff, (gameState.__levelAnimDelay || 0));
                // Watchdog：若主流程在合理時間內未完成，強制執行（pause + 2500ms）
                const guardDelay = (gameState.__levelAnimDelay || 0) + 2500;
                gameState.__handoffGuard = setTimeout(() => {
                    if (!gameState.__handoffDone && handoffLevel === gameState.currentLevel) {
                        console.warn('[Watchdog] 關卡切換逾時，啟動保護性切換');
                        runHandoff();
                    }
                }, guardDelay);
            }
        }

        // 小螢幕：平滑捲到頁面頂端，確保上方關卡進度也可見
    // 小畫面時把分數區域捲入視口
    // Scroll score area into view on small screens
    function scrollScoreIntoView() {
            // 僅在小螢幕上進行自動捲動（避免桌面用戶被干擾）
            if (window.innerWidth > 640) return;
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

    // 關卡切換等待期間鎖定互動，避免動畫中點擊/焦點/捲動異常
    // Lock interactions on main containers during level handoff wait
    function setLevelInteractionLock(lock) {
            try {
                const ids = ['gameVerses', 'gameChapters', 'versesCarousel'];
                ids.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.pointerEvents = lock ? 'none' : '';
                });
                // 同步處理提示按鈕，避免期間被觸發
                const hintBtn = document.getElementById('hintBtn');
                if (hintBtn) {
                    if (lock) {
                        if (!hintBtn.dataset.locked) hintBtn.dataset.locked = '1';
                        hintBtn.disabled = true;
                        hintBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    } else {
                        if (hintBtn.dataset.locked === '1') {
                            delete hintBtn.dataset.locked;
                            if (gameState.hintsRemaining > 0) {
                                hintBtn.disabled = false;
                                hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                            }
                        }
                    }
                }
            } catch(_) { /* non-fatal */ }
        }

    // ===== 全畫面關卡特效（完美/全對/全錯） =====
    // 插入一次性樣式
    function ensureLevelFxStyles() {
            if (document.getElementById('levelFxStyles')) return;
            const style = document.createElement('style');
            style.id = 'levelFxStyles';
            style.textContent = `
            .level-fx-overlay { position: fixed; inset: 0; pointer-events: none; z-index: 10020; overflow: hidden; }
            .level-fx-flash { position:absolute; inset:0; opacity:0; }
            .level-fx-radial { position:absolute; inset:-10%; opacity:0.18; filter: blur(2px); }
            .level-fx-particle { position:absolute; left:50%; top:50%; width:10px; height:10px; opacity:0; border-radius: 2px; will-change: transform, opacity; }
            .level-fx-star { width:12px; height:12px; background: currentColor; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }
            .level-fx-circle { border-radius: 9999px; }
            .level-fx-square { }
            .level-fx-overlay.level-fx-shake { animation: megaShake 900ms cubic-bezier(.36,.07,.19,.97) both; }
            @keyframes levelFlash { 0%{opacity:0} 10%{opacity:.95} 100%{opacity:0} }
            @keyframes particleExplode { 0% { opacity:1; transform: translate(-50%,-50%) scale(0.4) rotate(0deg); } 100% { opacity:0; transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1) rotate(var(--rot)); } }
            @keyframes megaShake {
                0% { transform: translate(0, 0) }
                10% { transform: translate(-14px, -10px) }
                20% { transform: translate(16px, 12px) }
                30% { transform: translate(-12px, 10px) }
                40% { transform: translate(12px, -14px) }
                50% { transform: translate(-8px, 8px) }
                60% { transform: translate(10px, -6px) }
                70% { transform: translate(-6px, 10px) }
                80% { transform: translate(6px, -8px) }
                90% { transform: translate(-4px, 6px) }
                100% { transform: translate(0, 0) }
            }
            `;
            document.head.appendChild(style);
        }

    // 觸發關卡特效：type = 'perfect' | 'complete' | 'failed'
    function triggerLevelEffect(type) {
            try {
                const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                ensureLevelFxStyles();
                const overlay = document.createElement('div');
                overlay.className = 'level-fx-overlay';
                // 色盤
                let colors = [];
                let flashBg = '';
                // 調整動畫時長：全對（complete）略短且較柔和
                const flashDur = reduce ? 300 : (type === 'complete' ? 700 : 900);
                const particleDur = reduce ? 500 : (type === 'complete' ? 900 : 1200);
                if (type === 'perfect') {
                    colors = ['#FBBF24','#F59E0B','#FFD54F','#FFF3B0','#FFFFFF'];
                    flashBg = 'radial-gradient(ellipse at center, rgba(255,223,128,0.92), rgba(255,190,60,0.66) 40%, rgba(255,184,28,0.0) 70%)';
                } else if (type === 'complete') {
                    // 使用較柔和的綠色，降低閃光透明度
                    colors = ['#86EFAC','#A7F3D0','#6EE7B7','#34D399','#BBF7D0'];
                    flashBg = 'radial-gradient(ellipse at center, rgba(52,211,153,0.55), rgba(16,185,129,0.30) 40%, rgba(16,185,129,0.0) 70%)';
                } else { // failed
                    colors = ['#EF4444','#DC2626','#F87171','#FB7185','#991B1B'];
                    flashBg = 'radial-gradient(ellipse at center, rgba(239,68,68,0.85), rgba(220,38,38,0.55) 40%, rgba(220,38,38,0.0) 70%)';
                    overlay.classList.add('level-fx-shake');
                }

                // 閃光層
                const flash = document.createElement('div');
                flash.className = 'level-fx-flash';
                flash.style.background = flashBg;
                flash.style.animation = `levelFlash ${flashDur}ms ease-out forwards`;
                overlay.appendChild(flash);

                // 放射淡層
                const radial = document.createElement('div');
                radial.className = 'level-fx-radial';
        radial.style.background = type === 'perfect'
                    ? 'radial-gradient(circle at center, rgba(255,255,255,0.35) 0%, rgba(255,255,255,0.05) 35%, rgba(255,255,255,0) 70%)'
                    : type === 'complete'
            ? 'radial-gradient(circle at center, rgba(34,197,94,0.15) 0%, rgba(34,197,94,0.04) 35%, rgba(34,197,94,0) 70%)'
                        : 'radial-gradient(circle at center, rgba(239,68,68,0.25) 0%, rgba(239,68,68,0.06) 35%, rgba(239,68,68,0) 70%)';
                overlay.appendChild(radial);

                // 粒子爆裂
        const count = reduce ? 20 : (type === 'perfect' ? 90 : type === 'complete' ? 40 : 64);
                const shapes = ['level-fx-star','level-fx-circle','level-fx-square'];
                for (let i = 0; i < count; i++) {
                    const p = document.createElement('div');
                    p.className = `level-fx-particle ${shapes[i % shapes.length]}`;
                    p.style.color = colors[Math.floor(Math.random()*colors.length)];
                    const ang = Math.random() * Math.PI * 2;
                    const dist = (type === 'failed' ? 320 : 380) * (0.45 + Math.random()*0.75);
                    const dx = Math.cos(ang) * dist;
                    const dy = Math.sin(ang) * dist;
                    const rot = `${Math.round((Math.random()*720-360))}deg`;
                    p.style.setProperty('--dx', `${dx}px`);
                    p.style.setProperty('--dy', `${dy}px`);
                    p.style.setProperty('--rot', rot);
                    const size = (type === 'perfect' ? 8 : 7) + Math.round(Math.random()*10);
                    p.style.width = `${size}px`;
                    p.style.height = `${size}px`;
                    p.style.animation = `particleExplode ${particleDur}ms cubic-bezier(.17,.67,.37,1) ${Math.round(Math.random()*120)}ms forwards`;
                    overlay.appendChild(p);
                }

                document.body.appendChild(overlay);
                // 清理
                setTimeout(() => { try { if (overlay.parentElement) overlay.parentElement.removeChild(overlay); } catch(_) {} }, reduce ? 600 : (type === 'complete' ? 1100 : 1300));
            } catch(_) { /* non-fatal */ }
        }

    // 使用提示一次（每關最多提醒一次未使用提示）
    // Use a hint and maybe show per-level reminder
    function useHint() {
            if (gameState.hintsRemaining <= 0) return;
            const hintBtn = document.getElementById('hintBtn');
            if (hintBtn.disabled) return;

            // 禁用提示按鈕，避免連續誤點
            hintBtn.disabled = true;
            hintBtn.classList.add('opacity-50', 'cursor-not-allowed');

            // 找到所有未完成且未答錯的題目
            const availableQuestions = [];
            gameState.questionData.forEach((question, index) => {
                const verseCard = document.querySelector(`[data-index="${index}"]`);
                if (verseCard &&
                    !verseCard.classList.contains('bg-green-100') &&
                    !verseCard.classList.contains('bg-red-100') &&
                    gameState.questionAttempts[index] > 0) {
                    availableQuestions.push(index);
                }
            });
            if (availableQuestions.length === 0) {
                // 沒有可提示題目，立即恢復按鈕
                setTimeout(() => {
                    if (gameState.hintsRemaining > 0) {
                        hintBtn.disabled = false;
                        hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }, 500);
                return;
            }

            // 扣除提示次數
            gameState.hintsRemaining--;
            updateGameUI();

            // Prefer the currently selected question if the player has one selected and it's still answerable;
            // otherwise pick a random available question.
            let selectedQuestionIndex = null;
            if (gameState.selectedVerseIndex != null) {
                const sel = gameState.selectedVerseIndex;
                const selCard = document.querySelector(`[data-index="${sel}"]`);
                const selAttempts = typeof gameState.questionAttempts[sel] === 'number' ? gameState.questionAttempts[sel] : 0;
                const selNotAnswered = selCard && !selCard.classList.contains('bg-green-100') && !selCard.classList.contains('bg-red-100') && selAttempts > 0;
                if (selNotAnswered) selectedQuestionIndex = sel;
            }

            if (selectedQuestionIndex == null) {
                const randomIndex = Math.floor(Math.random() * availableQuestions.length);
                selectedQuestionIndex = availableQuestions[randomIndex];
            }
            const selectedQuestion = gameState.questionData[selectedQuestionIndex];
            try {
                const levelKey = `${gameState.currentLevel}|${selectedQuestionIndex}`;
                gameState.usedHints.add(levelKey);
            } catch (e) {
                // fallback for environments where usedHints may not be a Set
                try { gameState.usedHints.add(selectedQuestionIndex); } catch (ee) { /* ignore */ }
            }

            // 清除所有現有的提示效果
            document.querySelectorAll('.hint-flash').forEach(element => {
                element.classList.remove('hint-flash');
            });

            // 找到正確的章節卡片（easy 使用 pairId）
            const verseCard = document.querySelector(`[data-index="${selectedQuestionIndex}"]`);
            let correctChapter = null;
            if (gameState.difficulty === 'easy' && selectedQuestion.pairId) {
                correctChapter = document.querySelector(`[data-pair-id="${selectedQuestion.pairId}"]`);
            } else {
                correctChapter = document.querySelector(`[data-book="${selectedQuestion.book}"][data-chapter="${selectedQuestion.chapter}"]`);
            }
            if (correctChapter && verseCard) {
                correctChapter.classList.add('hint-flash');
                verseCard.classList.add('hint-flash');
                // 4秒後移除效果並恢復按鈕
                setTimeout(() => {
                    correctChapter.classList.remove('hint-flash');
                    verseCard.classList.remove('hint-flash');
                    if (gameState.hintsRemaining > 0) {
                        hintBtn.disabled = false;
                        hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }, 4000);
            } else {
                // 若找不到卡片，1秒後恢復按鈕
                setTimeout(() => {
                    if (gameState.hintsRemaining > 0) {
                        hintBtn.disabled = false;
                        hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }, 1000);
            }
        }
        


        // Parse numeric delta from a display text like "+20", "全對+100", "完美+300", or "-10".
    // 從文字（如 +20 / 全對+100 / -10）中解析數值變化量
    // Parse numeric delta from a display string
    function parseDeltaFromDisplayText(displayText) {
            try {
                if (typeof displayText !== 'string') return 0;
                const m = displayText.match(/([+\-]?\d+)/);
                if (!m) return 0;
                return parseInt(m[1], 10) || 0;
            } catch (_) { return 0; }
        }

        // Queue-based center score updater: waits for floating inline count to finish, then animates gold number.
        const __centerQueue = (window.__centerQueue = window.__centerQueue || []);
        let __centerBusy = (window.__centerBusy = window.__centerBusy || false);
    // 處理中心分數的排程佇列，避免動畫重疊
    // Process queued center-score updates (serialize animations)
    function processCenterQueue() {
            if (__centerBusy) return;
            const item = __centerQueue.shift();
            if (!item) return;
            __centerBusy = true;
            const scoreElement = document.getElementById('centerScore');
            const from = parseInt(scoreElement.textContent, 10) || 0;
            const to = from + item.delta;
            try {
                // Optional pulse/particles aligned with center counting start
                if (item.pulse) {
                    try { pulseCenterScore(item.delta); } catch(e) {}
                    try { spawnScoreParticles(item.delta); } catch(e) {}
                }
            } catch (_) {}
            // Run the counting animation; it internally cancels previous intervals if any
            animateScoreWithCounting(from, to);
            const doneMs = (typeof getReducedMotion === 'function' && getReducedMotion()) ? 60 : 900;
            setTimeout(() => {
                __centerBusy = false;
                processCenterQueue();
            }, doneMs + 40);
        }
    // 排入中心分數變更（可延遲、可帶脈衝特效）
    // Enqueue a center score update with optional delay/pulse
    function enqueueCenterScoreDelta(delta, delayMs = 720, options = { pulse: true }) {
            const d = Math.trunc(delta || 0);
            const delay = Math.max(0, delayMs|0);
            setTimeout(() => {
                __centerQueue.push({ delta: d, pulse: !!options.pulse });
                processCenterQueue();
            }, delay);
        }

    // 顯示得分/扣分動畫（行動版貼近中心分數，桌面版含完美/全對特效）
    // Show floating score animations; mobile favors center overlay
    function showScoreAnimation(text, isSpecial, targetElement = null) {
            const scoreElement = document.getElementById('centerScore');
            
            // 改為：等待浮動加分數字跳轉動畫完成（~720ms）後，再讓金色分數開始各別的數字跳轉動畫
            // 解析當次加分/扣分的增量，將其排入中心分數佇列，逐一處理，彼此獨立不需等全部完成。
            const displayText = text.replace('分', '');
            const deltaForCenter = parseDeltaFromDisplayText(displayText);
            const inlineDur = (typeof getReducedMotion === 'function' && getReducedMotion()) ? 40 : 720;
            // 對於特殊獎勵，我們仍排入佇列，但不重複觸發 pulse（特殊效果分支已各自處理脈衝/特效）
            const shouldPulse = !(text.includes('完美+300') || text.includes('全對+100'));
            // 不要計算紅色扣分（負值）到中心金色分數，避免重複扣分
            if (deltaForCenter > 0) {
                enqueueCenterScoreDelta(deltaForCenter, inlineDur, { pulse: shouldPulse });
            }
            
            // 移除「分」字
            // const displayText = text.replace('分', '');
            
            // 允許同時存在多個普通得分動畫（不再移除既有的 .score-popup）
            
            // 創建浮動分數動畫
            const floatingScore = document.createElement('div');
            floatingScore.textContent = displayText;
            // Force inline counting on mobile for special rewards even if reduced-motion is set
            try {
                const isMobile = (window.matchMedia && window.matchMedia('(max-width: 640px)').matches) || window.innerWidth <= 640;
                const isSpecialText = text.includes('完美+300') || text.includes('全對+100');
                if (isMobile && isSpecialText) floatingScore.dataset.forceInlineCount = 'true';
            } catch(_) {}
            try { applyInlineCountToFloating(floatingScore, displayText); } catch (e) {}
            floatingScore.style.pointerEvents = 'none';
            floatingScore.style.zIndex = '9999';
            floatingScore.style.position = 'absolute';
            
            // 根據分數類型設置不同效果和位置
            if (text.includes('完美+300')) {
                // 完美獎勵: on mobile animate to centerBadge and overlay like ordinary +score;
                // on desktop keep the full-screen central perfect popup
                const isMobile = (window.matchMedia && window.matchMedia('(max-width: 640px)').matches) || window.innerWidth <= 640;
                if (isMobile) {
                    // Mobile: Always show dead-center of the viewport
                    floatingScore.className = 'text-5xl font-extrabold text-yellow-400 score-popup';
                    floatingScore.style.textShadow = '0 2px 8px rgba(0,0,0,0.45)';
                    floatingScore.style.position = 'fixed';
                    floatingScore.style.left = '50%';
                    floatingScore.style.top = '50%';
                    floatingScore.style.transform = 'translate(-50%, -50%) scale(0.95)';
                    floatingScore.style.whiteSpace = 'nowrap';
                    floatingScore.style.opacity = '0';
                    floatingScore.style.zIndex = '10002';
                    // Disable CSS keyframe animation to avoid conflicts
                    try { floatingScore.style.animation = 'none'; floatingScore.style.webkitAnimation = 'none'; } catch(_) {}
                    try { floatingScore.classList.remove('perfect-popup','celebration-popup'); } catch(_) {}
                    document.body.appendChild(floatingScore);
                    try { pulseCenterScore(300); } catch(e) {}
                    try { spawnGoldGlitter(300); } catch(e) {}
                    requestAnimationFrame(() => {
                        floatingScore.style.transition = 'opacity 360ms ease, transform 520ms cubic-bezier(.2,.9,.2,1)';
                        floatingScore.style.opacity = '1';
                        floatingScore.style.transform = 'translate(-50%, -50%) scale(1)';
                    });
                } else {
                    // Desktop: original full-screen perfect popup
                    floatingScore.className = 'text-7xl font-black text-yellow-500 perfect-popup';
                    floatingScore.style.textShadow = '0 0 50px rgba(255, 215, 0, 1)';
                    floatingScore.style.position = 'fixed';
                    floatingScore.style.left = '50%';
                    floatingScore.style.top = '50%';
                    floatingScore.style.transform = 'translate(-50%, -50%)';
                    floatingScore.style.zIndex = '10000';
                    document.body.appendChild(floatingScore);
                    scoreElement.classList.add('score-flash');
                        createPerfectEffects(document.body);
                        try { pulseCenterScore(300); } catch(e) {}
                        try { spawnScoreParticles(300); } catch(e) {}
                }
            } else if (text.includes('全對+100')) {
                // 全對獎勵: same mobile overlay behavior as ordinary +score; desktop keeps large celebration
                const isMobile = (window.matchMedia && window.matchMedia('(max-width: 640px)').matches) || window.innerWidth <= 640;
                if (isMobile) {
                    // Mobile: Always show dead-center of the viewport
                    floatingScore.className = 'text-4xl font-extrabold text-green-400 score-popup';
                    floatingScore.style.textShadow = '0 2px 8px rgba(0,0,0,0.35)';
                    floatingScore.style.position = 'fixed';
                    floatingScore.style.left = '50%';
                    floatingScore.style.top = '50%';
                    floatingScore.style.transform = 'translate(-50%, -50%) scale(0.95)';
                    floatingScore.style.whiteSpace = 'nowrap';
                    floatingScore.style.opacity = '0';
                    floatingScore.style.zIndex = '10002';
                    try { floatingScore.style.animation = 'none'; floatingScore.style.webkitAnimation = 'none'; } catch(_) {}
                    document.body.appendChild(floatingScore);
                    try { pulseCenterScore(100); } catch(e) {}
                    // reduce mobile confetti rain intensity
                    try { spawnConfettiRain(40, null); } catch(e) {}
                    requestAnimationFrame(() => {
                        floatingScore.style.transition = 'opacity 360ms ease, transform 520ms cubic-bezier(.2,.9,.2,1)';
                        floatingScore.style.opacity = '1';
                        floatingScore.style.transform = 'translate(-50%, -50%) scale(1)';
                    });
                } else {
                    // Softer desktop celebration popup
                    floatingScore.className = 'text-5xl font-extrabold text-green-500 celebration-popup';
                    floatingScore.style.textShadow = '0 0 8px rgba(34, 197, 94, 0.35), 0 2px 3px rgba(0, 0, 0, 0.25)';
                    floatingScore.style.position = 'fixed';
                    floatingScore.style.left = '50%';
                    floatingScore.style.top = '50%';
                    floatingScore.style.transform = 'translate(-50%, -50%)';
                    floatingScore.style.zIndex = '10000';
                    // Shorter float duration for a less intense feel
                    try { floatingScore.style.animationDuration = '2.2s'; } catch(_) {}
                    document.body.appendChild(floatingScore);
                        createCelebrationEffects(document.body);
                        try { pulseCenterScore(100); } catch(e) {}
                        // reduce desktop confetti rain intensity
                        try { spawnConfettiRain(40); } catch(e) {}
                }
            } else {
                // 普通得分/扣分動畫 - 顯示在對應的經文卡片上方
                const isNegative = text.includes('-');
                // negative uses downward sink animation
                floatingScore.className = `text-4xl font-black ${isNegative ? 'text-red-500 score-popup score-down' : 'text-green-500 score-popup'}`;
                floatingScore.style.textShadow = isNegative ? 
                    '0 0 20px rgba(239, 68, 68, 0.6)' : 
                    '0 0 20px rgba(34, 197, 94, 0.6)';
                
                // On mobile prefer showing next to the center score (gold number) so the popup isn't clipped
                // inside the verse card (which causes it to be invisible on small screens).
                const isMobile = (window.matchMedia && window.matchMedia('(max-width: 640px)').matches) || window.innerWidth <= 640;
                const centerBadge = document.querySelector('.mobile-center-badge');
                if (isMobile) {
                    // Animate the floating score from the verse card (if provided) to the center score/gold number
                    try {
                        const pad = 8; // px padding from viewport edge

                        // Prefer the actual center score element if available (do not create badges or touch encouragementText)
                        let destRect = null;
                        let centerRect = null;
                        const centerEl = document.getElementById('centerScore');
                        if (centerEl) {
                            try { centerRect = centerEl.getBoundingClientRect(); } catch(e) { centerRect = null; }
                            if (centerRect && centerRect.width > 4) destRect = centerRect;
                        }
                        // fallback to mobile-center-badge if centerScore not measurable
                        if (!destRect && centerBadge) {
                            try { destRect = centerBadge.getBoundingClientRect(); } catch(e) { destRect = null; }
                        }
                        // final fallback to viewport center
                        if (!destRect) {
                            destRect = { left: Math.round(window.innerWidth / 2), top: Math.round(window.innerHeight / 2), width: 0, height: 0 };
                        }

                        let destLeft = Math.round(destRect.left + destRect.width / 2);
                        let destTop = Math.round(destRect.top + destRect.height / 2);

                        floatingScore.style.position = 'fixed';
                        floatingScore.style.left = destLeft + 'px';
                        floatingScore.style.top = destTop + 'px';
                        // apply temporary transform so we can measure size
                        floatingScore.style.transform = 'translate(-50%, -50%) scale(0.95)';
                        floatingScore.style.zIndex = '10001';
                        // ensure mobile-friendly size and prevent wrapping/truncation
                        floatingScore.style.whiteSpace = 'nowrap';
                        floatingScore.style.fontSize = '1.2rem';
                        floatingScore.style.padding = '2px 6px';
                        floatingScore.style.borderRadius = '6px';
                        floatingScore.style.background = 'rgba(255,255,255,0.06)';
                        floatingScore.style.backdropFilter = 'saturate(120%) blur(4px)';
                        floatingScore.style.opacity = '0';
                        document.body.appendChild(floatingScore);

                        // Measure and clamp using the popup's size so it won't be clipped at edges.
                        const popupRect = floatingScore.getBoundingClientRect();
                        const popupW = popupRect.width;
                        const popupH = popupRect.height;

                        // Determine whether we should overlay directly on the gold center score
                        const useCenterOverlay = !!centerRect;

                        // compute top-left coords so the popup is fully visible
                        let destLeftPx = destLeft - Math.round(popupW / 2);
                        let destTopPx = destTop - Math.round(popupH / 2);
                        destLeftPx = Math.max(pad, Math.min(window.innerWidth - pad - popupW, destLeftPx));
                        destTopPx = Math.max(pad, Math.min(window.innerHeight - pad - popupH, destTopPx));
                        // update to clamped top-left
                        floatingScore.style.left = destLeftPx + 'px';
                        floatingScore.style.top = destTopPx + 'px';
                        floatingScore.style.transform = 'scale(0.95)';

                        // If overlaying on the center score, remove translucent background so it covers the gold number
                        if (useCenterOverlay) {
                            floatingScore.style.background = 'none';
                            floatingScore.style.backdropFilter = '';
                            floatingScore.style.padding = '0';
                            floatingScore.style.borderRadius = '0';
                            floatingScore.style.color = ''; // keep CSS class color
                            floatingScore.style.zIndex = '10002';
                            // add stronger text shadow so numeric text reads over the gold background
                            floatingScore.style.textShadow = '0 2px 8px rgba(0,0,0,0.45)';
                            // slightly increase font-size to be visually prominent
                            floatingScore.style.fontSize = '1.15rem';
                        }

                        // If we have a source element, start at its center and animate to the center score
                        if (targetElement) {
                            try {
                                const startRect = targetElement.getBoundingClientRect();
                                const startCenterX = Math.round(startRect.left + startRect.width / 2);
                                const startCenterY = Math.round(startRect.top + startRect.height / 2);
                                // compute start top-left for popup
                                let startLeftPx = startCenterX - Math.round(popupW / 2);
                                let startTopPx = startCenterY - Math.round(popupH / 2);
                                startLeftPx = Math.max(pad, Math.min(window.innerWidth - pad - popupW, startLeftPx));
                                startTopPx = Math.max(pad, Math.min(window.innerHeight - pad - popupH, startTopPx));
                                floatingScore.style.left = startLeftPx + 'px';
                                floatingScore.style.top = startTopPx + 'px';
                                floatingScore.style.transform = 'scale(1.15)';

                                // prepare transition (animate left/top and scale/opacity)
                                floatingScore.style.transition = 'left 520ms cubic-bezier(.2,.9,.2,1), top 520ms cubic-bezier(.2,.9,.2,1), opacity 520ms ease, transform 520ms cubic-bezier(.2,.9,.2,1)';
                                // force layout then animate to destination (top-left coords)
                                floatingScore.getBoundingClientRect();
                                requestAnimationFrame(() => {
                                    floatingScore.style.left = destLeftPx + 'px';
                                    floatingScore.style.top = destTopPx + 'px';
                                    floatingScore.style.opacity = '1';
                                    floatingScore.style.transform = 'scale(1)';
                                });
                            } catch (innerErr) {
                                // if measuring the source fails, fallback to showing at destination
                                floatingScore.style.opacity = '1';
                                floatingScore.style.transform = 'scale(1)';
                            }
                        } else {
                            // no source: simple pop-in at destination (already set to top-left)
                            floatingScore.style.transition = 'opacity 240ms ease, transform 320ms cubic-bezier(.2,.9,.2,1)';
                            requestAnimationFrame(() => {
                                floatingScore.style.opacity = '1';
                                floatingScore.style.transform = 'scale(1)';
                            });
                        }
                    } catch (e) {
                        // If centering failed entirely, try overlaying on the verse/chapter title (front/back)
                        const alt = document.getElementById('verseTitle') || document.getElementById('chapterTitle');
                        if (alt) {
                            // overlay directly over the title text (covering it)
                            floatingScore.style.position = 'absolute';
                            floatingScore.style.left = '50%';
                            floatingScore.style.top = '50%';
                            floatingScore.style.transform = 'translate(-50%, -50%)';
                            floatingScore.style.opacity = '1';
                            floatingScore.style.zIndex = '9999';
                            floatingScore.style.background = 'linear-gradient(90deg,#16a34a,#4ade80)';
                            floatingScore.style.color = '#fff';
                            floatingScore.style.padding = '4px 8px';
                            floatingScore.style.borderRadius = '6px';
                            alt.style.position = 'relative';
                            alt.appendChild(floatingScore);
                        } else {
                            // final fallback: attach to score container like before
                            if (targetElement) {
                                floatingScore.style.left = '50%';
                                floatingScore.style.top = '-10px';
                                floatingScore.style.transform = 'translate(-50%, -100%)';
                                targetElement.style.position = 'relative';
                                targetElement.appendChild(floatingScore);
                            } else {
                                floatingScore.style.right = '-20px';
                                floatingScore.style.top = '50%';
                                floatingScore.style.transform = 'translateY(-50%)';
                                scoreElement.parentElement.style.position = 'relative';
                                scoreElement.parentElement.appendChild(floatingScore);
                            }
                        }
                    }
                } else if (targetElement) {
                    // 在經文卡片上方顯示
                    floatingScore.style.left = '50%';
                    floatingScore.style.top = '-10px';
                    floatingScore.style.transform = 'translate(-50%, -100%)';
                    
                    targetElement.style.position = 'relative';
                    targetElement.appendChild(floatingScore);
                } else {
                    // 備用位置：分數區域右側
                    floatingScore.style.right = '-20px';
                    floatingScore.style.top = '50%';
                    floatingScore.style.transform = 'translateY(-50%)';
                    
                    scoreElement.parentElement.style.position = 'relative';
                    scoreElement.parentElement.appendChild(floatingScore);
                }
            }
            
            // 移除動畫元素
            // 使用統一的計時器清理，避免 transitionend 與 CSS 動畫競態導致中途被移除
            // 針對桌面版特效使用實際關鍵影格長度，其餘維持較短顯示時間
            let duration;
            if (floatingScore.classList && floatingScore.classList.contains('perfect-popup')) {
                duration = 4000; // perfectFloat 4s
            } else if (floatingScore.classList && floatingScore.classList.contains('celebration-popup')) {
                duration = 3000; // celebrationFloat 3s
            } else {
                duration = text.includes('完美+300') ? 2600 : text.includes('全對+100') ? 2000 : 1600;
            }
            let removed = false;
            function cleanup() {
                if (removed) return;
                removed = true;
                try { if (typeof floatingScore.__cancelInline === 'function') floatingScore.__cancelInline(); } catch(_) {}
                try { if (floatingScore.parentElement) floatingScore.parentElement.removeChild(floatingScore); } catch(e) {}
                try { scoreElement.classList.remove('score-flash'); } catch(e) {}
            }
            setTimeout(cleanup, duration + 80);

            // 控制併發量：避免過多同時存在造成重疊和卡頓
            try {
                // 僅限制普通得分氣泡；特殊（完美/全對）與大面板效果不納入
                if (!isSpecial) {
                    const maxPopups = 6; // 軟上限：同時最多 6 個
                    const list = Array.from(document.querySelectorAll('.score-popup'));
                    if (list.length > maxPopups) {
                        // 超出上限時，移除最早插入的（在 DOM 順序靠前）
                        const excess = list.length - maxPopups;
                        for (let i = 0; i < excess; i++) {
                            const n = list[i];
                            try { if (n && n !== floatingScore && n.parentElement) n.parentElement.removeChild(n); } catch(_) {}
                        }
                    }
                }
            } catch (_) { /* ignore */ }
        }
        
    // 完美關卡特效：金色星芒（避免被容器裁切，採用 fixed）
    // Perfect-level effects: golden sparkles using fixed positioning
    function createPerfectEffects(container) {
            // debug: report that perfect effects are triggered and the provided container
            try { console.log('[DEBUG] createPerfectEffects called, container:', container && (container.id || container.tagName || String(container))); } catch(e) {}
            // Create dispersed star sparkle effects. Use the high-z .gold-glitter style
            // (which uses position: fixed and a high z-index) so the stars are not
            // clipped by lower stacking contexts on desktop. We still drive the
            // sparkle animation using the existing keyframes for a consistent look.
            for (let i = 0; i < 12; i++) {
                const sparkle = document.createElement('div');
                sparkle.textContent = '✨';
                // Use the gold-glitter class (position:fixed; high z-index)
                sparkle.className = 'gold-glitter perfect-sparkle';
                // allow per-instance sizing
                sparkle.style.fontSize = '4rem';

                // evenly distributed angles with a little radius randomness
                const angle = (i / 12) * 2 * Math.PI;
                const radius = 150 + Math.random() * 100;
                const centerX = Math.round(window.innerWidth / 2);
                const centerY = Math.round(window.innerHeight / 2);

                // Place using fixed coordinates so they appear across the whole viewport
                sparkle.style.left = (centerX + Math.cos(angle) * radius) + 'px';
                sparkle.style.top = (centerY + Math.sin(angle) * radius) + 'px';
                sparkle.style.transform = 'translate(-50%, -50%)';
                sparkle.style.pointerEvents = 'none';
                // Override class animation to use sparkleEffect timing so existing keyframes are reused
                sparkle.style.animation = `sparkleEffect 1.2s ease-out ${i * 0.08}s forwards`;

                document.body.appendChild(sparkle);

                setTimeout(() => {
                    if (sparkle.parentElement) sparkle.parentElement.removeChild(sparkle);
                }, 1400 + Math.round(i * 80));
            }
        }
        
    // 全對特效：彩帶表情落下（fixed，較高 z-index）
    // Celebration effects for all-correct rounds
    function createCelebrationEffects(container) {
            // debug: report that celebration effects are triggered and the provided container
            try { console.log('[DEBUG] createCelebrationEffects called, container:', container && (container.id || container.tagName || String(container))); } catch(e) {}
            // Create celebration confetti pieces. Use fixed positioning and a
            // higher z-index so confetti is visible above typical page content
            // on desktop (prevents clipping when container has transforms).
            // fewer, gentler emoji confetti pieces
            for (let i = 0; i < 5; i++) {
                const confetti = document.createElement('div');
                confetti.textContent = '🎉';
                confetti.className = 'confetti-piece';
                // confetti-piece already defines position: fixed and animation; but
                // ensure visibility and sizing for this instance
                confetti.style.position = 'fixed';
                confetti.style.fontSize = '2.2rem';
                confetti.style.left = (20 + i * 8) + '%';
                confetti.style.top = '25%';
                confetti.style.pointerEvents = 'none';
                confetti.style.zIndex = '10005';
                // shorter animation for softer impact
                confetti.style.animation = `confettiEffect 0.8s ease-out ${i * 0.06}s forwards`;

                document.body.appendChild(confetti);

                setTimeout(() => {
                    if (confetti.parentElement) confetti.parentElement.removeChild(confetti);
                }, 900 + Math.round(i * 50));
            }
        }

        

    // 顯示遊戲提示（可愛吐司）；回傳隱藏函數
    // Show a cute in-game toast; returns a hide function
    function showGameInstruction(text, autoFadeMs = 2000) {
            // 使用可愛吐司提示取代覆蓋層
            // 若傳入 0 表示不要自動隱藏；若未提供則採用預設 2000ms
            const dur = (typeof autoFadeMs === 'number') ? autoFadeMs : 2000;
            showCuteHint(text, 'purple', dur, '✨');
            // 回傳淡出函數供外部手動調用
            return () => hideCuteHint();
        }
        
    // 顯示一次性的提示提醒（每關一回）
    // Show a one-time per-level hint reminder
    function showHintReminder() {
            // 用可愛吐司提示提醒有提示功能
            showCuteHint(pick(HINTS.hintReminder), 'amber', 2400, '💡');
        }

    // 進入下一關：檢查題庫剩餘數、重置單關狀態
    // Advance to next level; reset per-level flags
    function nextLevel() {
            console.log('[DEBUG] nextLevel invoked, currentLevel=', gameState.currentLevel);
            // 保守：在嘗試進入下一關前先鎖住互動，並在最終 finally 中一定會解除
            try { setLevelInteractionLock(true); } catch(_) {}

            try {
                // 在進入下一關前，先檢查剩餘未使用的可用經文數是否足夠（至少 5 篇）
                try {
                    const pool = getAvailableVerses();
                    const usedKey = (v) => `${v.book}|${v.chapter}|${v.verse}`;
                    const usedVersesSet = gameState.usedVerses || new Set();
                    const uniqueRemaining = Array.isArray(pool) ? pool.filter(v => !usedVersesSet.has(usedKey(v))).length : 0;
                    console.log(`[DEBUG] nextLevel: uniqueRemaining=${uniqueRemaining}, used=${usedVersesSet.size}, pool=${Array.isArray(pool)?pool.length:0}, currentLevel=${gameState.currentLevel}`);
                    if (uniqueRemaining < 5) {
                        console.warn('[DEBUG] nextLevel: insufficient uniqueRemaining -> completeGame()');
                        alert('⚠️ 剩餘未使用的可用經文不足 5 篇，請擴大範圍或改選罕見度。本局將結束。');
                        // 結束本局並顯示結算
                        completeGame();
                        return;
                    }
                } catch (e) {
                    // 若檢查過程發生例外，紀錄但嘗試繼續（以避免誤判為無法切關）
                    console.warn('[DEBUG] nextLevel: exception during available verses check', e);
                }

                // 進入下一關：更新狀態
                gameState.currentLevel++;
                gameState.isFirstQuestionOfLevel = true;
                gameState.levelHintReminderShown = false; // 重置每關提示提醒狀態
                gameState.levelFailedCount = 0; // 重置每關完全失敗題數
                gameState.levelEndHandled = false; // 重置關卡結束防重入旗標

                // 嘗試產生下一關並更新 UI；若失敗則回退並安全結束，避免卡住
                try {
                    generateLevel();
                    updateGameUI();
                } catch (e) {
                    console.error('[DEBUG] nextLevel: exception during generateLevel/updateGameUI', e);
                    // 回退 currentLevel
                    gameState.currentLevel = Math.max(1, gameState.currentLevel - 1);
                    // 提示使用者並結束本局，防止遊戲卡死
                    try { alert('發生錯誤，無法載入下一關，遊戲將結束（請查看 console）。'); } catch(_) {}
                    completeGame();
                    return;
                }
            } finally {
                // 確保在任一情況下都會解除互動鎖（保護性）
                try { setLevelInteractionLock(false); } catch (e) { console.warn('[DEBUG] nextLevel: failed to release interaction lock', e); }
            }
        }

    // 完成本局：停止計時、計算時間獎懲、儲存紀錄、顯示結算
    // Complete the run: stop timer, compute time reward, save record, show modal
    function completeGame() {
            // 停止計時器
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            // 解除互動鎖，避免結算視窗無法操作
            try { setLevelInteractionLock(false); } catch(_) {}
            
            // 標記遊戲完成並記錄完成時間
            gameState.gameCompleted = true;
            gameState.gameEndTime = Date.now(); // 記錄遊戲結束時間
            
            // 先計算 accuracy 並更新/選定結語經文，讓之後的儲存會包含相同的 closing verse
            const accuracy = gameState.totalQuestions > 0 ? Math.round((gameState.totalCorrectAnswers / gameState.totalQuestions) * 100) : 0;
            try { updateClosingVerse(accuracy); } catch (e) {}

            // 結算：計算本局「時間獎懲」總分，方便在詳細計分與排行榜紀錄中顯示
            try {
                if (gameState.showTimeReward) {
                    const correctAnswers = gameState.totalCorrectAnswers || 0;
                    // 依排行模式（罕見度）決定每題基礎分，否則預設 100
                    const rarityBaseMap = { common: 100, rare: 125, all: 150 };
                    const perQ = gameState.rarity ? (rarityBaseMap[gameState.rarity] || 100) : 100;
                    const baseScore = correctAnswers * perQ;
                    const totalMistakes = gameState.totalMistakes || 0;
                    const bonusScore = (function () {
                        let b = 0;
                        // 關卡獎勵
                        Object.values(gameState.levelResults || {}).forEach(r => {
                            if (r === 'perfect') b += 300; else if (r === 'complete') b += 100;
                        });
                        // 提示獎勵
                        const hintCounts = { easy: 3, normal: 3, hard: 3 };
                        const totalHints = hintCounts[gameState.difficulty];
                        const hintsRemaining = (totalHints != null ? totalHints : 0) - (gameState.usedHints ? gameState.usedHints.size : 0);
                        if (hintsRemaining > 0) b += hintsRemaining * 100;
                        return b;
                    })();
                    // 回加 25 × 失誤數，扣除所有額外獎勵，剩下即為時間獎懲總分
                    const timeScore = (gameState.score || 0) - baseScore + (totalMistakes * 50) - bonusScore;
                    gameState.timeReward = Math.round(timeScore);
                } else {
                    gameState.timeReward = null;
                }
            } catch(_) { /* non-fatal */ }

            // 保存分數到排行榜（此時 gameState.closingVerse 已存在）
            // Visual feedback on game completion
            try { pulseCenterScore(gameState.score ? Math.min(300, gameState.score) : 100); } catch(e) {}
            try { spawnScoreParticles(gameState.score ? Math.min(300, gameState.score) : 100); } catch(e) {}

            const gameRecord = saveScore(gameState.score);
            
            // 直接在遊戲畫面顯示結算視窗
            checkAndShowGameComplete(gameRecord);
        }
        
    // 結束後：依是否為排行模式計算名次並顯示對應結算視窗
    // After completion: compute potential rank and show end modal
    async function checkAndShowGameComplete(gameRecord) {
            let rank = 0;
            
            // 只有選擇排行模式（罕見度）且完成遊戲才能進入排行榜
            if (gameState.rarity && gameState.gameCompleted) {
                const ldr = loadLeaderboard();
                const allLeaderboards = (ldr && typeof ldr.then === 'function') ? await ldr : ldr;
                const currentLeaderboard = (allLeaderboards && allLeaderboards[gameState.difficulty]) ? allLeaderboards[gameState.difficulty] : [];
                
                // 檢查是否能進入排行榜（前5名）
                if (currentLeaderboard.length < 5) {
                    // 排行榜未滿，直接進入（最多保留前5名）
                    rank = currentLeaderboard.length + 1;
                } else {
                    // 檢查是否超過最低分數
                    const lowestScore = currentLeaderboard[currentLeaderboard.length - 1].score;
                    if (gameState.score > lowestScore) {
                        // 計算排名
                        for (let i = 0; i < currentLeaderboard.length; i++) {
                            if (gameState.score > currentLeaderboard[i].score) {
                                rank = i + 1;
                                break;
                            }
                        }
                        if (rank === 0) rank = currentLeaderboard.length + 1;
                    }
                }
            }
            
            // 顯示結算視窗
            if (gameState.skipLeaderboardOnComplete && gameState.replaySourceRecord) {
                // For replay runs: show a modal that visually matches the leaderboard-record view
                showReplayEndModal(rank, gameState.replaySourceRecord);
            } else {
                // 傳入本局的紀錄，供「同題重玩」於未入榜時可用
                showPlayerNameModal(rank, gameRecord);
            }
        }

        // Show the end-of-replay modal: reuse the same modal structure as record-view but
        // populate static fields (closing verse, date/time, player name) from the original record
        // while recalculating the detailed score breakdown from the current gameState.
    // 重播結束視窗：沿用排行榜檢視版面，使用原紀錄靜態欄位
    // Show end-of-replay modal using original record fields
    function showReplayEndModal(rank, sourceRecord) {
            const modal = document.getElementById('playerNameModal');
            if (!modal) return;

            // Ensure modal is in 'viewing' mode so name input is hidden and close behaves like record view
            modal.dataset.viewingRecord = 'true';
            modal.dataset.viewingDifficulty = sourceRecord.difficulty || gameState.difficulty || '';
            // Set currentRecord so the "同題重玩" button can start another replay using the same snapshot
            try { modal.dataset.currentRecord = JSON.stringify(sourceRecord); } catch (e) { modal.dataset.currentRecord = ''; }

            // Update static displays using the stored record so it matches exactly what was shown when saved
            // but ensure score breakdown is rebuilt from the live gameState
            const rankMessage = document.getElementById('rankMessage');
            const leaderboardMessage = document.getElementById('leaderboardMessage');
            const leaderboardHeader = document.getElementById('leaderboardHeader');

                document.getElementById('finalScore').textContent = '0';
            const accuracy = gameState.totalQuestions > 0 ? Math.round((gameState.totalCorrectAnswers / gameState.totalQuestions) * 100) : 0;
                document.getElementById('finalAccuracy').textContent = '0%';
            const ratioEl = document.getElementById('finalAccuracyRatio');
            if (ratioEl) ratioEl.innerHTML = `<strong>(${gameState.totalCorrectAnswers}/${gameState.totalQuestions})</strong>`;

            // Populate closing verse from the original saved record so it matches the leaderboard view
            try {
                const closingTextEl = document.getElementById('closingVerseText');
                const closingRefEl = document.getElementById('closingVerseRef');
                if (sourceRecord.closingVerse || sourceRecord.closingVerseRef) {
                    applyClosingVerse(sourceRecord.closingVerse, sourceRecord.closingVerseRef, false);
                } else {
                    // fallback to current gameState chosen verse
                    updateClosingVerse(accuracy);
                }
            } catch (e) {}

            // For replay runs we should NOT show any "entered leaderboard" congratulations
            // Always hide the leaderboard message/header and the name input so it matches record view
            if (leaderboardHeader) leaderboardHeader.innerHTML = '';
            if (leaderboardMessage) leaderboardMessage.classList.add('hidden');

            // Hide name input (viewing mode)
            const nameInputSection = document.getElementById('nameInputSection');
            if (nameInputSection) nameInputSection.classList.add('hidden');

            // Show the same-question replay button even in replay end modal (allow infinite replays)
            const replayBtn = document.getElementById('replaySameQuestionsBtn');
            if (replayBtn) {
                replayBtn.classList.remove('hidden');
            }

            // Rebuild the detailed breakdown from current gameState (not the stored record)
            generateScoreBreakdown();

            // Finally show modal and lock scroll
            modal.classList.remove('hidden');
            lockBodyScroll();

            // Clear input and errors
            const input = document.getElementById('playerNameInput');
            if (input) input.value = '';
            const nameError = document.getElementById('nameError');
            if (nameError) nameError.classList.add('hidden');

            // Enable Enter-to-confirm while this modal is open
            try { attachPlayerNameModalEnterHotkey(); } catch (e) {}
        }

    // 舊流程：完成後若符合條件才進入排行榜取名（保留）
    // Legacy flow: gate leaderboard entry by conditions
    async function checkAndShowLeaderboardEntry(gameRecord) {
            // 只有選擇整本聖經且完成遊戲才能進入排行榜
            if (gameState.range !== 'all' || !gameState.gameCompleted) {
                return;
            }
            
            const ldr = loadLeaderboard();
            const allLeaderboards = (ldr && typeof ldr.then === 'function') ? await ldr : ldr;
            const currentLeaderboard = (allLeaderboards && allLeaderboards[gameState.difficulty]) ? allLeaderboards[gameState.difficulty] : [];
            
            // 檢查是否能進入排行榜（前5名）
            let canEnterLeaderboard = false;
            let rank = 0;
            if (currentLeaderboard.length < 5) {
                // 排行榜未滿，直接進入（最多保留前5名）
                canEnterLeaderboard = true;
                rank = currentLeaderboard.length + 1;
            } else {
                // 檢查是否超過最低分數
                const lowestScore = currentLeaderboard[currentLeaderboard.length - 1].score;
                if (gameState.score > lowestScore) {
                    canEnterLeaderboard = true;
                    // 計算排名
                    for (let i = 0; i < currentLeaderboard.length; i++) {
                        if (gameState.score > currentLeaderboard[i].score) {
                            rank = i + 1;
                            break;
                        }
                    }
                    if (rank === 0) rank = currentLeaderboard.length + 1;
                }
            }
            
            if (canEnterLeaderboard) {
                showPlayerNameModal(rank);
            }
        }

    // 顯示取名/結算視窗（含名次、明細、結語經文）
    // Show player-name modal with breakdown and closing verse
    function showPlayerNameModal(rank, currentGameRecord = null) {
            const modal = document.getElementById('playerNameModal');
            const rankMessage = document.getElementById('rankMessage');
            const leaderboardMessage = document.getElementById('leaderboardMessage');
            const leaderboardHeader = document.getElementById('leaderboardHeader');
            const nameInputSection = document.getElementById('nameInputSection');
            // Hide cute hint to avoid overlapping with modal
            try { hideCuteHint(); } catch (e) {}
            // Defensive: if duplicate closing verse elements were ever inserted, dedupe now
            try {
                const cv = document.getElementById('closingVerse');
                if (cv) {
                    const texts = cv.querySelectorAll('#closingVerseText');
                    const refs = cv.querySelectorAll('#closingVerseRef');
                    for (let i = 1; i < texts.length; i++) texts[i].remove();
                    for (let i = 1; i < refs.length; i++) refs[i].remove();
                }
            } catch (_) {}
            
            // 更新分數資訊
            document.getElementById('finalScore').textContent = '0';
            const accuracy = gameState.totalQuestions > 0 ? Math.round((gameState.totalCorrectAnswers / gameState.totalQuestions) * 100) : 0;
            document.getElementById('finalAccuracy').textContent = '0%';
            const ratioEl = document.getElementById('finalAccuracyRatio');
            if (ratioEl) ratioEl.innerHTML = `<strong>(${gameState.totalCorrectAnswers}/${gameState.totalQuestions})</strong>`;
            
            // 生成詳細計分數據
            generateScoreBreakdown();
            
            // 根據遊玩狀況選擇結語經文
            updateClosingVerse(accuracy);
            
            // 如果進入排行榜，顯示排行榜訊息和名稱輸入
            // Also: when this modal is the post-game end modal, only show the same-question
            // replay button if this run did NOT actually enter the leaderboard (rank === 0).
            const replayBtn = document.getElementById('replaySameQuestionsBtn');
            const sameReplayNote = document.getElementById('sameReplayNote');
            if (rank > 0) {
                rankMessage.textContent = `您獲得了第${rank}名！`;
                if (leaderboardHeader) {
                    // choose class based on rank for visual styling
                    let cls = 'rank-default';
                    if (rank === 1) cls = 'rank-gold';
                    else if (rank === 2) cls = 'rank-silver';
                    else if (rank === 3) cls = 'rank-bronze';
                    leaderboardHeader.classList.remove('rank-gold','rank-silver','rank-bronze','rank-default');
                    leaderboardHeader.classList.add(cls);
                    leaderboardHeader.innerHTML = `
                        <span class="rank-header ${cls}">
                            <span class="rank-badge">${rank}</span>
                            <span class="rank-title">第${rank}名</span>
                        </span>
                    `;
                }
                leaderboardMessage.classList.remove('hidden');
                // 確保不是檢視模式
                if (modal) modal.dataset.viewingRecord = '';
                nameInputSection.classList.remove('hidden');
                // If the run actually entered the leaderboard, hide the replay button in the post-game modal
                if (replayBtn) replayBtn.classList.add('hidden');
            } else {
                if (leaderboardHeader) leaderboardHeader.innerHTML = '';
                leaderboardMessage.classList.add('hidden');
                nameInputSection.classList.add('hidden');
                // If the run did NOT enter the leaderboard, allow same-question replay from the end modal
                if (replayBtn) replayBtn.classList.remove('hidden');
                // 為避免未入榜也嘗試儲存，明確標示為「不可列入排行榜」的重玩
                try { modal.dataset.viewingRecord = 'true'; } catch(_) {}
            }

            // Hide the explanatory note if the same-question replay button is not available
            try {
                if (sameReplayNote) {
                    if (!replayBtn || replayBtn.classList.contains('hidden')) {
                        sameReplayNote.classList.add('hidden');
                    } else {
                        sameReplayNote.classList.remove('hidden');
                    }
                }
            } catch (e) { /* ignore */ }
            
            // Ensure modal is attached to document.body so it isn't placed inside lower stacking contexts
            if (modal && modal.parentElement !== document.body) {
                try { document.body.appendChild(modal); } catch (e) { /* ignore */ }
            }
            // Ensure modal overlay is above pinned controls (which use very high z-index on mobile)
            if (modal) {
                try { modal.style.zIndex = '11000'; } catch (e) { /* ignore */ }
            }
            // 若有傳入本局紀錄，附加到 dataset 供同題重玩使用（未入榜也可以重玩）
            try {
                if (modal && currentGameRecord) {
                    modal.dataset.currentRecord = JSON.stringify(currentGameRecord);
                }
            } catch(_) {}
            modal.classList.remove('hidden');
            // lock background scroll for mobile comfort
            lockBodyScroll();
            
            // 清空輸入框
            document.getElementById('playerNameInput').value = '';
            document.getElementById('nameError').classList.add('hidden');

            // Enable Enter-to-confirm while this modal is open
            try { attachPlayerNameModalEnterHotkey(); } catch (e) {}
        }

    // 在顯示覆蓋層時鎖定背景滾動（行動裝置舒適度）
    // Lock body scroll while modal overlays are visible
    function lockBodyScroll() {
            // remember previous overflow
            try {
                document.body.dataset._prevOverflow = document.body.style.overflow || '';
                document.body.style.overflow = 'hidden';
                document.body.style.touchAction = 'none';
            } catch (e) {}
        }

        // Add click handlers so tapping the big score triggers a small pulse + particles
        try {
            document.addEventListener('DOMContentLoaded', () => {
                const center = document.getElementById('centerScore');
                if (center) {
                    center.style.cursor = 'pointer';
                    center.addEventListener('click', (e) => {
                        try { pulseCenterScore(50); } catch(e) {}
                        try { spawnScoreParticles(50); } catch(e) {}
                    });
                }

                const final = document.getElementById('finalScore');
                if (final) {
                    final.style.cursor = 'pointer';
                    final.addEventListener('click', (e) => {
                        try { pulseCenterScore(50); } catch(e) {}
                        // originRect: spawn near the finalScore element
                        try { spawnScoreParticles(50, final.getBoundingClientRect()); } catch(e) {}
                    });
                }

                // Also allow the main title to trigger the same effect when tapped/clicked
                const mainTitle = document.getElementById('mainTitle');
                if (mainTitle) {
                    mainTitle.style.cursor = 'pointer';
                    mainTitle.addEventListener('click', (e) => {
                        try { pulseCenterScore(50); } catch(e) {}
                        try { spawnScoreParticles(50, mainTitle.getBoundingClientRect()); } catch(e) {}
                    });
                }

                // Hint button: trigger a small star burst originating from the button (no center pulse/glow)
                const hintBtn = document.getElementById('hintBtn');
                if (hintBtn) {
                    hintBtn.addEventListener('click', (e) => {
                        if (hintBtn.disabled) return;
                        try { spawnScoreParticles(50, hintBtn.getBoundingClientRect()); } catch(e) {}
                    });
                }

                // scoring toggle for mobile: hide details but provide expand control
                try {
                    const toggleBtn = document.getElementById('toggleScoringBtn');
                    const scoringCard = document.getElementById('scoringCard');
                    if (toggleBtn && scoringCard) {
                        // show toggle only on small viewports
                        const showToggle = window.matchMedia && window.matchMedia('(max-width:420px)').matches;
                        if (showToggle) toggleBtn.style.display = 'inline-block';
                        // helper to set label text while preserving leading emoji/icon
                        const setToggleLabel = (open) => {
                            const labelSpan = toggleBtn.querySelector('span:not([aria-hidden])');
                            const text = open ? '收起計分說明' : '顯示計分說明';
                            if (labelSpan) labelSpan.textContent = text; else toggleBtn.textContent = text;
                            // update aria and chevron
                            toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
                            const chev = toggleBtn.querySelector('.chev');
                            if (chev) chev.style.transform = open ? 'rotate(180deg)' : 'none';
                            // announce state for screen readers
                            const live = document.getElementById('toggleScoringA11y');
                            if (live) live.textContent = open ? '已展開計分說明' : '已收起計分說明';
                        };
                        // initialize label based on current state
                        const initiallyOpen = scoringCard.classList.contains('scoring-open');
                        setToggleLabel(initiallyOpen);

                        toggleBtn.addEventListener('click', () => {
                            const open = scoringCard.classList.toggle('scoring-open');
                            setToggleLabel(open);
                        });
                    }
                } catch (e) { /* ignore */ }
            });
        } catch (e) { /* defensive: ignore if DOM not ready in some environments */ }

        // 全域：偵測並追蹤「減少動態效果」偏好（效能/無障礙）
        (function(){
            try {
                const mq = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
                window.__reducedMotion = !!(mq && mq.matches);
                if (mq && mq.addEventListener) {
                    mq.addEventListener('change', (e) => { window.__reducedMotion = !!e.matches; });
                }
            } catch (e) { /* ignore */ }
        })();
    // 回傳目前是否啟用「減少動態效果」偏好
    // Read reduced-motion preference flag
    function getReducedMotion() { return !!window.__reducedMotion; }

    // 還原先前的 body 滾動設定
    // Restore body scroll after modal close
    function unlockBodyScroll() {
            try {
                document.body.style.overflow = document.body.dataset._prevOverflow || '';
                document.body.style.touchAction = '';
                delete document.body.dataset._prevOverflow;
            } catch (e) {}
        }
        
        // Attach/detach an Enter key handler that confirms and returns to main menu when the end-game modal is open
    // 在結算視窗開啟時，綁定 Enter 快速確認的快捷鍵
    // Attach Enter hotkey for confirming while modal open
    function attachPlayerNameModalEnterHotkey() {
            try {
                const modal = document.getElementById('playerNameModal');
                if (!modal) return;
                // Remove previous handler if any
                if (modal.__enterHandler) {
                    try { document.removeEventListener('keydown', modal.__enterHandler); } catch (e) {}
                    modal.__enterHandler = null;
                }
                const handler = (ev) => {
                    if (ev && ev.key === 'Enter' && !ev.shiftKey && !ev.ctrlKey && !ev.altKey && !ev.metaKey) {
                        // Only trigger if modal is actually visible
                        if (!modal.classList.contains('hidden')) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            try { confirmPlayerName(); } catch (e) {}
                        }
                    }
                };
                modal.__enterHandler = handler;
                document.addEventListener('keydown', handler);
            } catch (e) { /* ignore */ }
        }

    // 解除前述快捷鍵（避免影響其他畫面）
    // Detach the Enter hotkey handler
    function detachPlayerNameModalEnterHotkey() {
            try {
                const modal = document.getElementById('playerNameModal');
                if (!modal) return;
                const handler = modal.__enterHandler;
                if (handler) {
                    try { document.removeEventListener('keydown', handler); } catch (e) {}
                    modal.__enterHandler = null;
                }
            } catch (e) { /* ignore */ }
        }

        // Utility: clear all leaderboard records (online if adapter exists, plus local cache)
        window.clearAllLeaderboardsNow = async function() {
            try {
                if (window.Leaderboard && typeof window.Leaderboard.clear === 'function') {
                    try { await window.Leaderboard.clear(); } catch (e) { /* ignore remote errors */ }
                }
            } catch (_) { /* ignore */ }
            try { localStorage.removeItem('bibleGameLeaderboard'); } catch(_) {}
            try { updateLeaderboardDisplay && updateLeaderboardDisplay(); } catch(_) {}
        };

        // URL trigger: add #clearLeaderboard or ?clearLeaderboard=1 to invoke clearing without UI clicks
        (function attachClearLeaderboardTrigger(){
            try {
                const url = new URL(window.location.href);
                const hash = (url.hash || '').toLowerCase();
                const qs = url.searchParams;
                const shouldClear = hash.includes('clearleaderboard') || qs.has('clearLeaderboard') || qs.get('clear') === 'leaderboard';
                if (shouldClear) {
                    // Defer to ensure DOM is ready and adapters initialized
                    setTimeout(async () => {
                        try { await window.clearAllLeaderboardsNow(); } catch(_) {}
                        try { alert('已清空排行榜紀錄'); } catch(_) {}
                    }, 100);
                }
            } catch (e) { /* ignore */ }
        })();
        
        // Wrapper kept for backwards compatibility when called from game-end flow
    // 由當前遊戲狀態生成結算明細（UI 包裝器）
    // Render score breakdown from live gameState
    function generateScoreBreakdown() {
            renderScoreBreakdown(gameState, { isRecord: false });
        }
        
    // 解析字串得分（拆出 +/-、數值與尾碼）
    // Parse a score display string into parts
    function parseScoreDisplay(text) {
            try {
                const s = String(text || '').trim();
                const m = s.match(/^([+\-])?(\d+)(.*)$/);
                if (!m) return { sign: '', value: 0, suffix: '' };
                const sign = m[1] || '';
                const value = parseInt(m[2], 10) || 0;
                const suffix = (m[3] || '').trim();
                return { sign, value, suffix };
            } catch (_) { return { sign: '', value: 0, suffix: '' }; }
        }

    // 新增一行計分明細（可標註總分行）
    // Append a breakdown item row
    function addScoreItem(container, label, calculation, score, colorClass, isTotal = false) {
            const item = document.createElement('div');
            item.className = `flex justify-between items-center ${isTotal ? 'col-span-2 border-t pt-2 mt-2' : ''}`;
            const parsed = parseScoreDisplay(score);
            const hasSuffix = parsed.suffix && parsed.suffix.length > 0;
            // Mark number for animation with data attributes
            item.innerHTML = `
                <div class="flex flex-col">
                    <span class="${colorClass} text-left">${label}</span>
                    ${calculation ? `<span class="text-gray-500 text-xs">${calculation}</span>` : ''}
                </div>
                <span class="${colorClass} font-bold bd-right">
                    <span class="bd-num" data-target="${parsed.value}" data-sign="${parsed.sign}">${parsed.sign}0</span>${hasSuffix ? `<span class="bd-suffix">${parsed.suffix}</span>` : ''}
                </span>
            `;
            container.appendChild(item);
        }
        
    // 計算本局額外獎勵（完美/全對/提示）
    // Compute bonus score for the run
    function getBonusScore() {
            let bonusScore = 0;
            
            // 計算完美和全對獎勵（scaled）
            Object.values(gameState.levelResults).forEach(result => {
                if (result === 'perfect') bonusScore += 300;
                else if (result === 'complete') bonusScore += 100;
            });
            
            // 計算提示獎勵（scaled）
            const hintCounts = { easy: 3, normal: 3, hard: 3 };
            const totalHints = hintCounts[gameState.difficulty];
            const hintsRemaining = totalHints - gameState.usedHints.size;
            bonusScore += hintsRemaining * 100;
            
            return bonusScore;
        }

        // Shared renderer used by both game-end and leaderboard record views
    // 共用渲染器：支援遊戲結束與排行榜紀錄檢視
    // Shared breakdown renderer for end-game and record view
    function renderScoreBreakdown(source, options = {}) {
            const container = document.getElementById('scoreBreakdownContent');
            if (!container) return;
            container.innerHTML = '';

            const isRecord = !!options.isRecord;

            // 先即時顯示結算摘要（難度／經文／用時），避免首次開啟時延遲顯示
            try {
                const metaEl = document.getElementById('finalMetaLine');
                if (metaEl) {
                    let diffLabel = '';
                    try {
                        const d = (source.difficulty || gameState.difficulty || '').toString();
                        if (d === 'easy') diffLabel = '簡單';
                        else if (d === 'normal') diffLabel = '普通';
                        else if (d === 'hard') diffLabel = '困難';
                    } catch(_) {}

                    let timeText = '';
                    try {
                        if (isRecord && source.time) {
                            timeText = `${source.time}`;
                        } else {
                            const end = gameState.gameEndTime || Date.now();
                            const start = gameState.gameStartTime || end;
                            const secs = Math.max(0, Math.floor((end - start) / 1000));
                            const m = Math.floor(secs / 60);
                            const s = (secs % 60).toString().padStart(2, '0');
                            timeText = `${m}:${s}`;
                        }
                    } catch(_) {}

                    let rarityPart = '';
                    try {
                        const r = (source.rarity || gameState.rarity || '').toString();
                        let rarityLabel = '';
                        if (r === 'common') rarityLabel = '常見';
                        else if (r === 'rare') rarityLabel = '冷門';
                        else if (r === 'all') rarityLabel = '全部';
                        if (rarityLabel) rarityPart = `經文：${rarityLabel}`;
                    } catch(_) {}

                    const parts = [];
                    if (diffLabel) parts.push(`難度：${diffLabel}`);
                    if (rarityPart) parts.push(rarityPart);
                    if (timeText) parts.push(`用時：${timeText}`);
                    metaEl.textContent = parts.join(' · ');
                    metaEl.classList.remove('hidden');
                }
            } catch(_) { /* ignore */ }

            // 正規化來源（遊戲中狀態 vs. 紀錄）
            // Normalize fields between live gameState and stored record
            const correctAnswers = source.correctAnswers != null ? source.correctAnswers : (source.totalCorrectAnswers != null ? source.totalCorrectAnswers : 0);
            const totalMistakes = source.totalMistakes != null ? source.totalMistakes : 0;
            const difficulty = source.difficulty || gameState.difficulty;

                    // 基礎分數（依罕見度 / 練習固定）
            const rarity = source.rarity || gameState.rarity || null;
            const rarityLabel = '';
            const rarityBaseMap = { common: 100, rare: 125, all: 150 };
            const perQ = rarity ? (rarityBaseMap[rarity] || 100) : 100;
            const baseScore = correctAnswers * perQ;
            addScoreItem(container, '基礎分數', `${correctAnswers} × ${perQ}`, `+${baseScore}分`, 'text-blue-600');

            // 失誤扣分
            if (totalMistakes > 0) {
                const mistakeDeduction = totalMistakes * 50;
                addScoreItem(container, '失誤扣分', `${totalMistakes} × 50`, `-${mistakeDeduction}分`, 'text-red-600');
            }

            // 時間獎懲：顯示平均用時（平均：x.x 秒/題），record 使用記錄，live 以本局時間計算
            if (isRecord) {
                // For record view we only render time-based score adjustments if a numeric timeReward exists.
                if (source.timeReward != null) {
                    const timeScore = source.timeReward;
                    const sign = timeScore > 0 ? '+' : '';
                    // 平均每題用時（以記錄的 time 與 totalQuestions 計算）
                    // Average seconds per question derived from saved mm:ss and totalQuestions
                    let timeDisplay = '';
                    try {
                        const totalQ = (source.totalQuestions != null) ? source.totalQuestions : (gameState.totalQuestions || 0);
                        let secs = 0;
                        if (source.time && typeof source.time === 'string') {
                            const mmss = String(source.time).trim();
                            const m = parseInt(mmss.split(':')[0] || '0', 10) || 0;
                            const s = parseInt(mmss.split(':')[1] || '0', 10) || 0;
                            secs = (m * 60) + s;
                        }
                        if (totalQ > 0 && secs > 0) {
                            const avg = secs / totalQ;
                            const text = (Math.round(avg * 10) / 10).toFixed(1);
                            timeDisplay = `${text} 秒/題`;
                        }
                    } catch(_) {}
                    const label = '時間獎懲';
                    const colorClass = timeScore > 0 ? 'text-indigo-600' : 'text-rose-600';
                    addScoreItem(container, label, timeDisplay, `${sign}${timeScore}分`, colorClass);
                }
            } else {
                if (gameState.showTimeReward) {
                    // 修正：依規則應回加 50 × 失誤數 以消除失誤扣分的影響
                    // Note: add back 50 × mistakes to neutralize mistake deduction before timeReward
                    const timeScore = gameState.score - baseScore + (totalMistakes * 50) - getBonusScore();
                    const sign = timeScore > 0 ? '+' : '';
                    // 顯示平均用時（不含結算視窗時間）
                    let timeDisplay = '';
                    try {
                        const end = gameState.gameEndTime || Date.now();
                        const start = gameState.gameStartTime || end;
                        const secs = Math.max(0, Math.floor((end - start) / 1000));
                        const totalQ = gameState.totalQuestions || 0;
                        if (totalQ > 0 && secs > 0) {
                            const avg = secs / totalQ;
                            const text = (Math.round(avg * 10) / 10).toFixed(1);
                            timeDisplay = `${text} 秒/題`;
                        }
                    } catch(_) {}
                    const label = '時間獎懲';
                    const colorClass = timeScore > 0 ? 'text-indigo-600' : 'text-rose-600';
                    addScoreItem(container, label, timeDisplay, `${sign}${Math.round(timeScore)}分`, colorClass);
                }
            }

            // 關卡獎勵
            let perfectCount = 0;
            let completeCount = 0;
            const levelResults = source.levelResults || {};
            Object.values(levelResults).forEach(r => {
                if (r === 'perfect') perfectCount++;
                else if (r === 'complete') completeCount++;
            });

            if (perfectCount > 0) addScoreItem(container, '完美獎勵', `${perfectCount} × 300`, `+${perfectCount * 300}分`, 'text-yellow-600');
            if (completeCount > 0) addScoreItem(container, '全對獎勵', `${completeCount} × 100`, `+${completeCount * 100}分`, 'text-green-600');

            // 提示獎勵
        if (isRecord) {
                if (source.hintsRemaining != null && source.totalHints != null) {
                    const hintsLeft = source.hintsRemaining || 0;
            if (hintsLeft > 0) addScoreItem(container, '提示獎勵', `${hintsLeft} × 100`, `+${hintsLeft * 100}分`, 'text-orange-600');
                }
            } else {
                const hintCounts = { easy: 3, normal: 3, hard: 3 };
                const totalHints = hintCounts[difficulty];
                const hintsUsedCount = gameState.usedHints ? gameState.usedHints.size : 0;
                const hintsRemaining = totalHints - hintsUsedCount;
                if (hintsRemaining > 0) {
            const hintBonus = hintsRemaining * 100;
            addScoreItem(container, '提示獎勵', `${hintsRemaining} × 100`, `+${hintBonus}分`, 'text-orange-600');
                }
            }

            // 總分
            const totalScore = source.score != null ? source.score : (gameState.score || 0);
            addScoreItem(container, '總分', '', `${totalScore}分`, 'text-purple-700 font-bold', true);

            // Animate breakdown numbers first; then animate final score and accuracy
            try {
                const nums = Array.from(container.querySelectorAll('.bd-num'));
                const reduced = getReducedMotion && getReducedMotion();
                const perItem = reduced ? 480 : 720;
                const gap = reduced ? 80 : 160;
                let totalDelay = 0;
                nums.forEach((n, i) => {
                    const target = parseInt(n.dataset.target || '0', 10) || 0;
                    const sign = n.dataset.sign || '';
                    const dur = perItem + Math.min(1200, Math.floor(target * 8));
                    setTimeout(() => {
                        try { animateInlineNumber(n, 0, target, dur, sign); } catch(_) {}
                    }, totalDelay);
                    totalDelay += gap;
                });

                // After breakdown anim completes, animate final score and accuracy
                setTimeout(() => {
                    try {
                        const finalScoreEl = document.getElementById('finalScore');
                        const finalAccEl = document.getElementById('finalAccuracy');
                        const metaEl = document.getElementById('finalMetaLine');
                        const total = totalScore;
                        if (finalScoreEl) {
                            // ensure starts at 0 then count up
                            finalScoreEl.textContent = '0';
                            animateInlineNumber(finalScoreEl, 0, total, reduced ? 1200 : 1800, '');
                        }
                        if (finalAccEl) {
                            // parse (x/y) for accurate percentage
                            const ratioEl = document.getElementById('finalAccuracyRatio');
                            let acc = 0;
                            try {
                                const t = ratioEl && ratioEl.textContent ? ratioEl.textContent : '';
                                const m = t.match(/(\d+)\/(\d+)/);
                                if (m) {
                                    const got = parseInt(m[1], 10) || 0;
                                    const tot = parseInt(m[2], 10) || 0;
                                    acc = tot > 0 ? Math.round((got / tot) * 100) : 0;
                                }
                            } catch(_) {}
                            // Keep % sign visible during the count-up: animate only the numeric span
                            finalAccEl.innerHTML = '<span class="acc-num">0</span><span class="acc-unit">%</span>';
                            const numEl = finalAccEl.querySelector('.acc-num');
                            try { animateInlineNumber(numEl, 0, acc, reduced ? 1200 : 1800, ''); } catch(_) {}
                        }

                        // Show a small meta line (difficulty + used time) to enrich the center area
                        try {
                            if (metaEl) {
                                let diffLabel = '';
                                try {
                                    const d = (source.difficulty || gameState.difficulty || '').toString();
                                    if (d === 'easy') diffLabel = '簡單';
                                    else if (d === 'normal') diffLabel = '普通';
                                    else if (d === 'hard') diffLabel = '困難';
                                } catch(_) {}

                                let timeText = '';
                                try {
                                    if (source.time) {
                                        timeText = `${source.time}`;
                                    } else {
                                        const end = gameState.gameEndTime || Date.now();
                                        const start = gameState.gameStartTime || end;
                                        const secs = Math.max(0, Math.floor((end - start) / 1000));
                                        const m = Math.floor(secs / 60);
                                        const s = (secs % 60).toString().padStart(2, '0');
                                        timeText = `${m}:${s}`;
                                    }
                                } catch(_) {}

                                const parts = [];
                                if (diffLabel) parts.push(`難度：${diffLabel}`);

                                // 出題範圍（常見/冷門/全部），僅在有選擇排行罕見度時顯示
                                try {
                                    const r = (source.rarity || gameState.rarity || '').toString();
                                    let rarityLabel = '';
                                    if (r === 'common') rarityLabel = '常見';
                                    else if (r === 'rare') rarityLabel = '冷門';
                                    else if (r === 'all') rarityLabel = '全部';
                                    if (rarityLabel) parts.push(`經文：${rarityLabel}`);
                                } catch(_) {}

                                if (timeText) parts.push(`用時：${timeText}`);
                                metaEl.textContent = parts.join(' · ');
                                metaEl.classList.remove('hidden');
                            }
                        } catch(_) {}
                    } catch (_) {}
                }, Math.max(0, totalDelay + (reduced ? 400 : 640)));
            } catch(_) { /* ignore anim errors */ }
        }

        // Backwards-compatible wrapper used when viewing a leaderboard record
    // 從排行榜紀錄渲染結算明細（補齊舊欄位）
    // Render breakdown using saved leaderboard record
    function renderScoreBreakdownFromRecord(record) {
            renderScoreBreakdown(record, { isRecord: true });
        }
        
        // Keep only one text+ref inside the closing verse container
    // 清理結語經文容器的重複節點/殘留
    // Sanitize closing verse container duplicates
    function sanitizeClosingVerseContainer() {
            try {
                const cv = document.getElementById('closingVerse');
                if (!cv) return;
                // Ensure exactly one text node and one ref node exist
                let textEl = cv.querySelector('#closingVerseText');
                let refEl = cv.querySelector('#closingVerseRef');
                // Create if missing
                if (!textEl) {
                    textEl = document.createElement('div');
                    textEl.id = 'closingVerseText';
                    textEl.className = 'text-lg font-bold text-gray-800 mb-1 closing-verse-clamp';
                    cv.insertAdjacentElement('afterbegin', textEl);
                }
                if (!refEl) {
                    refEl = document.createElement('div');
                    refEl.id = 'closingVerseRef';
                    refEl.className = 'text-sm text-gray-600 font-semibold';
                    refEl.style.marginTop = '4px';
                    cv.appendChild(refEl);
                }
                // Remove any other children except these two
                const keep = new Set([textEl, refEl]);
                Array.from(cv.childNodes).forEach(node => {
                    if (!keep.has(node)) cv.removeChild(node);
                });
            } catch (e) { /* ignore */ }
        }

        // Consistently apply closing verse text/ref to the modal and optionally persist to gameState
    // 將結語經文（文字＋參考）套用到視圖，必要時持久化
    // Apply closing verse text+ref to the view; optionally persist
    function applyClosingVerse(text, ref, persist = false) {
            sanitizeClosingVerseContainer();
            const closingVerseText = document.getElementById('closingVerseText');
            const closingVerseRef = document.getElementById('closingVerseRef');
            const safeText = (text && String(text).trim().length) ? String(text).trim() : '感謝遊玩！';
            let safeRef = (ref && String(ref).trim().length) ? String(ref).trim() : '';
            // Normalize refs that mistakenly append the verse text (e.g., "書 章:節:「經文…")
            if (safeRef) {
                const m = safeRef.match(/^(.*?\s\d+:\d+(?:-\d+)?)/);
                if (m) safeRef = m[1];
            }
            // Avoid double-leading quotes when verse itself already starts with a quote mark
            // 以中文引號包裹文本（避免重複包裹）
            // Wrap given text with Chinese quotes if not already wrapped
            function wrapChineseQuotes(s) {
                const str = String(s).trim();
                if (!str) return '';
                const leadingQuotes = ['「','『','“','"','”','』','』'];
                const first = str[0];
                // If the verse already begins with any quote mark, do not add outer quotes
                if (leadingQuotes.includes(first)) return str;
                return `「${str}」`;
            }
            if (closingVerseText) closingVerseText.textContent = wrapChineseQuotes(safeText);
            if (closingVerseRef) closingVerseRef.textContent = safeRef;
            if (persist) {
                try {
                    gameState.closingVerse = safeText;
                    gameState.closingVerseRef = safeRef;
                } catch (e) {}
            }
        }

    // 依表現（正確率）挑選合適的結語經文
    // Pick a closing verse based on run accuracy
    function updateClosingVerse(accuracy) {
            const closingVerseText = document.getElementById('closingVerseText');
            const closingVerseRef = document.getElementById('closingVerseRef');

            // 1) 準備允許的書卷（依玩家選擇的範圍）；僅用作偏好，不做強制
            // 依當前範圍（含自訂）取得允許書卷集合
            // Build allowed books set from current range/custom
            function getAllowedBooks() {
                try {
                    if (gameState.range === 'testament') return bibleBooks[gameState.testament] || [];
                    if (gameState.range === 'custom') return Array.isArray(gameState.customBooks) ? gameState.customBooks : [];
                    // 'all' 或未設定 -> 全部
                    return [...bibleBooks.old, ...bibleBooks.new];
                } catch (e) {
                    return [...bibleBooks.old, ...bibleBooks.new];
                }
            }
            const allowedBooks = getAllowedBooks();

            // 2) 輕量歷史：盡量避免最近重複，但不強制
            // 取得並維護最近使用的結語經文歷史，避免連續重複
            // Get/maintain recent closing-verse history to avoid repeats
            function getHistory() {
                try {
                    const raw = sessionStorage.getItem('closingVerseHistory');
                    const arr = raw ? JSON.parse(raw) : [];
                    return Array.isArray(arr) ? arr : [];
                } catch (e) { return []; }
            }
            // 將新的結語引用推入歷史（固定長度）
            // Push a ref into bounded history buffer
            function pushHistory(refStr) {
                try {
                    if (!refStr) return;
                    const maxKeep = 10;
                    const arr = getHistory().filter(x => x && x !== refStr);
                    arr.unshift(refStr);
                    while (arr.length > maxKeep) arr.pop();
                    sessionStorage.setItem('closingVerseHistory', JSON.stringify(arr));
                } catch (e) {}
            }
            const recentHistory = getHistory();

            // 3) 文字解析工具（僅必要時使用）
            // 將 "書名 章:節" 解析為結構化欄位
            // Parse a "Book C:V" ref into structured fields
            function parseRef(ref) {
                if (!ref || typeof ref !== 'string') return null;
                const i = ref.indexOf(' ');
                if (i <= 0) return { book: ref, chapter: null, verse: null };
                const book = ref.slice(0, i).trim();
                const rest = ref.slice(i + 1).trim();
                const m = rest.match(/^(\d+):(\d+)(?:-\d+)?$/);
                if (!m) return { book, chapter: null, verse: null };
                return { book, chapter: parseInt(m[1], 10), verse: parseInt(m[2], 10) };
            }

            // 4) 各表現等級對應的候選經文（沿用原來的精選名單；作為後備）
            const pools = {
                excellent: [
                    { text: "你們要靠主常常喜樂。我再說，你們要喜樂。", ref: "腓立比書 4:4" },
                    { text: "那美好的仗我已經打過了，當跑的路我已經跑盡了，所信的道我已經守住了。", ref: "提摩太後書 4:7" },
                    { text: "神能照著運行在我們心裡的大力充充足足地成就一切，超過我們所求所想的。", ref: "以弗所書 3:20" },
                    { text: "得勝的，我要賜他在我寶座上與我同坐。", ref: "啟示錄 3:21" },
                    { text: "忠心至死，我就賜給你那生命的冠冕。", ref: "啟示錄 2:10" },
                    { text: "好，你這又良善又忠心的僕人。", ref: "馬太福音 25:21" },
                    { text: "凡得勝的必這樣穿白衣，我也必不從生命冊上塗抹他的名。", ref: "啟示錄 3:5" },
                    { text: "義人的腳步被耶和華立定；他的道路，耶和華也喜愛。", ref: "詩篇 37:23" },
                    { text: "你們是世上的光。城造在山上是不能隱藏的。", ref: "馬太福音 5:14" },
                    { text: "聖靈所結的果子，就是仁愛、喜樂、和平。", ref: "加拉太書 5:22" }
                ],
                good: [
                    { text: "我靠著那加給我力量的，凡事都能做。", ref: "腓立比書 4:13" },
                    { text: "忘記背後，努力面前的，向著標竿直跑。", ref: "腓立比書 3:13-14" },
                    { text: "但那等候耶和華的必重新得力。", ref: "以賽亞書 40:31" },
                    { text: "你當剛強壯膽！不要懼怕，也不要驚惶。", ref: "約書亞記 1:9" },
                    { text: "當將你的事交託耶和華，並倚靠他，他就必成全。", ref: "詩篇 37:5" },
                    { text: "你們所遇見的試探，無非是人所能受的。", ref: "哥林多前書 10:13" },
                    { text: "我們行善，不可喪志；若不灰心，到了時候就要收成。", ref: "加拉太書 6:9" },
                    { text: "你要保守你心，勝過保守一切，因為一生的果效是由心發出。", ref: "箴言 4:23" },
                    { text: "應當一無掛慮，只要凡事藉著禱告、祈求，和感謝。", ref: "腓立比書 4:6" },
                    { text: "神所賜、出人意外的平安必在基督耶穌裡保守你們的心懷意念。", ref: "腓立比書 4:7" }
                ],
                encouraging: [
                    { text: "疲乏的，他賜能力；軟弱的，他加力量。", ref: "以賽亞書 40:29" },
                    { text: "你當剛強壯膽！不要懼怕，也不要驚惶。", ref: "約書亞記 1:9" },
                    { text: "我的恩典夠你用的，因為我的能力是在人的軟弱上顯得完全。", ref: "哥林多後書 12:9" },
                    { text: "耶和華必在你前面行；他必與你同在，必不撇下你。", ref: "申命記 31:8" },
                    { text: "你們要將一切的憂慮卸給神，因為他顧念你們。", ref: "彼得前書 5:7" },
                    { text: "神是我們的避難所，是我們的力量，是我們在患難中隨時的幫助。", ref: "詩篇 46:1" },
                    { text: "耶和華靠近傷心的人，拯救靈性痛悔的人。", ref: "詩篇 34:18" },
                    { text: "你要把你的重擔卸給耶和華，他必撫養你。", ref: "詩篇 55:22" },
                    { text: "凡勞苦擔重擔的人可以到我這裡來，我就使你們得安息。", ref: "馬太福音 11:28" },
                    { text: "在神沒有難成的事。", ref: "路加福音 1:37" }
                ],
                supportive: [
                    { text: "你們中間若有缺少智慧的，應當求那厚賜與眾人、也不斥責人的神。", ref: "雅各書 1:5" },
                    { text: "你要專心仰賴耶和華，不可倚靠自己的聰明。", ref: "箴言 3:5" },
                    { text: "你的話是我腳前的燈，是我路上的光。", ref: "詩篇 119:105" },
                    { text: "敬畏耶和華是智慧的開端；認識至聖者便是聰明。", ref: "箴言 9:10" },
                    { text: "我心裡存記你的話，免得我得罪你。", ref: "詩篇 119:11" },
                    { text: "聖經都是神所默示的，於教訓、督責、使人歸正、教導人學義都是有益的。", ref: "提摩太後書 3:16" },
                    { text: "信道是從聽道來的，聽道是從基督的話來的。", ref: "羅馬書 10:17" },
                    { text: "草必枯乾，花必凋殘，惟有我們神的話必永遠立定。", ref: "以賽亞書 40:8" },
                    { text: "天地要廢去，我的話卻不能廢去。", ref: "馬太福音 24:35" },
                    { text: "人活著，不是單靠食物，乃是靠神口裡所出的一切話。", ref: "馬太福音 4:4" }
                ]
            };

            // 5) 依 accuracy 計算等級（只用於後備池與微弱偏好）
            let tier = 'supportive';
            if (accuracy >= 90) tier = 'excellent';
            else if (accuracy >= 70) tier = 'good';
            else if (accuracy >= 50) tier = 'encouraging';

            // 6) 主要路徑：從外部經文庫挑選符合「安慰、勸勉、造就、鼓勵」原則的經文
            // 從資料庫挑選鼓勵/積極向上的經文候選
            // Pick affirmative/encouraging verses from DB
            function pickPositiveFromDB() {
                try {
                    const db = getActiveVerseDB();
                    if (!Array.isArray(db) || db.length === 0) return null;

                    // 主題關鍵詞分類（安慰/勸勉/造就/鼓勵）
                    const THEMES = {
                        comfort: ['安慰','撫慰','醫治','醫治你','拯救我','倚靠','信靠','保守','平安','安息','避難所','靠主','靠着主','扶持','幫助','同在','不撇下','不丟棄','不離開'],
                        exhort: ['勸勉','勉勵','勸戒','警醒','持守','忍耐','自守','彼此相愛','彼此勸慰','行善','行事為人','要追求','要學','要遠避','不可懼怕','不可停止','要謹守'],
                        edify: ['造就','建造','堅固','成全','教導','教訓','智慧','真理','公義','敬虔','學義','成長','成聖','得著','得以','使你們','使我們'],
                        encourage: ['鼓勵','剛強','勇敢','壯膽','喜樂','盼望','得力','加添力量','歡呼','高興','放心','振作','不灰心','不喪膽','得勝']
                    };
                    const NEGATIVE = ['怒','發怒','懲罰','刑罰','鞭','咒詛','滅','審判','仇','仇敵','報應','毀滅','殺','砍','擊打','咒','哀號','災','災禍','有禍了','咒詛','咒罵'];

                    // 根據表現偏好主題：低分偏向安慰/鼓勵；高分偏向勸勉/造就
                    let preferredThemes = ['comfort','encourage','exhort','edify'];
                    if (accuracy >= 70) preferredThemes = ['exhort','edify','encourage','comfort'];

                    const pool = db.slice();

                    // 粗略主題分類（感恩/盼望/得勝…）
                    // Coarse theme classification from text
                    function classifyThemes(text) {
                        if (!text || typeof text !== 'string') return [];
                        const t = [];
                        const hasNeg = NEGATIVE.some(k => text.includes(k));
                        if (hasNeg) return t;
                        for (const [key, words] of Object.entries(THEMES)) {
                            if (words.some(w => text.includes(w))) t.push(key);
                        }
                        return t;
                    }

                    // 候選：需命中任一主題，且非負面；同時優先短句可讀性
                    let candidates = pool.filter(v => Array.isArray(v) ? false : true)
                        .map(v => ({ rec: v, themes: classifyThemes(v.verse) }))
                        .filter(x => x.themes.length > 0);

                    if (!candidates.length) return null;

                    // 分 rarity：常見 > 冷門（對結語可讀性友善）
                    function byRarity(list, r) { return list.filter(x => x.rec.rarity === r); }
                    let cCommon = byRarity(candidates, 'common');
                    let cRare = byRarity(candidates, 'rare');

                    // 偏好同範圍書卷
                    // 優先當前允許書卷；不足再放寬
                    // Prefer allowed-books first; relax if needed
                    function preferAllowed(arr) {
                        return [...arr].sort((a,b) => {
                            const aIn = allowedBooks.includes(a.rec.book) ? 1 : 0;
                            const bIn = allowedBooks.includes(b.rec.book) ? 1 : 0;
                            if (bIn !== aIn) return bIn - aIn;
                            // 其次偏好較短的經文（更適合結語顯示）
                            const al = (a.rec.verse || '').length;
                            const bl = (b.rec.verse || '').length;
                            return al - bl;
                        });
                    }
                    cCommon = preferAllowed(cCommon);
                    cRare = preferAllowed(cRare);

                    // 依主題偏好重新過濾排序
                    // 主題評分（多維度加總）
                    // Compute a weighted theme score
                    function themeScore(themes) {
                        // 高權重給首選主題（index 越小越優先）
                        let score = 0;
                        for (const t of themes) {
                            const idx = preferredThemes.indexOf(t);
                            if (idx >= 0) score += (10 - idx * 3);
                        }
                        return score;
                    }

                    // 根據得分與隨機性挑一條
                    // Pick one entry with score and randomness
                    function pickFrom(arr) {
                        if (!arr.length) return null;
                        // 去除近期重複
                        const nonRepeat = arr.filter(x => !recentHistory.includes(`${x.rec.book} ${x.rec.chapter}`));
                        const base = nonRepeat.length ? nonRepeat : arr;
                        // 按主題分數降序、長度升序
                        const sorted = [...base].sort((a,b) => {
                            const ts = themeScore(b.themes) - themeScore(a.themes);
                            if (ts !== 0) return ts;
                            const al = (a.rec.verse || '').length;
                            const bl = (b.rec.verse || '').length;
                            return al - bl;
                        });
                        return sorted[0];
                    }

                    const picked = pickFrom(cCommon) || pickFrom(cRare);
                    if (!picked) return null;

                    const v = picked.rec;
                    return { text: v.verse, ref: `${v.book} ${v.chapter}` };
                } catch (e) { return null; }
            }

            // 7) 後備路徑：精選池（依等級），同樣先避近期重複、偏好本局書卷
            // 使用內建精選池（依正確率分類）
            // Select from curated verse pools by accuracy
            function pickFromCurated() {
                const raw = pools[tier] || [];
                if (!raw.length) return null;
                const preferred = raw.filter(v => {
                    const p = parseRef(v.ref);
                    const inBook = !p || !p.book ? true : allowedBooks.includes(p.book);
                    const notRecent = !recentHistory.includes(v.ref);
                    return inBook && notRecent;
                });
                const nonRecent = preferred.length ? preferred : raw.filter(v => !recentHistory.includes(v.ref));
                const poolToUse = nonRecent.length ? nonRecent : raw;
                return poolToUse[Math.floor(Math.random() * poolToUse.length)];
            }

            let selected = pickPositiveFromDB() || pickFromCurated();
            if (!selected) {
                // safety fallback：任取 supportive 原始精選
                const raw = pools[tier] || pools.supportive;
                selected = raw[Math.floor(Math.random() * raw.length)];
            }

            const verse = selected.text;
            const reference = selected.ref;
            applyClosingVerse(verse, reference, true);
            try { pushHistory(reference); } catch (e) {}
        }

    // 確認玩家名稱並嘗試寫入排行榜；同時顯示結算與按鈕
    // Confirm player name and attempt to save to leaderboard
    function confirmPlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const nameError = document.getElementById('nameError');
            const playerName = nameInput.value.trim();
            const leaderboardMessage = document.getElementById('leaderboardMessage');
            
            // 如果 modal 是檢視模式（從首頁點開），不應該允許更改名稱或再次儲存
            const modal = document.getElementById('playerNameModal');
            if (modal && modal.dataset.viewingRecord === 'true') {
                // 檢視模式：不儲存，關閉前讀取要還原的難度
                const viewingDifficulty = modal.dataset.viewingDifficulty || gameState.difficulty;
                // 清除檢視旗標（稍後還原 tab）
                modal.dataset.viewingRecord = '';
                modal.dataset.viewingDifficulty = '';
                // 關閉視窗並還原 name input 顯示
                const modalElView = document.getElementById('playerNameModal');
                if (modalElView) {
                    try { detachPlayerNameModalEnterHotkey(); } catch (e) {}
                    modalElView.classList.add('hidden');
                    try { unlockBodyScroll(); } catch(e) {}
                }
                const nameInputSectionElView = document.getElementById('nameInputSection');
                if (nameInputSectionElView) nameInputSectionElView.classList.remove('hidden');
                // 返回主畫面並更新排行榜顯示為原先檢視的難度
                showStartScreen();
                updateLeaderboardDisplay(viewingDifficulty || gameState.difficulty);
                return;
            } else {
                // 如果進入排行榜，需要驗證玩家名稱並儲存
                if (!leaderboardMessage.classList.contains('hidden')) {
                    if (!validatePlayerName(playerName)) {
                        return;
                    }
                    // 保存到排行榜：若為同題重玩，是否儲存取決於 SUPABASE_CONFIG.allowReplaySaves（預設不儲存）
                    const allowReplaySaves = !!(window.SUPABASE_CONFIG && window.SUPABASE_CONFIG.allowReplaySaves);
                    try { localStorage.setItem('lastPlayerName', playerName || ''); } catch(_) {}
                    const isReplayRun = !!gameState.skipLeaderboardOnComplete;
                    const skipSave = isReplayRun && !allowReplaySaves; // 同題重玩且未開啟儲存 -> 跳過
                    // 若是同題重玩且允許儲存，將模式覆蓋為 'replay' 以利後續辨識
                    const modeOverride = (isReplayRun && allowReplaySaves) ? 'replay' : undefined;
                    savePlayerToLeaderboard(playerName, { skipSave, modeOverride });
                    // 使用完後重置旗標（重玩流程專用）
                    gameState.skipLeaderboardOnComplete = false;
                }
            }
            
            // 關閉視窗並還原 name input 顯示
            // 非檢視模式走到這裡（正常儲存/關閉）
            const modalEl = document.getElementById('playerNameModal');
            if (modalEl) {
                try { detachPlayerNameModalEnterHotkey(); } catch (e) {}
                modalEl.classList.add('hidden');
                // ensure background scrolling is restored on mobile
                try { unlockBodyScroll(); } catch(e) {}
                // 清除可能的檢視旗標與記錄的難度
                modalEl.dataset.viewingRecord = '';
                modalEl.dataset.viewingDifficulty = '';
            }
            const nameInputSectionEl = document.getElementById('nameInputSection');
            if (nameInputSectionEl) nameInputSectionEl.classList.remove('hidden');
            
            // 返回主畫面並更新排行榜顯示
            showStartScreen();
            // 僅在遊戲結束的結算流程關閉後才切換排行榜標籤至本局難度
            if (gameState && gameState.gameCompleted) {
                try {
                    // 更新顯示內容
                    updateLeaderboardDisplay(gameState.difficulty);
                    // 同步高亮對應標籤（依難度色系著色）
                    try { setActiveLeaderboardTabByDifficulty(gameState.difficulty); } catch(_) {}
                } catch(_) { updateLeaderboardDisplay(); }
            } else {
                updateLeaderboardDisplay();
            }
        }

    // 驗證玩家名稱（空白/長度/字元）
    // Validate player name inputs
    function validatePlayerName(name) {
            const nameError = document.getElementById('nameError');
            
            // 允許留空（將顯示為匿名）
            if (!name) {
                nameError.classList.add('hidden');
                return true;
            }
            
            // 檢查長度
            if (name.length < 2) {
                nameError.textContent = '名稱至少需要2個字';
                nameError.classList.remove('hidden');
                return false;
            }
            
            if (name.length > 10) {
                nameError.textContent = '名稱不能超過10個字';
                nameError.classList.remove('hidden');
                return false;
            }
            
            // 檢查是否只包含中英文
            const validPattern = /^[a-zA-Z\u4e00-\u9fa5]+$/;
            if (!validPattern.test(name)) {
                nameError.textContent = '只能輸入中文或英文';
                nameError.classList.remove('hidden');
                return false;
            }
            
            // 簡單的不雅文字檢查
            const inappropriateWords = ['笨蛋', '白痴', '傻瓜', 'stupid', 'idiot', 'fool'];
            const lowerName = name.toLowerCase();
            for (let word of inappropriateWords) {
                if (lowerName.includes(word)) {
                    nameError.textContent = '請使用適當的名稱';
                    nameError.classList.remove('hidden');
                    return false;
                }
            }
            
            nameError.classList.add('hidden');
            return true;
        }

        // savePlayerToLeaderboard(playerName, options)
    // options = { skipSave?: boolean, modeOverride?: 'ranking'|'practice'|'replay' }
    // 將紀錄寫入排行榜（線上或本機 fallback）
    // Persist record to leaderboard (online or local fallback)
    function savePlayerToLeaderboard(playerName, options = {}) {
            // 只有完成遊戲才能進入排行榜
            if (!gameState.gameCompleted && !options.allowIncomplete) {
                return;
            }
            console.log('[LEADERBOARD] savePlayerToLeaderboard called', { playerName, options, gameCompleted: gameState.gameCompleted, skipLeaderboardOnComplete: gameState.skipLeaderboardOnComplete });
            
            // If online adapter exists, delegate the persistence; otherwise use localStorage
            let allLeaderboards = null;
            if (!(window.Leaderboard && typeof window.Leaderboard.save === 'function')) {
                allLeaderboards = JSON.parse(localStorage.getItem('bibleGameLeaderboard') || '{}');
                if (!allLeaderboards.easy) allLeaderboards.easy = [];
                if (!allLeaderboards.normal) allLeaderboards.normal = [];
                if (!allLeaderboards.hard) allLeaderboards.hard = [];
            }
            
            // 計算遊戲耗時
            const gameTime = gameState.gameStartTime ? Math.floor((Date.now() - gameState.gameStartTime) / 1000) : 0;
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // 處理玩家名稱，留空則顯示為匿名
            const finalPlayerName = playerName.trim() || '匿名';
            
            // 創建遊戲記錄（包含快照）
            const gameRecord = {
                id: Date.now(),
                playerName: finalPlayerName,
                score: gameState.score,
                difficulty: gameState.difficulty,
                date: new Date().toLocaleDateString('zh-TW'),
                time: timeString,
                completed: gameState.gameCompleted,
                correctAnswers: gameState.totalCorrectAnswers,
                totalQuestions: gameState.totalQuestions,
                totalMistakes: gameState.totalMistakes,
                levelResults: { ...gameState.levelResults },
                range: gameState.range,
                rarity: gameState.rarity || null,
                // 若提供覆蓋，優先使用；否則依是否為排名模式（有設定罕見度）判定
                mode: (options && options.modeOverride) ? options.modeOverride : (gameState.rarity ? 'ranking' : 'practice'),
                testament: gameState.testament,
                customBooks: [...gameState.customBooks],
                // persist hint/time related transient fields so record view can exactly reproduce breakdown
                hintsRemaining: gameState.hintsRemaining != null ? gameState.hintsRemaining : null,
                // totalHints is derived from difficulty; store it for exact replay
                totalHints: (function(){ const hintCounts = { easy: 3, normal: 3, hard: 3 }; return hintCounts[gameState.difficulty] || null; })(),
                // store whether time reward was shown and explicit numeric timeReward if available
                showTimeReward: gameState.showTimeReward === true,
                timeReward: (typeof gameState.timeReward === 'number') ? gameState.timeReward : null,
                // small helper: store usedHints count to help diagnostics
                usedHintsCount: (gameState.usedHints ? gameState.usedHints.size : 0),
                // persist chosen closing verse so record view uses the same verse as game end
                closingVerse: gameState.closingVerse || null,
                closingVerseRef: gameState.closingVerseRef || null,
                questionSnapshot: (function(){ try { return JSON.parse(JSON.stringify(gameState.questionData || [])); } catch(e){ return null; } })()
            };
            
            // 若選擇跳過儲存（例如同樣題目再來一局），則不寫入排行榜
            if (options.skipSave) {
                console.log('[LEADERBOARD] options.skipSave true - not persisting record for replay run');
                return;
            }

            // Online or local save
            if (window.Leaderboard && typeof window.Leaderboard.save === 'function') {
                try {
                    window.Leaderboard.save(gameRecord).then(() => updateLeaderboardDisplay(gameState.difficulty)).catch(err => {
                        console.warn('Online leaderboard save failed; falling back to local', err);
                        try {
                            let fallback = JSON.parse(localStorage.getItem('bibleGameLeaderboard') || '{}');
                            if (!fallback.easy) fallback.easy = [];
                            if (!fallback.normal) fallback.normal = [];
                            if (!fallback.hard) fallback.hard = [];
                            fallback[gameState.difficulty].push(gameRecord);
                            fallback[gameState.difficulty].sort((a,b)=>(b.score||0)-(a.score||0));
                            fallback[gameState.difficulty] = fallback[gameState.difficulty].slice(0,5);
                            localStorage.setItem('bibleGameLeaderboard', JSON.stringify(fallback));
                            updateLeaderboardDisplay(gameState.difficulty);
                        } catch(e) {}
                    });
                } catch (e) {
                    console.warn('Online leaderboard save threw; fallback to local', e);
                }
                return;
            }

            // Local save path
            allLeaderboards[gameState.difficulty].push(gameRecord);
            allLeaderboards[gameState.difficulty].sort((a, b) => (b.score || 0) - (a.score || 0));
            allLeaderboards[gameState.difficulty] = allLeaderboards[gameState.difficulty].slice(0, 5);
            localStorage.setItem('bibleGameLeaderboard', JSON.stringify(allLeaderboards));
        }



    // 中央分數的數字跳動動畫（支援中斷/重新開始）
    // Animate center score counting from A to B
    function animateScoreWithCounting(fromScore, toScore) {
            const scoreElement = document.getElementById('centerScore');
            const difference = toScore - fromScore;
            
            if (difference === 0) return;
            // 先取消先前尚未結束的計數動畫，避免重疊
            try {
                if (scoreElement && scoreElement.__countingInterval) {
                    clearInterval(scoreElement.__countingInterval);
                    scoreElement.__countingInterval = null;
                }
            } catch (e) {}

            // 若使用者偏好減少動態，直接跳到目標值並做極短促的視覺提示
            if (getReducedMotion()) {
                scoreElement.textContent = toScore;
                scoreElement.classList.add('counting-animation');
                setTimeout(() => scoreElement.classList.remove('counting-animation'), 40);
                return;
            }

            // 更積極的快速動畫：縮短總時長並限制更新次數以獲得更快響應
            const totalDurationMs = 900; // 動畫總時長（毫秒）—加倍
            const maxSteps = 40; // 限制步數以更快完成

            let absDiff = Math.abs(difference);
            let steps = Math.min(absDiff, maxSteps);
            if (steps <= 0) steps = 1;

            // 每一步的數值變化（向上或向下取整，確保不會無限循環）
            const rawStep = difference / steps;
            const stepValue = rawStep > 0 ? Math.ceil(rawStep) : Math.floor(rawStep);

            // 更短的單步延遲以達到快速完成
            const stepDuration = Math.max(8, Math.floor(totalDurationMs / steps));

            let currentValue = fromScore;
            let stepCount = 0;

            const countingInterval = setInterval(() => {
                currentValue += stepValue;
                stepCount++;

                // 防止超越目標：若越界則直接設為目標並結束
                if ((stepValue > 0 && currentValue >= toScore) || (stepValue < 0 && currentValue <= toScore) || stepCount >= steps) {
                    clearInterval(countingInterval);
                    scoreElement.textContent = toScore;
                    scoreElement.classList.add('counting-animation');
                    setTimeout(() => scoreElement.classList.remove('counting-animation'), 60);
                    return;
                }

                scoreElement.textContent = currentValue;
                scoreElement.classList.add('counting-animation');

                setTimeout(() => {
                    scoreElement.classList.remove('counting-animation');
                }, 40);
            }, stepDuration);
            // 記錄 interval 以便下一次更新能夠中止
            try { scoreElement.__countingInterval = countingInterval; } catch (e) {}
        }

        // spawn lightweight particles near the center score; intensity scales with magnitude
    // 分數微粒特效：依分數幅度與選項決定數量、顏色、距離（尊重減少動態偏好）
    // Score particles: spawn lightweight glyphs near a center or origin; honors reduced motion.
    // 分數粒子特效：由某個元素或視窗中心綻放
    // Spawn particle effects near origin or viewport center
    function spawnScoreParticles(delta, originRect, options) {
            // clamp particle count; user requested doubling the previous counts
            const abs = Math.abs(delta);
            let count = 2; // base doubled
            if (abs >= 300) count = 16; // was 8 -> doubled
            else if (abs >= 150) count = 12; // was 6
            else if (abs >= 60) count = 8; // was 4
            else if (abs >= 20) count = 6; // was 3

            // 減少動態：顯著降低數量與距離
            const reduced = getReducedMotion();
            if (reduced) {
                count = Math.min(count, 4);
            }
            // explicit count override
            if (options && typeof options.count === 'number') {
                try { count = Math.max(1, Math.floor(options.count)); } catch(_) { /* ignore */ }
            }

            // white -> platinum/gold palette (defaults)
            const positiveColors = ['#ffffff', '#fff7e6', '#fff3b0', '#ffefc4'];
            const negativeColors = ['#ffffff', '#fff7e6', '#fff3b0']; // keep white present for negative as well
            const overrideColors = options && Array.isArray(options.colors) && options.colors.length ? options.colors : null;

            const center = originRect || (function(){ const el = document.getElementById('centerScore'); try { return el.getBoundingClientRect(); } catch(e){ return null; } })();
            const cx = center ? Math.round(center.left + center.width / 2) : Math.round(window.innerWidth / 2);
            const cy = center ? Math.round(center.top + center.height / 2) : Math.round(window.innerHeight / 2);

            const customZ = options && typeof options.zIndex === 'number' ? options.zIndex : null;
            const customDur = options && typeof options.durationMs === 'number' ? Math.max(200, Math.floor(options.durationMs)) : null;
            const glyph = options && typeof options.glyph === 'string' ? options.glyph : null;
            const customOpacity = options && typeof options.opacity === 'number' ? Math.max(0, Math.min(1, options.opacity)) : null;
            const sizeMinOpt = (options && typeof options.sizeMin === 'number') ? options.sizeMin : null;
            const sizeMaxOpt = (options && typeof options.sizeMax === 'number') ? options.sizeMax : null;
            const distMinOpt = (options && typeof options.distanceMin === 'number') ? options.distanceMin : null;
            const distMaxOpt = (options && typeof options.distanceMax === 'number') ? options.distanceMax : null;
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'score-particle';
                // use a small star/flash glyph instead of a solid circle
                p.textContent = glyph || '✦';
                let size;
                if (sizeMinOpt != null && sizeMaxOpt != null) {
                    const minS = Math.max(1, sizeMinOpt);
                    const maxS = Math.max(minS, sizeMaxOpt);
                    size = Math.round(minS + Math.random() * (maxS - minS));
                } else {
                    size = 10 + Math.round(Math.random() * 12) + Math.min(26, Math.floor(Math.abs(delta) / 30));
                }
                p.style.fontSize = size + 'px';
                p.style.width = (size + 4) + 'px';
                p.style.height = (size + 4) + 'px';
                p.style.display = 'inline-flex';
                p.style.alignItems = 'center';
                p.style.justifyContent = 'center';

                // choose color from platinum/gold family
                const colors = overrideColors || (delta >= 0 ? positiveColors : negativeColors);
                p.style.color = colors[Math.floor(Math.random() * colors.length)];
                // transparent background to allow glyph only appearance
                p.style.background = 'transparent';

                // random direction spread; allow shorter travel via options
                const angle = Math.random() * Math.PI * 2;
                let distance;
                if (distMinOpt != null && distMaxOpt != null) {
                    let minD = Math.max(0, distMinOpt);
                    let maxD = Math.max(minD, distMaxOpt);
                    if (reduced) { minD *= 0.5; maxD *= 0.5; }
                    distance = minD + Math.random() * (maxD - minD);
                } else {
                    distance = reduced ? (8 + Math.random() * 16) : ((26 + Math.random() * 40) * 2); // reduced-motion: shorter
                }
                const dx = Math.round(Math.cos(angle) * distance) + 'px';
                const dy = Math.round(Math.sin(angle) * distance) + 'px';
                p.style.setProperty('--dx', dx);
                p.style.setProperty('--dy', dy);

                p.style.left = (cx - (size + 4) / 2) + 'px';
                p.style.top = (cy - (size + 4) / 2) + 'px';

                document.body.appendChild(p);
                if (customZ != null) { try { p.style.zIndex = String(customZ); } catch(_) {} }
                if (customOpacity != null) { try { p.style.opacity = String(customOpacity); } catch(_) {} }
                if (customDur != null) { try { p.style.animationDuration = `${customDur}ms`; } catch(_) {} }
                // remove after animation（reduced-motion: 更快清理）
                const life = customDur != null ? customDur : (reduced ? 600 : 1500);
                setTimeout(() => { try { if (p.parentElement) p.parentElement.removeChild(p); } catch(e) {} }, life);
            }
        }

        // Unique start button effect: concentric aurora rings + themed particles
    // 開始按鈕特效：同心環光暈 + 粉紫粒子；在減少動態時改為短暫高光
    // Start button burst: aurora rings + violet/pink particles; reduced-motion -> brief glow only.
    // 開始按鈕點擊時的微小特效
    // Subtle burst when Start is clicked
    function triggerStartButtonBurst(originRect) {
            try {
                const reduced = getReducedMotion && getReducedMotion();
                const rect = originRect || (function(){ const el = document.getElementById('startGameBtn'); try { return el.getBoundingClientRect(); } catch(e){ return null; } })();
                const cx = rect ? Math.round(rect.left + rect.width / 2) : Math.round(window.innerWidth / 2);
                const cy = rect ? Math.round(rect.top + rect.height / 2) : Math.round(window.innerHeight / 2);

                // Reduced motion: brief accessible glow on the button only
                if (reduced) {
                    const btn = document.getElementById('startGameBtn');
                    if (btn) {
                        const prev = { boxShadow: btn.style.boxShadow, border: btn.style.border };
                        btn.style.boxShadow = '0 0 0 4px rgba(168,85,247,0.5), 0 0 16px rgba(236,72,153,0.6)';
                        btn.style.border = '3px solid rgba(236,72,153,0.9)';
                        setTimeout(() => { try { btn.style.boxShadow = prev.boxShadow || ''; btn.style.border = prev.border || ''; } catch(_) {} }, 260);
                    }
                    return;
                }

                const ringColors = ['#A78BFA', '#C084FC', '#EC4899', '#F472B6']; // violet/pink family
                const ringCount = 3;
                const baseSize = 24; // px
                const stagger = 70;   // ms

                for (let i = 0; i < ringCount; i++) {
                    const ring = document.createElement('div');
                    const size = baseSize + i * 8;
                    ring.style.position = 'fixed';
                    ring.style.left = (cx - size / 2) + 'px';
                    ring.style.top = (cy - size / 2) + 'px';
                    ring.style.width = size + 'px';
                    ring.style.height = size + 'px';
                    ring.style.borderRadius = '50%';
                    const col = ringColors[i % ringColors.length];
                    ring.style.border = '3px solid ' + col;
                    ring.style.boxShadow = `0 0 24px ${col}80, inset 0 0 12px ${col}40`;
                    ring.style.opacity = '0.95';
                    ring.style.transform = 'scale(0.25)';
                    ring.style.transition = 'transform 720ms cubic-bezier(.2,.9,.2,1), opacity 720ms linear';
                    ring.style.zIndex = '40'; // render below countdown overlay (z-50)
                    document.body.appendChild(ring);
                    // animate out
                    setTimeout(() => {
                        try { ring.style.transform = 'scale(2.8)'; ring.style.opacity = '0'; } catch(_) {}
                    }, 16 + i * stagger);
                    setTimeout(() => { try { if (ring.parentElement) ring.parentElement.removeChild(ring); } catch(_) {} }, 820 + i * stagger);
                }

                // matching particle flare in violet/pink palette, also below overlay
                try { spawnScoreParticles(120, rect, { colors: ['#FFFFFF','#F5D0FE','#E879F9','#C084FC','#A78BFA','#F472B6','#EC4899'], zIndex: 40 }); } catch(_) {}
            } catch (_) { /* ignore visual errors */ }
        }

        // Animate a numeric span inline from a start to end value with optional sign prefix
    // 行內數字跳動動畫：將文字中的數值從起點平滑數到終點，支援 +/- 前綴
    // Animate a numeric span inline from start to end with easing and optional sign prefix.
    // 行內小數字計數器（用於明細動畫、加分浮標）
    // Inline number animator for breakdown and popups
    function animateInlineNumber(spanEl, fromVal, toVal, durationMs, signPrefix = '') {
            try {
                if (!spanEl) return () => {};
                if (getReducedMotion && getReducedMotion()) {
                    spanEl.textContent = `${signPrefix}${toVal}`;
                    return () => {};
                }
                const start = performance.now();
                let rafId = 0;
                const run = (now) => {
            const t = Math.max(0, Math.min(1, (now - start) / Math.max(1, durationMs)));
                    const eased = 1 - Math.pow(1 - t, 3);
                    const cur = Math.round(fromVal + (toVal - fromVal) * eased);
                    spanEl.textContent = `${signPrefix}${cur}`;
                    if (t < 1) {
                        rafId = requestAnimationFrame(run);
                    }
                };
                rafId = requestAnimationFrame(run);
                return () => { try { if (rafId) cancelAnimationFrame(rafId); } catch(_) {} };
            } catch (_) {
                return () => {};
            }
        }

        // Wrap numeric portion of floating text and apply inline counting
    // 將浮動分數文字中的數值切出並套用行內跳動（行動裝置可強制啟用以提升感受）
    // Apply inline counting to the numeric part of a floating score text; can force on mobile.
    // 對加分浮標套用行內數字動畫（避免重算中心分數）
    // Apply inline counting to floating score popups
    function applyInlineCountToFloating(containerEl, displayText) {
            try {
                if (!containerEl || typeof displayText !== 'string') return;
                const m = displayText.match(/^(.*?)([+\-]?\d+)(.*)$/);
                if (!m) return;
                const before = m[1] || '';
                const numStr = m[2] || '';
                const after = m[3] || '';
        const sign = numStr.startsWith('-') ? '-' : (numStr.startsWith('+') ? '+' : '');
        const target = Math.abs(parseInt(numStr.replace(/[+\-]/g, ''), 10) || 0);

                containerEl.innerHTML = '';
                if (before) containerEl.appendChild(document.createTextNode(before));
                const numSpan = document.createElement('span');
                numSpan.className = 'inline-count-num';
                numSpan.style.display = 'inline-block';
                numSpan.textContent = `${sign}0`;
                containerEl.appendChild(numSpan);
                if (after) containerEl.appendChild(document.createTextNode(after));

                // negative should count downwards visually: -0 -> -target
                const fromVal = 0;
                const toVal = target;
                // Allow a forced inline counting (used by mobile special popups)
                const force = containerEl && containerEl.dataset && containerEl.dataset.forceInlineCount === 'true';
                if (force && typeof window.getReducedMotion === 'function') {
                    const original = window.getReducedMotion;
                    try { window.getReducedMotion = () => false; } catch(_) {}
                    const cancel = animateInlineNumber(numSpan, fromVal, toVal, 720, sign);
                    containerEl.__cancelInline = () => { try { cancel(); } catch(_) {}; try { window.getReducedMotion = original; } catch(_) {} };
                } else {
                    const cancel = animateInlineNumber(numSpan, fromVal, toVal, 720, sign); // 加倍
                    containerEl.__cancelInline = cancel;
                }
            } catch (_) { /* ignore */ }
        }

        // pulse the large center score element; scale intensity based on delta
    // 中央金色分數脈衝：依分數幅度改變放大倍率與陰影，短暫顯示後還原
    // Pulse the big center score; scale intensity by delta and then reset.
    // 讓中央分數微微脈衝發光（不改變分數）
    // Pulse-glow the center score element
    function pulseCenterScore(delta) {
            const el = document.getElementById('centerScore');
            if (!el) return;
            // magnitude mapping: map delta to scale multiplier
            const abs = Math.min(1000, Math.abs(delta));
            let scale = 1.06; // default small pop
            if (abs >= 300) scale = 1.28;
            else if (abs >= 150) scale = 1.20;
            else if (abs >= 60) scale = 1.12;
            else if (abs >= 20) scale = 1.08;

            // apply transform with a short ease-out
            el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1)';
            el.style.transformOrigin = 'center center';
            el.style.transform = `scale(${scale})`;
            // subtle shadow/enhance for positive deltas
            if (delta > 0) {
                el.style.textShadow = '0 4px 18px rgba(255,255,255,0.9), 0 0 40px rgba(255, 255, 220, 0.6)';
            }
            // revert back
            setTimeout(() => {
                try { el.style.transform = ''; el.style.transition = ''; el.style.textShadow = ''; } catch(e) {}
            }, 380);
        }

        // Spawn a vertical confetti rain of colorful ribbons; intensity scales with magnitude
    // 彩帶雨：以多色小長方飄落，數量隨分數而變；減少動態時降低數量與壽命
    // Confetti rain: colorful ribbons falling; intensity scales with delta; throttled for reduced motion.
    // 五彩紙花下落效果（慶祝）
    // Spawn confetti rain for celebration
    function spawnConfettiRain(delta, originRect) {
            try {
                const abs = Math.abs(delta || 100);
                // determine count: scaled but capped
                let base = 10;
                if (abs >= 300) base = 40;
                else if (abs >= 150) base = 30;
                else if (abs >= 60) base = 20;
                else if (abs >= 20) base = 14;
                let count = Math.min(80, base);

                // 減少動態：大幅降低數量
                if (getReducedMotion()) {
                    count = Math.min(count, 12);
                }

                const colors = ['#EF4444','#F97316','#F59E0B','#10B981','#3B82F6','#8B5CF6','#EC4899'];

                // spawn area: above the viewport or near originRect center
                const spawnCenter = originRect ? Math.round(originRect.left + originRect.width/2) : Math.round(window.innerWidth/2);
                const startY = -20; // start slightly above

                for (let i = 0; i < count; i++) {
                    const el = document.createElement('div');
                    el.className = 'confetti-piece';
                    el.style.background = colors[Math.floor(Math.random()*colors.length)];
                    // vary size and horizontal offset
                    const w = 6 + Math.floor(Math.random()*12);
                    const h = Math.max(10, w + Math.floor(Math.random()*8));
                    el.style.width = w + 'px';
                    el.style.height = h + 'px';
                    // make horizontal spread wider for lower-intensity celebrations (e.g. +100)
                    const spreadFactor = (abs <= 100) ? 0.6 : 0.45; // wider spread for small delta bursts
                    const spread = Math.round(window.innerWidth * spreadFactor);
                    const leftBase = spawnCenter - Math.round(spread / 2);
                    const left = leftBase + Math.floor(Math.random() * spread) + Math.floor((Math.random() - 0.5) * 120);
                    el.style.left = (Math.max(6, Math.min(window.innerWidth - 6, left))) + 'px';
                    el.style.top = startY + 'px';
                    // random horizontal drift applied via CSS variable
                    const drift = Math.round((Math.random()*200) - 100) + 'px';
                    el.style.setProperty('--conf-x', drift);
                    el.style.opacity = '1';
                    el.style.transform = `translateY(0)`;
                    el.style.borderRadius = (Math.random() > 0.6 ? '2px' : '6px');
                    document.body.appendChild(el);

                    // stagger removal slightly after animation end（reduced-motion: 縮短生命週期）
                    const life = getReducedMotion() ? 2800 + Math.floor(Math.random()*600) : 6400 + Math.floor(Math.random()*1600);
                    setTimeout(() => { try { if (el.parentElement) el.parentElement.removeChild(el); } catch(e) {} }, life);
                }
            } catch (e) { /* ignore visual errors */ }
        }

        // Spawn gold glitter particles: small shimmering glyphs that drift down slowly; can be continuous for a short duration
    // 金色流光：小星星緩慢下降，可持續一段時間並逐步減量；支援指定來源區域
    // Gold glitter: shimmering stars drifting down; can run continuously with tapering rate.
    // 金色亮粉閃爍（慶祝）
    // Spawn golden glitter sparkles
    function spawnGoldGlitter(intensity, originRect) {
            try {
                // Tapering glitter shower: run for up to 20s, spawn frequently at start and gradually reduce
        const abs = Math.abs(intensity || 300);
        const reduced = getReducedMotion();
        const totalDuration = reduced ? 6000 : 20000; // reduced-motion: shorter overall
                const startTime = Date.now();
        const maxTotal = reduced ? 80 : 400; // safety cap

                // initial and final parameters (will interpolate over time)
        const initialInterval = reduced ? 300 : 120; // ms between ticks at start
        const finalInterval = reduced ? 900 : 1200; // ms between ticks at end
        const initialGroup = reduced ? 3 : Math.min(10, Math.max(4, Math.floor((abs/50))));
        const finalGroup = 1;

                let spawned = 0;

                const spawnTick = () => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed > totalDuration || spawned >= maxTotal) return;
                    const t = Math.min(1, elapsed / totalDuration);

                    // linear interpolation helper
                    const lerp = (a,b,p) => Math.round(a + (b-a)*p);

                    const interval = lerp(initialInterval, finalInterval, t);
                    const group = Math.max(finalGroup, lerp(initialGroup, finalGroup, t));

                    // spawn 'group' stars this tick
                    for (let i = 0; i < group && spawned < maxTotal; i++) {
                        const g = document.createElement('div');
                        g.className = 'gold-glitter';
                        g.textContent = '✦'; // use a star glyph

                        // spawn across a wide horizontal area; prefer originRect center if provided
                        const spawnCenterX = originRect ? Math.round(originRect.left + originRect.width/2) : Math.round(window.innerWidth/2);
                        const spread = Math.round(window.innerWidth * 0.7); // wide spread across the sky
                        const leftBase = spawnCenterX - Math.round(spread/2);
                        const left = leftBase + Math.floor(Math.random() * spread) + Math.floor((Math.random() - 0.5) * 200);
                        const clampedLeft = Math.max(6, Math.min(window.innerWidth-6, left));

                        const spawnTop = originRect ? Math.round(originRect.top) : -40; // start above viewport for falling effect
                        const top = spawnTop + Math.round(Math.random() * 40 - 10);

                        g.style.left = clampedLeft + 'px';
                        g.style.top = top + 'px';

                        // animation duration longer for a gentle fall; vary per star
                        const dur = (reduced ? 900 : 1800) + Math.floor(Math.random() * (reduced ? 800 : 2200));
                        g.style.animationDuration = dur + 'ms';

                        // horizontal drift and slight rotation
                        const dx = Math.round((Math.random() * 220) - 110);
                        const rot = Math.round((Math.random() * 60) - 30);
                        g.style.transform = `translateX(${dx}px) rotate(${rot}deg)`;
                        g.style.opacity = '0.98';

                        document.body.appendChild(g);

                        // cleanup after animation plus a small buffer
                        setTimeout(() => { try { if (g.parentElement) g.parentElement.removeChild(g); } catch (e) {} }, dur + 400);

                        spawned++;
                    }

                    // schedule next tick with slight randomness
                    const jitter = Math.floor((Math.random() - 0.5) * (interval * 0.3));
                    setTimeout(spawnTick, Math.max(40, interval + jitter));
                };

                // kick off
                spawnTick();
            } catch (e) { /* ignore visual errors */ }
        }

        // Continuous star rain controller (desktop only)
    // 桌面專用：持續星星雨控制器（避免在行動裝置過度渲染）
    // Desktop-only continuous star rain controller; throttles by active nodes.
    // 在背景啟動「星星雨」裝飾效果
    // Start decorative star rain in the background
    function startStarRain() {
            try {
                // desktop only
                if ((window.matchMedia && window.matchMedia('(max-width: 640px)').matches) || window.innerWidth <= 640) return;
                if (window.__starRainRunning) return;
                window.__starRainRunning = true;

                const loop = () => {
                    if (!window.__starRainRunning) return;
                    try {
                        // throttle if too many active glitter nodes
                        const active = document.querySelectorAll('.gold-glitter').length;
                        const budget = active > 300 ? 0 : (active > 200 ? 1 : (active > 120 ? 2 : 3));
                        for (let i = 0; i < budget; i++) {
                            const g = document.createElement('div');
                            g.className = 'gold-glitter';
                            g.textContent = '✦';
                            // random horizontal spawn across viewport
                            const left = Math.max(6, Math.min(window.innerWidth - 6, Math.floor(Math.random() * window.innerWidth)));
                            const top = -40 + Math.floor(Math.random() * 20);
                            g.style.left = left + 'px';
                            g.style.top = top + 'px';
                            // vary duration and drift
                            const dur = 1400 + Math.floor(Math.random() * 1800);
                            g.style.animationDuration = dur + 'ms';
                            const dx = Math.round((Math.random() * 220) - 110);
                            const rot = Math.round((Math.random() * 60) - 30);
                            g.style.transform = `translateX(${dx}px) rotate(${rot}deg)`;
                            g.style.opacity = '0.98';
                            document.body.appendChild(g);
                            setTimeout(() => { try { if (g.parentElement) g.parentElement.removeChild(g); } catch (_) {} }, dur + 400);
                        }
                    } catch (_) {}
                    // schedule next tick
                    window.__starRainTimer = setTimeout(loop, 240 + Math.floor(Math.random() * 220));
                };
                loop();
            } catch (_) { /* ignore */ }
        }

    // 停止星星雨：可選擇立即清除現有的金色流光元素
    // Stop star rain; optionally clear existing glitter nodes.
    // 停止星星雨並清理節點
    // Stop star rain and clean up nodes
    function stopStarRain(forceClear = true) {
            try {
                window.__starRainRunning = false;
                if (window.__starRainTimer) { clearTimeout(window.__starRainTimer); window.__starRainTimer = null; }
                if (forceClear) {
                    document.querySelectorAll('.gold-glitter').forEach(el => { try { if (el.parentElement) el.parentElement.removeChild(el); } catch(_) {} });
                }
            } catch (_) { /* ignore */ }
        }


    // 依目前狀態更新主要 UI（標題、提示、按鈕等）
    // Update main game UI from current state
    function updateGameUI() {
            // 更新關卡進度橢圓條
            try { updateLevelOvals(); } catch (e) { /* ignore */ }
            
            // 更新題目進度橢圓條
            try { updateQuestionOvals(); } catch (e) { /* ignore */ }
            
            // 更新分數顯示（使用計數動畫）
            const scoreElement = document.getElementById('centerScore');
            const currentScore = parseInt(scoreElement.textContent) || 0;
            const newScore = gameState.score;
            
            if (newScore !== currentScore) {
                animateScoreWithCounting(currentScore, newScore);
                // 向輔助工具播報分數變化
                try { const live = document.getElementById('scoreAriaLive'); if (live) live.textContent = `分數 ${newScore} 分`; } catch(e){}
            } else {
                scoreElement.textContent = gameState.score;
            }
            
            // 更新提示按鈕狀態和圖案顯示
            updateHintButton();
        }

    // 更新關卡進度橢圓（包含失敗紅色狀態）
    // Update level progress ovals including failed state
    function updateLevelOvals() {
            const container = document.getElementById('levelOvals');
            if (container) container.innerHTML = '';

            for (let i = 1; i <= 5; i++) {
                const oval = document.createElement('div');
                // reduced height and font to save vertical space
                oval.className = 'flex-1 h-7 rounded-full flex items-center justify-center text-xs font-semibold transition-all duration-200';

                if (i < gameState.currentLevel || (i === gameState.currentLevel && gameState.levelResults[i])) {
                    // 已完成的關卡（包括剛完成的當前關卡）
                    const levelResult = gameState.levelResults && gameState.levelResults[i];
                    if (levelResult === 'perfect') {
                        // golden feel: white->yellow gradient, warmer border and subtle shadow
                        oval.className += ' bg-gradient-to-br from-white via-yellow-100 to-yellow-300 text-yellow-900 border-2 border-yellow-400 shadow-md';
                        oval.innerHTML = '<span class="px-2">完美</span>';
                    } else if (levelResult === 'complete') {
                        oval.className += ' bg-emerald-500 text-white border-2 border-yellow-400 shadow-sm';
                        oval.innerHTML = '<span class="px-2">全對</span>';
                    } else if (levelResult === 'failed') {
                        // 全錯：紅底錯誤狀態
                        oval.className += ' bg-rose-500 text-white border-2 border-rose-700 shadow-sm';
                        oval.innerHTML = '<span class="px-2">失敗</span>';
                    } else {
                        oval.className += ' bg-green-400 text-green-900 border-2';
                        oval.innerHTML = '<span class="px-2">完成</span>';
                    }
                } else if (i === gameState.currentLevel) {
                    // 當前關卡（進行中）
                    oval.className += ' bg-purple-200 text-purple-800 animate-pulse';
                    oval.innerHTML = `<span class="px-2">🎮${i}</span>`;
                } else {
                    // 未開始的關卡
                    oval.className += ' bg-gray-200 text-gray-500 border-2';
                    oval.innerHTML = `<span class="px-2">⏳${i}</span>`;
                }

                if (container) container.appendChild(oval);
            }

            // 同步更新手機版迷你關卡進度（備援顯示）
            try {
                const mini = document.getElementById('levelProgressMini');
                if (mini) {
                    mini.innerHTML = '';
                    for (let i = 1; i <= 5; i++) {
                        const d = document.createElement('div');
                        d.className = 'mini-dot';
                        const levelResult = gameState.levelResults && gameState.levelResults[i];
                        if (i < gameState.currentLevel || (i === gameState.currentLevel && levelResult)) {
                            if (levelResult === 'perfect') {
                                d.className += ' bg-gradient-to-br from-white via-yellow-100 to-yellow-300 border-yellow-400';
                            } else if (levelResult === 'complete') {
                                d.className += ' bg-emerald-500 border-yellow-400';
                            } else if (levelResult === 'failed') {
                                d.className += ' bg-rose-500 border-rose-700';
                            } else {
                                d.className += ' bg-green-400 border-green-500';
                            }
                        } else if (i === gameState.currentLevel) {
                            d.className += ' bg-purple-200 border-purple-300';
                        } else {
                            d.className += ' bg-gray-200 border-gray-300';
                        }
                        mini.appendChild(d);
                    }
                }
            } catch (_) {}
        }

    // 更新本關每題的進度橢圓（對/錯/未答）
    // Update question ovals for current level
    function updateQuestionOvals() {
            const container = document.getElementById('questionOvals');
            if (!container) return;
            container.innerHTML = '';

            let correctCount = 0;
            let totalAnswered = 0;

            // 確保有題目數據才進行更新
            if (!gameState.questionData || gameState.questionData.length === 0) {
                document.getElementById('currentQuestion').textContent = '0/0';
                return;
            }

            for (let i = 0; i < gameState.questionData.length; i++) {
                const oval = document.createElement('div');
                // shorter ovals to reduce vertical footprint
                oval.className = 'flex-1 h-5 rounded-full flex items-center justify-center text-[11px] font-semibold transition-all duration-200';

                const verseCard = document.querySelector(`[data-index="${i}"]`);
                const maxAttempts = { easy: 3, normal: 2, hard: 1 };
                const originalAttempts = maxAttempts[gameState.difficulty];
                const currentAttempts = gameState.questionAttempts[i] || originalAttempts;

                if (verseCard && verseCard.classList.contains('bg-green-100')) {
                    // 答對了，檢查是否無失誤且未使用提示
                    if (currentAttempts === originalAttempts) {
                        const levelHintKey = `${gameState.currentLevel}|${i}`;
                        const hintUsedThisLevel = (gameState.usedHints && (gameState.usedHints.has(levelHintKey) || gameState.usedHints.has(i)));
                        if (!hintUsedThisLevel) {
                        // 無失誤且無提示完成 - 翠綠色配金邊 (smaller shadow)
                        oval.className += ' bg-emerald-500 text-white border-2 border-yellow-400 shadow-sm';
                        oval.innerHTML = '<span>✓</span>';
                        } else {
                            // used hint this level: treat as answered-with-hint
                            oval.className += ' bg-green-400 text-green-900 border-2';
                            oval.innerHTML = '<span>✓</span>';
                        }
                    } else {
                        // 有失誤 - 普通綠色
                        oval.className += ' bg-green-400 text-green-900 border-2';
                        oval.innerHTML = '<span>✓</span>';
                    }
                    correctCount++;
                    totalAnswered++;
                } else if (verseCard && verseCard.classList.contains('bg-red-100')) {
                    // 答錯
                    oval.className += ' bg-red-400 text-red-900 border-2';
                    oval.innerHTML = '<span>✗</span>';
                    totalAnswered++;
                } else if (verseCard && (verseCard.classList.contains('bg-yellow-100') || verseCard.classList.contains('bg-orange-100'))) {
                    // 已經嘗試過但還未完成 - 黃色
                    oval.className += ' bg-yellow-400 text-yellow-900 border-2';
                    oval.innerHTML = '<span>!</span>';
                } else {
                    // 未開始
                    oval.className += ' bg-gray-200 text-gray-500 border-2';
                    oval.innerHTML = '<span>?</span>';
                }

                container.appendChild(oval);
            }

            // 更新數字顯示
            const cq = document.getElementById('currentQuestion');
            if (cq) cq.textContent = `${totalAnswered}/${gameState.questionData.length}`;
        }

    // 刷新提示按鈕狀態與剩餘次數顏色
    // Refresh hint button and remaining count color
    function updateHintButton() {
            const hintBtn = document.getElementById('hintBtn');
            const hintCount = document.getElementById('hintCount');
            
            // 更新提示次數顯示
            if (hintCount) {
                hintCount.textContent = `⭐×${gameState.hintsRemaining}`;
                
                // 根據剩餘次數改變顏色
                if (gameState.hintsRemaining <= 0) {
                    hintCount.className = 'text-sm font-bold text-gray-400 ml-3';
                } else if (gameState.hintsRemaining <= 1) {
                    hintCount.className = 'text-sm font-bold text-red-600 ml-3';
                } else if (gameState.hintsRemaining <= 2) {
                    hintCount.className = 'text-sm font-bold text-orange-600 ml-3';
                } else {
                    hintCount.className = 'text-sm font-bold text-blue-600 ml-3';
                }
            }
            
            // 更新按鈕狀態
            if (gameState.hintsRemaining <= 0) {
                hintBtn.classList.add('opacity-50', 'cursor-not-allowed');
                hintBtn.disabled = true;
            } else {
                hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                hintBtn.disabled = false;
            }
        }



    // 封裝並回傳本局遊戲紀錄（不直接寫入；由呼叫端決定後續流程）
    // Build and return a gameRecord snapshot for this run; caller persists/displays it.
    function saveScore(score) {
            // 計算遊戲耗時（從開始到完成最後一關，不包括結算視窗時間）
            const endTime = gameState.gameEndTime || Date.now();
            const gameTime = gameState.gameStartTime ? Math.floor((endTime - gameState.gameStartTime) / 1000) : 0;
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // 創建遊戲記錄
            const gameRecord = {
                id: Date.now(), // 唯一ID
                score: score,
                difficulty: gameState.difficulty,
                date: new Date().toLocaleDateString('zh-TW'),
                time: timeString,
                completed: gameState.gameCompleted,
                correctAnswers: gameState.totalCorrectAnswers,
                totalQuestions: gameState.totalQuestions,
                totalMistakes: gameState.totalMistakes,
                levelResults: { ...gameState.levelResults },
                range: gameState.range,
                testament: gameState.testament,
                customBooks: [...gameState.customBooks],
                // include closing verse chosen at game end so record view shows identical verse
                closingVerse: gameState.closingVerse || null,
                closingVerseRef: gameState.closingVerseRef || null,
                // persist transient fields to allow exact replay of breakdown
                hintsRemaining: gameState.hintsRemaining != null ? gameState.hintsRemaining : null,
                totalHints: (function(){ const hintCounts = { easy: 3, normal: 3, hard: 3 }; return hintCounts[gameState.difficulty] || null; })(),
                showTimeReward: gameState.showTimeReward === true,
                timeReward: (typeof gameState.timeReward === 'number') ? gameState.timeReward : null,
                usedHintsCount: (gameState.usedHints ? gameState.usedHints.size : 0)
            };
            // 儲存題組快照（最小必要資訊以便重播）
            try {
                gameRecord.questionSnapshot = {
                    questionData: JSON.parse(JSON.stringify(gameState.questionData || [])),
                    levelResults: { ...gameState.levelResults },
                    totalQuestions: gameState.totalQuestions
                };
            } catch (e) {
                gameRecord.questionSnapshot = null;
            }
            
            return gameRecord;
        }

    // 載入排行榜（線上優先；否則本機 localStorage）
    // Load leaderboard from online adapter or localStorage
    function loadLeaderboard() {
            // If online leaderboard is configured, this function becomes a thin wrapper to fetch
            // and map results into the same structure { easy:[], normal:[], hard:[] }.
            if (window.Leaderboard && typeof window.Leaderboard.load === 'function') {
                console.log('[LEADERBOARD] using online leaderboard load');
                return window.Leaderboard.load();
            }

            const stored = JSON.parse(localStorage.getItem('bibleGameLeaderboard') || '{}');
            
            // 如果是舊格式（陣列），轉換為新格式
            if (Array.isArray(stored)) {
                const newFormat = { easy: [], normal: [], hard: [] };
                stored.forEach(record => {
                    if (record.difficulty && newFormat[record.difficulty]) {
                        newFormat[record.difficulty].push({
                            score: record.score,
                            date: record.date
                        });
                    }
                });
                // 每個難度保留前5名（升級）
                Object.keys(newFormat).forEach(difficulty => {
                    newFormat[difficulty].sort((a, b) => b.score - a.score);
                    newFormat[difficulty] = newFormat[difficulty].slice(0, 5);
                });
                localStorage.setItem('bibleGameLeaderboard', JSON.stringify(newFormat));
                return newFormat;
            }
            
            // 確保每個難度都存在，並限制為最多 5 筆
            if (!stored.easy) stored.easy = [];
            if (!stored.normal) stored.normal = [];
            if (!stored.hard) stored.hard = [];
            Object.keys(stored).forEach(k => {
                if (Array.isArray(stored[k])) {
                    stored[k].sort((a, b) => (b.score || 0) - (a.score || 0));
                    stored[k] = stored[k].slice(0, 5);
                }
            });
            // Backfill/estimate transient fields for older records that predate these properties.
            // We keep the estimate conservative and attach a flag so consumers can detect it.
            try {
                Object.keys(stored).forEach(k => {
                    if (!Array.isArray(stored[k])) return;
                    stored[k].forEach(record => {
                        // If a record already has explicit timeReward, skip
                        if (record.timeReward != null) return;

                        // Need minimal fields to attempt an estimate
                        const correctAnswers = record.correctAnswers != null ? record.correctAnswers : (record.totalCorrectAnswers != null ? record.totalCorrectAnswers : null);
                        const totalMistakes = record.totalMistakes != null ? record.totalMistakes : 0;
                        const levelResults = record.levelResults || {};

                        if (correctAnswers == null || record.score == null) {
                            // insufficient data to estimate
                            return;
                        }

                        // compute base score and level bonuses using the same rules as renderer
                        const baseScore = correctAnswers * 100;
                        let bonusScore = 0;
                        Object.values(levelResults).forEach(r => {
                            if (r === 'perfect') bonusScore += 300;
                            else if (r === 'complete') bonusScore += 100;
                        });

                        // estimate hint bonus when possible
                        let hintBonus = 0;
                        if (record.hintsRemaining != null && record.totalHints != null) {
                            hintBonus = (record.hintsRemaining || 0) * 100;
                        } else if (record.totalHints != null && record.usedHintsCount != null) {
                            const hintsLeft = Math.max(0, (record.totalHints || 0) - (record.usedHintsCount || 0));
                            hintBonus = hintsLeft * 100;
                        }
                        bonusScore += hintBonus;

                        // 與結算視圖一致：回加 20 × 失誤數
                        const estimatedTimeReward = (record.score || 0) - baseScore + (totalMistakes * 50) - bonusScore;
                        record.timeReward = estimatedTimeReward;
                        record.timeRewardEstimated = true;
                    });
                });
            } catch (e) { /* non-fatal */ }

            // Backfill deterministic closingVerse for legacy records missing it so repeated opens are stable.
            try {
                // verse pools mirrored from updateClosingVerse logic
                const versePools = {
                    excellent: [
                        { text: "你們要靠主常常喜樂。我再說，你們要喜樂。", ref: "腓立比書 4:4" },
                        { text: "那美好的仗我已經打過了，當跑的路我已經跑盡了，所信的道我已經守住了。", ref: "提摩太後書 4:7" },
                        { text: "神能照著運行在我們心裡的大力充充足足地成就一切，超過我們所求所想的。", ref: "以弗所書 3:20" },
                        { text: "得勝的，我要賜他在我寶座上與我同坐。", ref: "啟示錄 3:21" },
                        { text: "忠心至死，我就賜給你那生命的冠冕。", ref: "啟示錄 2:10" },
                        { text: "好，你這又良善又忠心的僕人。", ref: "馬太福音 25:21" },
                        { text: "凡得勝的必這樣穿白衣，我也必不從生命冊上塗抹他的名。", ref: "啟示錄 3:5" },
                        { text: "義人的腳步被耶和華立定；他的道路，耶和華也喜愛。", ref: "詩篇 37:23" },
                        { text: "你們是世上的光。城造在山上是不能隱藏的。", ref: "馬太福音 5:14" },
                        { text: "聖靈所結的果子，就是仁愛、喜樂、和平。", ref: "加拉太書 5:22" }
                    ],
                    good: [
                        { text: "我靠著那加給我力量的，凡事都能做。", ref: "腓立比書 4:13" },
                        { text: "你當剛強壯膽，不要懼怕，也不要驚惶。", ref: "申命記 31:6" },
                        { text: "所信的道我已經守住了。", ref: "提摩太後書 4:7" },
                        { text: "神是我們的避難所和力量。", ref: "詩篇 46:1" }
                    ],
                    encouraging: [
                        { text: "不要失望，要堅固禱告。", ref: "帖撒羅尼迦前書 5:17" },
                        { text: "倚靠耶和華的人有福了。", ref: "詩篇 40:4" },
                        { text: "凡事藉著禱告和祈求，帶著感謝，將你們所要的告訴神。", ref: "腓立比書 4:6" }
                    ],
                    supportive: [
                        { text: "耶和華是我的牧者，我必不致缺乏。", ref: "詩篇 23:1" },
                        { text: "你要剛強壯膽，不可懼怕。", ref: "約書亞記 1:9" },
                        { text: "凡事互相寬容，彼此相愛。", ref: "以弗所書 4:2" }
                    ]
                };

                function simpleHash(str) {
                    let h = 0;
                    for (let i = 0; i < str.length; i++) {
                        h = ((h << 5) - h) + str.charCodeAt(i);
                        h |= 0;
                    }
                    return Math.abs(h);
                }

                Object.keys(stored).forEach(k => {
                    if (!Array.isArray(stored[k])) return;
                    stored[k].forEach(record => {
                        if (record.closingVerse != null || record.closingVerseRef != null) return;
                        // compute approximate accuracy if possible
                        const correct = record.correctAnswers != null ? record.correctAnswers : (record.totalCorrectAnswers != null ? record.totalCorrectAnswers : null);
                        const totalQ = record.totalQuestions != null ? record.totalQuestions : null;
                        if (correct == null || totalQ == null || totalQ === 0) return; // insufficient data
                        const acc = Math.round((correct / totalQ) * 100);

                        let pool = versePools.supportive;
                        if (acc >= 90) pool = versePools.excellent;
                        else if (acc >= 70) pool = versePools.good;
                        else if (acc >= 50) pool = versePools.encouraging;

                        const idxSeed = (record.id != null) ? String(record.id) : String(record.score || '') + String(record.date || '');
                        const idx = simpleHash(idxSeed) % pool.length;
                        record.closingVerse = pool[idx].text;
                        record.closingVerseRef = pool[idx].ref;
                        record.closingVerseEstimated = true;
                    });
                });

                // persist our backfilled fields so future loads are stable
                try {
                    localStorage.setItem('bibleGameLeaderboard', JSON.stringify(stored));
                } catch (e) { /* ignore persistence failures */ }
            } catch (e) { /* non-fatal */ }

            return stored;
        }



    // 重新渲染排行榜清單：支援非同步來源、無動畫回退、減少動態偏好
    // Re-render leaderboard for a difficulty; supports async adapter and reduced-motion fallback.
    // 重繪排行榜卡片清單；支援非同步與減少動態回退
    // Redraw leaderboard list; supports async and reduced-motion
    async function updateLeaderboardDisplay(selectedDifficulty = 'easy', options = {}) {
            const container = document.getElementById('leaderboardList');
            if (!container) return;
            // Ensure tabs reflect current difficulty theme
            try { setActiveLeaderboardTabByDifficulty && setActiveLeaderboardTabByDifficulty(selectedDifficulty); } catch(_) {}
            // Prevent overlapping transitions from programmatic calls
            if (options.animate && window.__lbTransitioning) return;

            // Respect reduced motion
            let reduced = false;
            try { reduced = !!(getReducedMotion && getReducedMotion()); } catch(_) {}
            const animate = !!options.animate && !reduced;
            const direction = options.direction === 'right' ? 'right' : 'left';
            if (animate && window.__lbTransitioning) return; // prevent overlapping animations

            const pending = loadLeaderboard();
            const isAsync = pending && typeof pending.then === 'function';
            if (isAsync) container.setAttribute('aria-busy', 'true');

            // Resolve data
            let allLeaderboards;
            try {
                allLeaderboards = isAsync ? await pending : pending;
            } catch (e) {
                console.warn('online leaderboard load failed; using empty fallback', e);
                allLeaderboards = { easy: [], normal: [], hard: [] };
            } finally {
                container.removeAttribute('aria-busy');
            }

            const difficultyLeaderboard = (allLeaderboards && allLeaderboards[selectedDifficulty]) || [];

            // Helper to build a pane's grid content
            const buildPaneContent = (paneEl) => {
                paneEl.innerHTML = '';
                for (let i = 0; i < 5; i++) {
                    const column = document.createElement('div');
                    column.className = 'text-center';
                    if (i < difficultyLeaderboard.length) {
                        const record = difficultyLeaderboard[i];
                        const rankNumber = i + 1;
                        const playerName = record.playerName || '匿名';
                        const rarity = record.rarity || null;
                        const rarityLabelMap = { common: '常見經文', rare: '冷門經文', all: '全部經文' };
                        const rarityLabel = rarity ? (rarityLabelMap[rarity] || '未知') : null;
                        const rankClass = (rankNumber === 1) ? 'rank-1' : (rankNumber === 2) ? 'rank-2' : (rankNumber === 3) ? 'rank-3' : 'rank-default';
                        const medal = (rankNumber === 1) ? '🥇' : (rankNumber === 2) ? '🥈' : (rankNumber === 3) ? '🥉' : '';
                        const aria = `第${rankNumber}名，${playerName}，${record.score}分`;
                        column.innerHTML = `
                            <div class="leaderboard-card ${rankClass}" data-record-id="${record.id}" title="${playerName}" role="button" aria-label="${aria}">
                                <div class="lb-rank-ribbon"><span>${rankNumber}</span></div>
                                ${medal ? `<div class=\"lb-medal\" aria-hidden=\"true\">${medal}</div>` : ''}
                                <div class="lb-card-body text-left">
                                    <div class="lb-top-row">
                                        <div class="lb-score">${record.score}<span class="unit">分</span></div>
                                        <div class="lb-name flex-1 min-w-0"><span class="truncate" title="${playerName}">${playerName}</span></div>
                                    </div>
                                    <div class="lb-meta">${record.date || ''}${record.time ? ' · ' + record.time : ''}${record.elapsed ? ' · ' + record.elapsed : ''}</div>
                                    ${rarityLabel ? `<div class=\"mt-1\">\n                                        <span class=\"lb-pill ${rarity === 'all' ? 'rarity-all' : rarity === 'rare' ? 'rarity-rare' : 'rarity-common'}\">${rarityLabel}</span>\n                                    </div>` : ''}
                                </div>
                            </div>
                        `;
                    } else {
                        column.innerHTML = `
                            <div class="leaderboard-card rank-default" aria-hidden="true">
                                <div class="lb-rank-ribbon"><span>-</span></div>
                                <div class="lb-card-body text-center" style="min-height: 3.2rem; display: flex; align-items: center; justify-content: center;">
                                    <div class="text-sm font-semibold text-gray-400">暫無記錄</div>
                                </div>
                            </div>
                        `;
                    }
                    paneEl.appendChild(column);
                }
            };

            // Acquire panes
            let currentPane = container.querySelector('[data-lb-pane="current"]');
            let nextPane = document.createElement('div');
            nextPane.className = 'lb-slide grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4';
            nextPane.setAttribute('data-lb-pane', 'next');

            buildPaneContent(nextPane);

            // Helper to attach card click handlers within a pane
            const bindPaneInteractions = (pane) => {
                pane.querySelectorAll('[data-record-id]').forEach(el => {
                    el.style.cursor = 'pointer';
                    el.addEventListener('click', () => {
                        try {
                            const rect = el.getBoundingClientRect();
                            let rank = 0;
                            try {
                                const ribbon = el.querySelector('.lb-rank-ribbon span');
                                rank = ribbon ? parseInt(ribbon.textContent, 10) || 0 : 0;
                            } catch(_) {}
                            const rankPalettes = {
                                1: ['#FDE68A','#F59E0B','#FBBF24','#FFF7CC','#FEEBC8'],
                                2: ['#E5E7EB','#D1D5DB','#9CA3AF','#F3F4F6','#FFFFFF'],
                                3: ['#F59E0B','#D97706','#B45309','#FCD34D','#FDE68A'],
                                0: ['#E5E7EB','#D1FAE5','#EDE9FE','#F3F4F6']
                            };
                            const colors = rankPalettes[rank] || rankPalettes[0];
                            spawnScoreParticles(80, rect, { colors });
                        } catch(_) {}
                        const id = el.getAttribute('data-record-id');
                        openLeaderboardRecordById(id, selectedDifficulty);
                    });
                });
            };

            // Personal rank tile (append to pane)
            const maybeAppendPersonalRank = async (pane) => {
                try {
                    const playerName = (window.localStorage && localStorage.getItem('lastPlayerName')) || '';
                    if (playerName && window.Leaderboard && typeof window.Leaderboard.load === 'function') {
                        const cfg = window.SUPABASE_CONFIG;
                        if (cfg && window.supabase && window.supabase.createClient) {
                            const client = window.supabase.createClient(cfg.url, cfg.anonKey, cfg.options || {});
                            const topList = difficultyLeaderboard;
                            const selfTop = topList.find(r => (r.playerName||'') === playerName);
                            if (!selfTop) {
                                let q1 = client
                                    .from(cfg.table || 'scores')
                                    .select('score, created_at')
                                    .eq('difficulty', selectedDifficulty)
                                    .eq('player_name', playerName);
                                if (cfg.projectTag) q1 = q1.eq('project_tag', cfg.projectTag);
                                const { data: myRows, error: myErr } = await q1
                                    .order('score', { ascending: false })
                                    .order('created_at', { ascending: true })
                                    .limit(1);
                                if (!myErr && myRows && myRows.length) {
                                    const my = myRows[0];
                                    let q2 = client
                                        .from(cfg.table || 'scores')
                                        .select('id', { count: 'exact', head: true })
                                        .eq('difficulty', selectedDifficulty)
                                        .gt('score', my.score);
                                    if (cfg.projectTag) q2 = q2.eq('project_tag', cfg.projectTag);
                                    const { data: cntRows } = await q2;
                                    const betterCount = (cntRows && cntRows.length) ? cntRows.length : (cntRows && cntRows.count) ? cntRows.count : 0;
                                    const rank = (betterCount || 0) + 1;
                                    if (rank > 5) {
                                        const row = document.createElement('div');
                                        row.className = 'col-span-full mt-2';
                                        row.innerHTML = `
                                            <div class="leaderboard-card rank-default" aria-live="polite">
                                                <div class="lb-rank-ribbon"><span>${rank}</span></div>
                                                <div class="lb-card-body text-left">
                                                    <div class="lb-top-row">
                                                        <div class="lb-score">個人名次<span class="unit"></span></div>
                                                        <div class="lb-name flex-1 min-w-0"><span class="truncate" title="${playerName}">${playerName}</span></div>
                                                    </div>
                                                    <div class="lb-meta">目前於「${selectedDifficulty}」難度的估計名次</div>
                                                </div>
                                            </div>
                                        `;
                                        pane.appendChild(row);
                                    }
                                }
                            }
                        }
                    }
                } catch (e) { /* non-fatal */ }
            };

            // Ensure swipe is initialized once
            try { if (!container.__swipeSetup) { setupLeaderboardSwipe(); container.__swipeSetup = true; } } catch(_) {}

            // If there's no current pane or animation is disabled, just render statically
            if (!animate || !container.querySelector('[data-lb-pane="current"]')) {
                // Clear and mount as static
                container.innerHTML = '';
                nextPane.classList.add('lb-slide-static');
                nextPane.setAttribute('data-lb-pane', 'current');
                container.appendChild(nextPane);
                window.__lbCurrentDifficulty = selectedDifficulty;
                bindPaneInteractions(nextPane);
                await maybeAppendPersonalRank(nextPane);
                return;
            }

            // Animated transition between panes
            currentPane = container.querySelector('[data-lb-pane="current"]');
            if (!currentPane) {
                // Fallback to static if somehow missing
                container.innerHTML = '';
                nextPane.classList.add('lb-slide-static');
                nextPane.setAttribute('data-lb-pane', 'current');
                container.appendChild(nextPane);
                window.__lbCurrentDifficulty = selectedDifficulty;
                bindPaneInteractions(nextPane);
                await maybeAppendPersonalRank(nextPane);
                return;
            }

            bindPaneInteractions(nextPane);
            await maybeAppendPersonalRank(nextPane);

            // Determine mobile to use crossfade instead of slide to avoid double-stack on small screens
            let isMobile = false;
            try { isMobile = !!(window.matchMedia && window.matchMedia('(max-width: 640px)').matches); } catch(_) { isMobile = (window.innerWidth <= 640); }

            // Lock container height during transition to prevent collapse
            const currentH = currentPane.offsetHeight;
            if (currentH && currentH > 0) container.style.height = currentH + 'px';

            currentPane.classList.remove('lb-slide-static');
            container.appendChild(nextPane);

            // Measure next height after insertion
            const nextH = nextPane.offsetHeight;
            const targetH = Math.max(currentH || 0, nextH || 0);
            if (targetH && targetH > 0) container.style.height = targetH + 'px';

            window.__lbTransitioning = true;
            // Disable pointer events on tabs and container while animating
            try {
                document.querySelectorAll('.leaderboard-tab').forEach(t => t.style.pointerEvents = 'none');
                container.style.pointerEvents = 'none';
            } catch(_) {}
            if (isMobile) {
                // Crossfade: keep both panes stacked, fade out current, fade in next
                try {
                    // Reset transforms for crossfade
                    currentPane.style.transform = 'none';
                    nextPane.style.transform = 'none';
                    nextPane.style.opacity = '0';
                    // Force reflow
                    void nextPane.offsetWidth;
                } catch(_) {}
                requestAnimationFrame(() => {
                    try {
                        currentPane.style.opacity = '0';
                        nextPane.style.opacity = '1';
                    } catch(_) {}
                });
            } else {
                // Slide transition
                nextPane.style.transform = (direction === 'left') ? 'translateX(100%)' : 'translateX(-100%)';
                requestAnimationFrame(() => {
                    try {
                        currentPane.style.transform = (direction === 'left') ? 'translateX(-100%)' : 'translateX(100%)';
                        nextPane.style.transform = 'translateX(0)';
                    } catch(_) {}
                });
            }

            let done = false;
            const cleanup = () => {
                if (done) return; done = true;
                try { currentPane.remove(); } catch(_) {}
                nextPane.classList.add('lb-slide-static');
                nextPane.setAttribute('data-lb-pane', 'current');
                nextPane.style.transform = '';
                nextPane.style.opacity = '';
                window.__lbCurrentDifficulty = selectedDifficulty;
                window.__lbTransitioning = false;
                container.style.height = '';
                nextPane.removeEventListener('transitionend', cleanup);
                // Re-enable interactions
                try {
                    document.querySelectorAll('.leaderboard-tab').forEach(t => t.style.pointerEvents = '');
                    container.style.pointerEvents = '';
                } catch(_) {}
            };
            nextPane.addEventListener('transitionend', cleanup);
            // Fallback: in case transitionend doesn't fire (e.g., display change), force cleanup
            setTimeout(cleanup, 800);
        }







        // 單次初始化旗標，避免重建造成閃爍
        window.__marqueeInitialized = window.__marqueeInitialized || false;

    // 初始化經文跑馬燈：桌面高密度、手機精簡；支援「偏好減少動態」改渲染成靜態行
    // Initialize verse marquee: dense on desktop, reduced on mobile; honor reduced motion with static lines
    // 初始化首頁跑馬燈（動態經文牆），考慮行動裝置與減少動態
    // Initialize the verse marquee on the start screen
    function initializeVerseMarquee() {
            const marqueeContainer = document.getElementById('verseMarquee');
            if (!marqueeContainer) return;
            // On small screens, render a reduced-density marquee instead of disabling
            let mobileLite = false;
            try {
                mobileLite = !!(window.matchMedia && window.matchMedia('(max-width: 640px)').matches);
            } catch (_) { mobileLite = (window.innerWidth <= 640); }
            if (window.__marqueeInitialized) return; // 防止重複初始化

            // 構建期間暫時隱藏，避免首度渲染閃爍
            const prevVisibility = marqueeContainer.style.visibility;
            marqueeContainer.style.visibility = 'hidden';
            marqueeContainer.innerHTML = '';

            // 行數：桌面 34，手機精簡到 10 行
            const totalLines = mobileLite ? 10 : 34;
            const __activeDB = getActiveVerseDB();
            const __commonPool = Array.isArray(__activeDB) ? __activeDB.filter(v => v && v.rarity === 'common') : [];
            // 跑馬燈一律使用常見經文；若暫無常見經文則暫不渲染，等待資料到齊再刷新
            if (!__commonPool || __commonPool.length === 0) {
                marqueeContainer.style.visibility = prevVisibility || '';
                return;
            }
            const shuffledVerses = [...__commonPool].sort(() => Math.random() - 0.5);
            const selectedVerses = shuffledVerses.slice(0, totalLines).map(v => v.verse);

            // 若使用者偏好減少動態，直接渲染靜態多行文字並退出
            if (getReducedMotion && getReducedMotion()) {
                const frag = document.createDocumentFragment();
                for (let i = 0; i < Math.min(totalLines, selectedVerses.length); i++) {
                    const verseElement = document.createElement('div');
                    verseElement.className = 'verse-text';
                    verseElement.style.animation = 'none';
                    verseElement.style.position = 'relative';
                    verseElement.style.top = 'auto';
                    verseElement.style.left = 'auto';
                    verseElement.style.transform = 'none';
                    verseElement.style.opacity = '0.65';
                    verseElement.style.filter = 'none';
                    verseElement.style.fontSize = '1rem';
                    verseElement.style.textShadow = 'none';
                    verseElement.style.margin = '2px 0';
                    verseElement.textContent = selectedVerses[i] || '';
                    frag.appendChild(verseElement);
                }
                marqueeContainer.appendChild(frag);
                marqueeContainer.style.visibility = prevVisibility || '';
                window.__marqueeInitialized = true;
                return;
            }

            // 預設的字體大小基準值（以 rem 為單位）。手機使用更小字級範圍，減少遮擋與重繪。
            const baseFontSizes = mobileLite
                ? [1.2,1.4,1.6,1.8,2.0,1.5,1.7,1.3,1.9,2.1,1.6,1.4,1.8,1.2,1.7]
                : [2.6,3.2,3.6,4.2,3.4,4.6,3.9,4.0,3.3,4.8,3.7,2.9,3.0,4.4,3.5,5.2,6.5];
            const baseMin = Math.min(...baseFontSizes);
            const baseMax = Math.max(...baseFontSizes);
            const newMin = baseMin * 0.5; // 最小值 x0.5
            const newMax = baseMax * 2;   // 最大值 x2
            // 線性映射函數，保持原始分佈比例
            const scaledFontSizes = baseFontSizes.map(s => {
                if (baseMax === baseMin) return newMin;
                const t = (s - baseMin) / (baseMax - baseMin);
                return (newMin + t * (newMax - newMin));
            });

            // 速度群組（秒）：手機整體加快以縮短佔用，並降低透明度
            const speedGroups = mobileLite ? [12, 18, 26] : [18, 30, 45];
            const maxDuration = Math.max(...speedGroups);

            // richer color pool (主色 + glow)，循環使用
            const colorPool = [
                { c: '255,99,132',   a: 0.14 }, // pink-red
                { c: '255,159,64',   a: 0.12 }, // orange
                { c: '255,205,86',   a: 0.10 }, // yellow
                { c: '75,192,192',   a: 0.10 }, // teal
                { c: '54,162,235',   a: 0.11 }, // blue
                { c: '153,102,255',  a: 0.12 }, // purple
                { c: '201,203,207',  a: 0.08 }, // gray
                { c: '99,102,241',   a: 0.11 }, // indigo
                { c: '16,185,129',   a: 0.10 }, // green
                { c: '236,72,153',   a: 0.12 }  // fuchsia
            ];

            const frag = document.createDocumentFragment();
            for (let i = 0; i < totalLines; i++) {
                const verseElement = document.createElement('div');
                verseElement.className = 'verse-text';

                // For each line, pick 3 random verses to rotate through on each full marquee cycle
                const picks = [];
                const activeDB = getActiveVerseDB();
                const pool = Array.isArray(activeDB) ? activeDB.filter(v => v && v.rarity === 'common') : [];
                for (let p = 0; p < 3; p++) {
                    const v = pool[Math.floor(Math.random() * pool.length)];
                    picks.push(v ? (v.verse || '') : '');
                }
                // ensure we have at least one fallback
                if (picks.length === 0) picks.push(selectedVerses[i] || '');
                verseElement.textContent = picks[0] || '';
                // attach list and index for iteration handler
                verseElement.__marqueeList = picks;
                verseElement.__marqueeIdx = 0;
                // on each completed animation loop, switch to the next verse in this line's list
                verseElement.addEventListener('animationiteration', function() {
                    try {
                        this.__marqueeIdx = (this.__marqueeIdx + 1) % (this.__marqueeList ? this.__marqueeList.length : 1);
                        const next = (this.__marqueeList && this.__marqueeList[this.__marqueeIdx]) || '';
                        this.textContent = next;
                    } catch (e) { /* ignore */ }
                });

                // 垂直位置以百分比計算，平均分布並保持在視窗外開始/結束
                // 中心偏移控制讓行分布更加均勻
                const centerOffset = mobileLite ? -20 : -30; // 起始偏移
                const step = mobileLite ? 8 : 6; // 每行間距百分比（行距已在 CSS 中調整）
                const vpos = Math.round(centerOffset + i * step);
                verseElement.style.top = `${vpos}%`;

                // 固定 line-height（見 CSS），僅改變 font-size
                const chosenSizeValue = scaledFontSizes[i % scaledFontSizes.length];
                const chosenSize = `${chosenSizeValue}rem`;
                verseElement.style.fontSize = chosenSize;

                // 分配速度群組：循環分配以在視覺上產生深度
                const duration = speedGroups[i % speedGroups.length];
                verseElement.style.animationDuration = `${duration}s`;
                verseElement.style.animation = `marquee-horizontal ${duration}s linear infinite`;

                // 依據字體大小計算深度感（越大視為越靠前）
                const depthNormalized = (chosenSizeValue - newMin) / (newMax - newMin); // 0..1
                const zIndex = 10 + Math.round(depthNormalized * 90); // 10..100
                verseElement.style.zIndex = zIndex;

                // 依深度調整模糊（遠處較模糊）與透明度
                const maxBlur = mobileLite ? 2.0 : 3.0; // px
                const blurPx = Math.round((1 - depthNormalized) * maxBlur * 10) / 10; // 0..maxBlur
                verseElement.style.filter = `blur(${blurPx}px)`;

                // 顏色與發光：根據索引選用 colorPool，並以速度群組與深度增加層次
                const colorEntry = colorPool[i % colorPool.length];
                const baseAlpha = colorEntry.a;
                const speedIndex = i % speedGroups.length; // 0 fast,1 mid,2 slow
                // 深度會讓近處更飽滿、遠處較淡
                const depthFactor = 0.8 + depthNormalized * 1.2; // 0.8..2.0
                const finalAlpha = Math.max(0.04, Math.min(0.30, baseAlpha * depthFactor * (1 - speedIndex * 0.08)));
                verseElement.style.color = `rgba(${colorEntry.c}, ${finalAlpha})`;

                // text-shadow 作為 glow，近處給較強光暈，遠處較弱；慢速群組更強
                const glowBase = 12 + Math.round((10 + speedIndex * 8) * (0.6 + depthNormalized * 1.2));
                const glowAlpha = Math.min(0.45, 0.10 + speedIndex * 0.06 + depthNormalized * 0.12 + (i % 5) * 0.01);
                verseElement.style.textShadow = `0 0 ${glowBase}px rgba(${colorEntry.c}, ${glowAlpha}), 0 2px ${Math.round(glowBase/3)}px rgba(0,0,0,0.06)`;

                // 透明度整體表現結合深度與速度（近處與慢速看起來更清晰）
                const baseOpacity = (mobileLite ? 0.35 : 0.55) + depthNormalized * (mobileLite ? 0.35 : 0.45);
                verseElement.style.opacity = `${Math.max(0.18, Math.min(1, baseOpacity - speedIndex * 0.10))}`;

                // 使用最大持續時間來計算延遲步進以避免短速組合時同時出現
                const delayStep = maxDuration / totalLines;
                verseElement.style.animationDelay = `${i * -delayStep}s`;

                frag.appendChild(verseElement);
            }
            marqueeContainer.appendChild(frag);
            marqueeContainer.style.visibility = prevVisibility || '';
            window.__marqueeInitialized = true;
        }

        // 若外部資料於初始化後才抵達，更新每行的輪播備選內容，避免重建造成閃爍
    // 重新整理跑馬燈資料來源（依當前題庫）
    // Refresh marquee dataset from current verse DB
    function refreshVerseMarqueeData() {
            try {
    const marqueeContainer = document.getElementById('verseMarquee');
    const activeDB = getActiveVerseDB();
    const pool = Array.isArray(activeDB) ? activeDB.filter(v => v && v.rarity === 'common') : [];
    if (!marqueeContainer || !Array.isArray(pool) || pool.length === 0) return;
                const lines = marqueeContainer.querySelectorAll('.verse-text');
                lines.forEach(line => {
                    const picks = [];
                    for (let p = 0; p < 3; p++) {
            const v = pool[Math.floor(Math.random() * pool.length)];
                        picks.push(v ? (v.verse || '') : '');
                    }
                    line.__marqueeList = picks;
                    // reduced-motion 靜態模式：即時更新顯示文字
                    if (getReducedMotion && getReducedMotion()) {
                        line.textContent = picks[0] || '';
                    }
                });
            } catch (e) { /* ignore */ }
        }

        // Online Leaderboard Adapter (Supabase) — optional
        // Provide a global window.Leaderboard with methods: load(), save(record), clear()
        // Requires a config file bible-challenge/leaderboard-config.js that defines window.SUPABASE_CONFIG = { url, anonKey, table }
        ;(function initOnlineLeaderboard(){
            try {
                const cfg = (window && window.SUPABASE_CONFIG) || null;
                if (!cfg || !cfg.url || !cfg.anonKey) return; // not configured
                if (!(window.supabase && typeof window.supabase.createClient === 'function')) return; // client not loaded

                const client = window.supabase.createClient(cfg.url, cfg.anonKey, cfg.options || {});
                const table = cfg.table || 'scores';

                function toPublicRecord(row){
                    if (!row) return null;
                    // Map DB row into app record shape
                    return {
                        id: row.id || row.created_at || row.rowid || Date.now(),
                        playerName: row.player_name || row.playerName || '匿名',
                        score: row.score || 0,
                        difficulty: row.difficulty || 'easy',
                        date: row.date || (row.created_at ? new Date(row.created_at).toLocaleDateString('zh-TW') : ''),
                        time: row.time || '',
                        completed: row.completed ?? true,
                        correctAnswers: row.correct_answers ?? row.correctAnswers ?? null,
                        totalQuestions: row.total_questions ?? row.totalQuestions ?? null,
                        totalMistakes: row.total_mistakes ?? row.totalMistakes ?? null,
                        levelResults: row.level_results ?? row.levelResults ?? {},
                        range: row.range || 'all',
                        rarity: row.rarity || null,
                        mode: row.mode || 'ranking',
                        testament: row.testament || 'both',
                        customBooks: row.custom_books || [],
                        hintsRemaining: row.hints_remaining ?? null,
                        totalHints: row.total_hints ?? null,
                        showTimeReward: row.show_time_reward ?? false,
                        timeReward: row.time_reward ?? null,
                        usedHintsCount: row.used_hints_count ?? null,
                        closingVerse: row.closing_verse ?? null,
                        closingVerseRef: row.closing_verse_ref ?? null,
                        questionSnapshot: row.question_snapshot ?? null
                    };
                }

                async function load(){
                    // With timeout + retry (exponential backoff with jitter)
                    const difficulties = ['easy','normal','hard'];
                    const out = { easy: [], normal: [], hard: [] };
                    const fetchTop5 = async (diff) => {
                        const op = () => {
                            let q = client.from(table)
                                .select('*')
                                .eq('difficulty', diff);
                            // 限定同一專案標籤的資料，避免誤讀其他專案的排行榜
                            if (cfg.projectTag) q = q.eq('project_tag', cfg.projectTag);
                            return q.order('score', { ascending: false })
                                   .order('created_at', { ascending: true })
                                   .limit(5);
                        };
                        const runWithTimeout = (p, ms) => Promise.race([
                            p, new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), ms))
                        ]);
                        const retry = async (fn, tries = 3, base = 600) => {
                            let lastErr;
                            for (let i = 0; i < tries; i++) {
                                try {
                                    const { data, error } = await runWithTimeout(fn(), 4000 + i * 1000);
                                    if (error) throw error;
                                    return data || [];
                                } catch (e) {
                                    lastErr = e;
                                    const jitter = Math.random() * 150;
                                    await new Promise(r => setTimeout(r, Math.min(2000, base * Math.pow(2, i)) + jitter));
                                }
                            }
                            throw lastErr || new Error('fetch failed');
                        };
                        const data = await retry(op);
                        return (data || []).map(toPublicRecord);
                    };
                    try {
                        for (const d of difficulties) {
                            out[d] = await fetchTop5(d);
                        }
                        return out;
                    } catch (e) {
                        console.warn('[LEADERBOARD] online load error', e);
                        try { return JSON.parse(localStorage.getItem('bibleGameLeaderboard') || '{}'); } catch(_) { return { easy:[], normal:[], hard:[] }; }
                    }
                }

                async function save(record){
                    try {
                        // Persist minimal fields + useful metadata. Avoid overly large questionSnapshot by default; keep if config allows.
                        const keepSnapshot = !!cfg.storeSnapshot;
                        const row = {
                            player_name: record.playerName || '匿名',
                            score: record.score || 0,
                            difficulty: record.difficulty || 'easy',
                            date: record.date || new Date().toLocaleDateString('zh-TW'),
                            time: record.time || '',
                            completed: record.completed !== false,
                            correct_answers: record.correctAnswers ?? null,
                            total_questions: record.totalQuestions ?? null,
                            total_mistakes: record.totalMistakes ?? null,
                            level_results: record.levelResults || {},
                            range: record.range || 'all',
                            rarity: record.rarity || null,
                            // Preserve explicit mode ('ranking'|'practice'|'replay'); default to 'ranking' for safety
                            mode: record.mode || 'ranking',
                            testament: record.testament || 'both',
                            custom_books: record.customBooks || [],
                            hints_remaining: record.hintsRemaining ?? null,
                            total_hints: record.totalHints ?? null,
                            show_time_reward: record.showTimeReward === true,
                            time_reward: record.timeReward ?? null,
                            used_hints_count: record.usedHintsCount ?? null,
                            closing_verse: record.closingVerse ?? null,
                            closing_verse_ref: record.closingVerseRef ?? null,
                            question_snapshot: keepSnapshot ? (record.questionSnapshot || null) : null,
                            project_tag: cfg.projectTag || null
                        };
                        const { error } = await client.from(table).insert(row);
                        if (error) throw error;
                    } catch (e) {
                        console.warn('[LEADERBOARD] online save error', e);
                        throw e;
                    }
                }

                async function clear(){
                    try {
                        // Danger: wipe all rows. Optionally scope by project tag if configured
                        if (cfg.projectTag) {
                            const { error } = await client.from(table).delete().eq('project_tag', cfg.projectTag);
                            if (error) throw error;
                        } else {
                            const { error } = await client.from(table).delete().neq('id', null);
                            if (error) throw error;
                        }
                    } catch (e) {
                        console.warn('[LEADERBOARD] online clear error', e);
                        throw e;
                    }
                }

                window.Leaderboard = { load, save, clear };
                console.log('[LEADERBOARD] online adapter enabled');
            } catch (e) {
                // no-op if not configured
            }
        })();
            // Small init: scoring toggle for mobile to hide/show scoring body and remarks together
            document.addEventListener('DOMContentLoaded', function() {
                try {
                    // Update replay button sublabel according to config (allowReplaySaves)
                    try {
                        const allowReplaySaves = !!(window.SUPABASE_CONFIG && window.SUPABASE_CONFIG.allowReplaySaves);
                        const replayBtn = document.getElementById('replaySameQuestionsBtn');
                        if (replayBtn) {
                            const labelSpan = replayBtn.querySelector('span.text-left');
                            if (labelSpan) {
                                const baseText = '同題重玩';
                                const sub = allowReplaySaves ? '（可列入排行榜）' : '（不列入排行榜）';
                                labelSpan.innerHTML = baseText + '<br><span class="text-xs font-normal">' + sub + '</span>';
                            }
                        }
                    } catch (_) {}

                    var toggleBtn = document.getElementById('toggleScoringBtn');
                    var scoringCard = document.getElementById('scoringCard');
                    var scoringBody = document.getElementById('scoringBody');
                    if (toggleBtn && scoringCard && scoringBody) {
                        var expanded = scoringCard.classList.contains('scoring-open');
                        toggleBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                        toggleBtn.textContent = expanded ? '隱藏計分說明' : '顯示計分說明';
                        toggleBtn.addEventListener('click', function() {
                            expanded = !expanded;
                            scoringCard.classList.toggle('scoring-open', expanded);
                            toggleBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                            toggleBtn.textContent = expanded ? '隱藏計分說明' : '顯示計分說明';
                        });
                    }
                } catch (e) {
                    console.warn('scoring toggle init failed', e);
                }

                // 無障礙：對話框焦點管理與 Esc 關閉
                try {
                    const modals = ['confirmBackModal','playerNameModal'];
                    const focusableSel = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex]';
                    modals.forEach(id => {
                        const modal = document.getElementById(id);
                        if (!modal) return;
                        // 開啟時設定 aria-hidden、聚焦到標題或第一個可聚焦元素
                        const open = () => {
                            modal.setAttribute('aria-hidden','false');
                            const title = modal.querySelector('#'+(id==='confirmBackModal'?'confirmBackTitle':'playerNameModalTitle'));
                            const focusables = modal.querySelectorAll(focusableSel);
                            const first = focusables && focusables[0];
                            setTimeout(() => { (title || first || modal).focus({preventScroll:true}); }, 0);
                        };
                        const close = () => {
                            modal.setAttribute('aria-hidden','true');
                        };
                        // 觀察 hidden class 切換以呼叫 open/close
                        const obs = new MutationObserver(() => {
                            const hidden = modal.classList.contains('hidden');
                            if (!hidden) open(); else close();
                        });
                        obs.observe(modal, { attributes:true, attributeFilter:['class'] });

                        // Esc 關閉（playerNameModal 僅在非查看模式可關閉）
                        modal.addEventListener('keydown', (e) => {
                            if (e.key === 'Escape') {
                                if (id === 'confirmBackModal') {
                                    document.getElementById('cancelBackBtn')?.click();
                                } else if (id === 'playerNameModal') {
                                    const viewing = modal.dataset.viewingRecord === 'true';
                                    if (!viewing) document.getElementById('confirmNameBtn')?.click();
                                }
                            }
                        });
                    });
                } catch (e) { /* ignore a11y wiring errors */ }

                // 延後：優先嘗試載入外部經文資料，成功後再初始化跑馬燈（失敗則採用內建資料）
                try {
                    const kickoff = () => {
                        try { initializeVerseMarquee(); } catch(e){}
                        // 若已初始化，之後資料更新則只刷新內容，不重建 DOM
                        try { refreshVerseMarqueeData(); } catch(e){}
                    };
                    const loader = () => {
                        if (ENABLE_EXTERNAL_VERSES) {
                            attemptLoadExternalVerses().finally(kickoff);
                        } else {
                            // 直接使用內建資料
                            kickoff();
                        }
                    };
                    if ('requestIdleCallback' in window) {
                        window.requestIdleCallback(loader);
                    } else {
                        setTimeout(loader, 120);
                    }
                } catch(e){}
            });
        </script>
        <script>
            // Register a simple service worker to cache startup images and core assets for faster repeat visits
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', function() {
                    navigator.serviceWorker.register('sw.js', { scope: './' }).catch(function(_){});
                });
            }
        </script>
    </body>
    </html>
