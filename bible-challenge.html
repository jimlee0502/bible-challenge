<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>經夠盃挑戰</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <!-- Fallback preloads for both logo/word variants to mitigate late paint on slow networks -->
    <link rel="preload" as="image" href="logo/logo1-light.png" imagesrcset="logo/logo1-light.png" />
    <link rel="preload" as="image" href="logo/logo2-light.png" imagesrcset="logo/logo2-light.png" />
    <link rel="preload" as="image" href="logo/logo1-dark.png" imagesrcset="logo/logo1-dark.png" />
    <link rel="preload" as="image" href="logo/logo2-dark.png" imagesrcset="logo/logo2-dark.png" />
    <link rel="preload" as="image" href="logo/word1-light.png" imagesrcset="logo/word1-light.png" />
    <link rel="preload" as="image" href="logo/word2-light.png" imagesrcset="logo/word2-light.png" />
    <link rel="preload" as="image" href="logo/word1-dark.png" imagesrcset="logo/word1-dark.png" />
    <link rel="preload" as="image" href="logo/word2-dark.png" imagesrcset="logo/word2-dark.png" />
    <script>
        // Pre-pick and preload startup images as early as possible to avoid late appearance on slow networks.
        (function(){
            try {
                var pick = Math.ceil(Math.random() * 4); // 1..4
                window.__startupPick = pick;
                var isDark = (pick === 1 || pick === 2);
                var base = 'logo/';
                var logoSrc = isDark
                    ? (pick === 1 ? base + 'logo1-light.png' : base + 'logo2-light.png')
                    : (pick === 3 ? base + 'logo1-dark.png'  : base + 'logo2-dark.png');
                var wordSrc = isDark
                    ? (pick === 1 ? base + 'word1-light.png' : base + 'word2-light.png')
                    : (pick === 3 ? base + 'word1-dark.png'  : base + 'word2-dark.png');
                window.__startupLogoSrc = logoSrc;
                window.__startupWordSrc = wordSrc;
                window.__startupIsDark = isDark;
                // Inject preload hints for the chosen pair
                var l1 = document.createElement('link');
                l1.rel = 'preload'; l1.as = 'image'; l1.href = logoSrc; l1.setAttribute('fetchpriority','high');
                document.head.appendChild(l1);
                var l2 = document.createElement('link');
                l2.rel = 'preload'; l2.as = 'image'; l2.href = wordSrc; l2.setAttribute('fetchpriority','high');
                document.head.appendChild(l2);
            } catch (e) { /* ignore */ }
        })();
    </script>
    <!-- Online leaderboard support (optional): Supabase client + user-provided config -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- If you create bible-challenge/leaderboard-config.js with your keys, it will be loaded next; this file may not exist locally, which is okay. -->
    <script src="leaderboard-config.js"></script>
    <style>
        * {
            font-family: 'Noto Sans TC', sans-serif;
        }

        /* Desktop: arrange verse/chapter lists horizontally (row, wrap) so buttons appear side-by-side */
        @media (min-width: 761px) {
            .verses-list, .chapter-list {
                display: flex !important;
                flex-direction: row !important;
                flex-wrap: wrap !important;
                gap: 0.75rem !important;
                align-items: flex-start !important;
                justify-content: center !important; /* center rows when fewer than 3 items or last row */
                padding-left: 0 !important;
                padding-right: 0 !important;
            }

            /* Desktop - make panel titles and lists more compact so content fits without scrolling */
            #verseTitle, #chapterTitle {
                /* reduce large letter-spacing used for stylistic titles to save horizontal/vertical space */
                letter-spacing: 0.06em !important;
                margin-bottom: 0.15rem !important;
                line-height: 1.02 !important;
                /* slightly reduce font-size on wide screens for denser layout while keeping readability */
                font-size: clamp(1.6rem, 1.8vw, 2.4rem) !important;
                white-space: nowrap !important; /* keep the short title on one line */
            }

            /* Slightly tighten spacing inside panels and lists on desktop */
            .panel { padding: 0.6rem !important; }
            .panel .panel-title { margin-bottom: 0.1rem !important; padding-top: 0.25rem !important; padding-bottom: 0.25rem !important; }
            .verses-list, .chapter-list { gap: 0.5rem !important; }

            /* Make verse / chapter cards slightly denser on desktop to reduce overall height */
            .verses-list .verse-card, .chapter-list .chapter-card { padding: 0.6rem 0.85rem !important; min-height: 48px !important; }

            /* Ensure cards keep their JS-assigned widths (w-48, w-56, etc.) and don't expand to full width */
            /* Force up to 3 items per row: each card gets ~1/3 width minus gaps and is centered by the parent */
            .verses-list .verse-card, .chapter-list .chapter-card {
                display: inline-flex !important;
                flex: 0 0 calc((100% - 1.5rem) / 3) !important; /* two gaps of 0.75rem => 1.5rem total */
                max-width: calc((100% - 1.5rem) / 3) !important;
                width: auto !important;
                padding: 0.75rem 1rem !important;
                box-sizing: border-box !important;
            }

            /* keep panel padding reasonable on desktop */
            .panel { padding: 1rem !important; }
        }

        /* Desktop: remove the pale focus outline for main menu buttons/options (mouse click effect)
           Keep keyboard focus-visible intact elsewhere; scope to #startScreen to avoid harming in-game accessibility. */
        @media (min-width: 761px) {
            #startScreen .cute-button:focus,
            #startScreen .cute-button:focus-visible,
            #startScreen .cute-button:active,
            #startScreen .difficulty-option:focus,
            #startScreen .range-option:focus {
                outline: none !important;
                outline-offset: 0 !important;
                /* keep the existing shadow instead of the pale outline */
                box-shadow: 0 8px 24px rgba(2,6,23,0.08) !important;
            }
        }

    /* Unified spacing for scoring remarks lines (denser) */
    .scoring-remarks > div { margin-bottom: 0.2rem; line-height: 1.05; }
    .scoring-remarks > div:last-child { margin-bottom: 0; }

        /* Also remove the pale focus outline on mobile start screen (same behavior across devices) */
        #startScreen .cute-button:focus,
        #startScreen .cute-button:focus-visible,
        #startScreen .cute-button:active,
        #startScreen .difficulty-option:focus,
        #startScreen .range-option:focus {
            outline: none !important;
            outline-offset: 0 !important;
            box-shadow: 0 8px 24px rgba(2,6,23,0.08) !important;
        }
        
        .cute-button {
            transition: all 0.3s ease;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .cute-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .cute-card {
            border-radius: 25px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.1);
            background-color: rgba(255, 255, 255, 1) !important;
        }
        
        .difficulty-option, .range-option {
            background-color: rgba(255, 255, 255, 1) !important;
        }
        /* stronger hover / active / selected emphasis for difficulty cards */
    .difficulty-option {
            transition: transform 0.22s ease, box-shadow 0.22s ease, border-color 0.18s ease;
        }
        .difficulty-option:hover {
            transform: translateY(-6px) scale(1.02);
            box-shadow: 0 18px 45px rgba(0,0,0,0.16) !important;
            z-index: 10;
        }
        .difficulty-option:active {
            transform: translateY(-2px) scale(0.995);
        }
        .difficulty-option.selected {
            transform: translateY(-4px) scale(1.03);
            box-shadow: 0 20px 50px rgba(0,0,0,0.18) !important;
            border-width: 4px !important;
        }
        .difficulty-option:focus {
            outline: 3px solid rgba(96,165,250,0.35);
            outline-offset: 4px;
        }

        /* Ensure selected difficulty/range buttons always show a 4px colored border (explicit) */
        #startScreen .difficulty-option.selected[data-difficulty="easy"] {
            border: 4px solid #16a34a !important; /* green-600 */
        }
        #startScreen .difficulty-option.selected[data-difficulty="normal"] {
            border: 4px solid #d97706 !important; /* yellow-600 */
        }
        #startScreen .difficulty-option.selected[data-difficulty="hard"] {
            border: 4px solid #dc2626 !important; /* red-600 */
        }

        /* range buttons */
        #startScreen .range-option.selected[data-range="all"] {
            border: 4px solid #7c3aed !important; /* purple-600 */
        }
        #startScreen .range-option.selected[data-range="testament"] {
            border: 4px solid #2563eb !important; /* blue-600 */
        }
        #startScreen .range-option.selected[data-range="custom"] {
            border: 4px solid #ea580c !important; /* orange-600 */
        }
        .difficulty-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem 0.5rem;
            align-items: center;
            font-size: 0.85rem; /* slightly smaller for compactness */
        }
        .difficulty-badges .rounded-full {
            padding: 0.2rem 0.5rem;
            white-space: nowrap;
            min-width: auto;
            text-align: center;
            line-height: 1.1;
        }

        /* Desktop: evenly distribute difficulty badges into 3 equal columns */
        @media (min-width: 768px) {
            #startScreen .difficulty-option .difficulty-badges {
                display: grid !important;
                grid-template-columns: repeat(3, minmax(0, 1fr));
                align-items: center;
                justify-items: stretch;
                gap: 0.5rem 0.75rem;
            }
            #startScreen .difficulty-option .difficulty-badges .rounded-full {
                width: 100%;
            }
        }
        /* range-option styling for 出題範圍 (match difficulty card style; colors unchanged) */
        .range-option {
            transition: transform 0.22s ease, box-shadow 0.22s ease, border-color 0.18s ease;
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.6rem;
            min-height: 56px;
            padding: 0.6rem 0.9rem;
            overflow: hidden;
            text-align: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
        }
        .range-option .label {
            display: inline-block;
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 12rem;
            width: 100%;
            text-align: center;
            letter-spacing: 0.12em;
            word-spacing: 0.12em;
        }
        .range-option:hover {
            transform: translateY(-6px) scale(1.02);
            box-shadow: 0 18px 45px rgba(0,0,0,0.16) !important;
            z-index: 10;
        }
        .range-option:active {
            transform: translateY(-2px) scale(0.995);
        }
        .range-option.selected {
            transform: translateY(-4px) scale(1.03);
            box-shadow: 0 20px 50px rgba(0,0,0,0.18) !important;
            border-width: 4px !important;
        }
        .range-option:focus {
            outline: 3px solid rgba(96,165,250,0.35);
            outline-offset: 4px;
        }
        .range-badges { display: flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.35rem; }
        .range-badges .rounded-full { padding:0.35rem 0.6rem; font-size:0.85rem; }

        /* responsive: allow labels to wrap on very small screens */
        @media (max-width: 420px) {
            .range-option { min-height: 48px; padding: 0.6rem; }
            .range-option .label { white-space: normal; max-width: 100%; font-size: 0.95rem; letter-spacing: 0.08em; }
        }

    /* Hide the small mobile-only difficulty hints by default (desktop) */
    #startScreen .difficulty-option .difficulty-hint { display: none; }

        /* Normalize difficulty option sizes on small screens so each button appears equal */
        @media (max-width: 640px) {
            #startScreen .difficulty-option .text-3xl { font-size: 1.6rem !important; line-height: 1 !important; }
            #startScreen .difficulty-option .text-lg { font-size: 0.95rem !important; margin-top: 0.12rem !important; }
            #startScreen .difficulty-option { padding: 0.45rem 0.5rem !important; }
            /* Ensure the icon container is same size across options */
            #startScreen .difficulty-option > div > .col-span-1 { flex-basis: 44px !important; min-width:44px !important; display:flex; align-items:center; justify-content:center; }
            /* small hint under each difficulty button (visible on mobile compact layout) */
            #startScreen .difficulty-option .difficulty-hint { display: none; }
        }
        
        .verse-card {
            transition: all 0.3s ease;
            border-radius: 15px;
            cursor: pointer;
            position: relative; /* allow absolutely-positioned overlays like the ref label */
        }

        /* Easy-mode reference label: overlay at the bottom of the verse card without affecting layout */
        .verse-ref-label {
            position: absolute;
            right: 10px; /* 靠右一點 */
            bottom: 6px;
            /* subtle readable chip */
            background: rgba(255,255,255,0.75);
            -webkit-backdrop-filter: saturate(120%) blur(2px);
            backdrop-filter: saturate(120%) blur(2px);
            padding: 2px 8px;
            border-radius: 9999px;
            line-height: 1;
            pointer-events: none; /* decorative only */
            z-index: 5;
            white-space: nowrap;
            max-width: calc(100% - 1.4rem);
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 0 !important; /* ignore any margin classes when overlaid */
        }

        /* Mobile comfort adjustments */
    @media (max-width: 640px) {
            html, body { -webkit-text-size-adjust: 100%; }

            /* Bigger tappable buttons */
            .cute-button {
                padding: 0.9rem 1rem !important;
                min-height: 48px !important;
                font-size: 1rem !important;
                border-radius: 14px !important;
            }

            /* Slightly smaller card radius and lighter shadows for mobile performance */
            .cute-card {
                    border-radius: 12px !important;
                    box-shadow: 0 10px 30px rgba(16,24,40,0.06) !important;
            }

            /* Make modals full-screen and scrollable on small devices */
            #playerNameModal .cute-card,
            #clearLeaderboardModal .cute-card,
            #customBooksModal .cute-card,
            #confirmBackModal .cute-card {
                width: 100% !important;
                max-width: none !important;
                height: 100% !important;
                max-height: none !important;
                border-radius: 0 !important;
                margin: 0 !important;
                padding: 1rem !important;
                box-shadow: none !important;
                border-left: none !important;
                border-right: none !important;
                overflow-y: auto !important;
            }

            /* Reduce heavy decorative animations/particles that affect performance, but keep the background marquee visible on mobile */
            .confetti, .party-popper, .celebration-popup { display: none !important; }

            /* Mobile: hide scoring details but provide a toggle to expand them */
            #scoringCard .scoring-body { display: block !important; }
            #toggleScoringBtn { display: none !important; }
            @media (max-width: 420px) {
                /* show compact, pretty toggle on very small screens */
                #toggleScoringBtn { 
                    display: inline-flex !important; align-items: center; gap: 10px;
                    background: linear-gradient(180deg, rgba(107,114,128,0.06), rgba(156,163,175,0.06)); /* gray-500 -> gray-400 */
                    border: 1px solid rgba(107,114,128,0.28); /* gray-500 */
                    padding: 10px 14px; border-radius: 9999px; color: #374151; /* gray-700 */ font-size: 0.95rem;
                    box-shadow: 0 8px 22px rgba(2,6,23,0.07);
                    -webkit-backdrop-filter: saturate(140%) blur(6px);
                    backdrop-filter: saturate(140%) blur(6px);
                    transition: background-color .18s ease, box-shadow .18s ease, transform .12s ease;
                }
                #toggleScoringBtn:active { transform: scale(0.985); }
                #toggleScoringBtn:focus-visible { outline: 3px solid rgba(107,114,128,0.28); outline-offset: 3px; }
                #toggleScoringBtn .chev { transition: transform .18s ease; font-size: .95em; opacity: .9; }
                #scoringCard:not(.scoring-open) .scoring-body { display: none !important; }
                #scoringCard.scoring-open #toggleScoringBtn { background: rgba(107,114,128,0.08) !important; }
                #scoringCard.scoring-open #toggleScoringBtn .chev { transform: rotate(180deg); }

                /* End modal: make closing-verse text smaller to reduce scrolling */
                #playerNameModal #closingVerseText { font-size: 0.98rem !important; line-height: 1.55 !important; }
                #playerNameModal #closingVerse { padding: 0.6rem !important; }
            }

            /* Slightly larger verse cards and touch area */
            .verse-card, .chapter-card {
                min-height: 64px;
                padding: 0.75rem;
            }

            /* unified button style for clarity */
            .cute-button {
                box-shadow: 0 8px 24px rgba(2,6,23,0.08) !important;
                transition: transform 160ms ease, box-shadow 160ms ease !important;
            }

            .cute-button:active {
                transform: translateY(1px) scale(0.998) !important;
                box-shadow: 0 6px 18px rgba(2,6,23,0.06) !important;
            }

            /* focus-visible for keyboard users on mobile (accessibility) */
            .cute-button:focus-visible {
                outline: 3px solid rgba(99,102,241,0.22) !important;
                outline-offset: 4px !important;
            }

            /* Restore thin pale borders for unselected difficulty/range options on mobile (overrides .cute-button { border: none !important }) */
            #startScreen .difficulty-option:not(.selected),
            #startScreen .range-option:not(.selected) {
                border-style: solid !important;
                border-width: 2px !important;
                /* keep the color provided by utility classes (border-*-300) so the pale tint remains */
            }

            /* Mobile: single-column game area and larger interactive regions (scoped to startScreen only) */
            #startScreen .grid, #startScreen .game-area, #startScreen .game-controls {
                display: block !important;
                width: 100% !important;
                padding: 0 0.5rem !important;
            }

            /* Compact mobile: stack difficulty options vertically as thin horizontal strips (three rows)
               Each button is full-width, single row layout with icon on the left and label + hint on the right.
               This is mobile-only and does not affect desktop layout. */
            #startScreen .cute-card > .space-y-3 {
                display: flex !important;
                flex-direction: column !important;
                gap: 0.6rem !important;
                align-items: stretch !important;
                justify-content: flex-start !important;
            }

            #startScreen .cute-card > .space-y-3 .difficulty-option {
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                justify-content: flex-start !important;
                width: 100% !important;
                padding: 0.35rem 0.6rem !important;
                height: 56px !important;
                min-height: 56px !important;
                max-height: 56px !important;
                box-sizing: border-box !important;
                gap: 0.75rem !important;
                border-radius: 12px !important;
                box-shadow: 0 6px 18px rgba(0,0,0,0.05) !important;
            }

            /* keep compact badges visible in mobile strip layout */
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-badges {
                display: flex !important;
            }

            /* Layout the original grid children as horizontal content: left icon area and main label area */
            #startScreen .cute-card > .space-y-3 .difficulty-option .grid {
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                width: 100% !important;
                gap: 0.75rem !important;
            }

            /* left icon column — fixed width */
            #startScreen .cute-card > .space-y-3 .difficulty-option > .grid > .col-span-1 {
                flex: 0 0 52px !important;
                min-width: 52px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
            }

            /* main content area */
            #startScreen .cute-card > .space-y-3 .difficulty-option > .grid > .col-span-4 {
                flex: 1 1 auto !important;
                display: flex !important;
                flex-direction: column !important;
                align-items: flex-start !important;
                justify-content: center !important;
                padding-right: 0.5rem !important;
            }

            /* icon and label sizing for consistency */
            #startScreen .cute-card > .space-y-3 .difficulty-option .text-3xl { font-size: 1.4rem !important; line-height: 1 !important; }
            #startScreen .cute-card > .space-y-3 .difficulty-option .text-lg { font-size: 0.95rem !important; margin-top: 0 !important; }

            /* place the small hint inline under the label but keep it subtle */
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-hint {
                display: inline-block !important;
                font-size: 0.8rem !important;
                margin-top: 2px !important;
                opacity: 0.9 !important;
            }

            /* Mobile-only: show a large right-aligned difficulty hint (e.g., 配對經文) */
            #startScreen .difficulty-mobile-strip { display: none !important; }
            #startScreen .cute-card > .space-y-3 .difficulty-option .mobile-rarity { white-space: nowrap !important; }
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-hint {
                display: block !important;
                position: absolute !important;
                right: 0.85rem !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                margin: 0 !important;
                font-weight: 800 !important;
                letter-spacing: 0.08em !important;
                white-space: nowrap !important;
                text-align: right !important;
                max-width: 48% !important; /* prevent overflow on very small screens */
                /* responsive size: bigger on mobile but not overwhelming */
                font-size: clamp(1.05rem, 4.6vw, 1.35rem) !important;
                color: rgba(31,41,55,0.9) !important; /* default gray, overridden per difficulty below */
                text-shadow: 0 1px 0 rgba(255,255,255,0.6) !important;
                pointer-events: none !important;
                z-index: 32 !important;
            }
            /* Color the big hint to match each difficulty */
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="easy"] .difficulty-hint { color: #047857 !important; /* green-700 */ }
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="normal"] .difficulty-hint { color: #b45309 !important; /* amber-700 */ }
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="hard"] .difficulty-hint { color: #b91c1c !important; /* red-700 */ }

            /* Show the strip in the mobile stacked layout */
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-mobile-strip {
                display: block !important;
                width: 100% !important;
                padding: 0.45rem !important;
                border-radius: 12px !important;
                background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.4)) !important;
                box-shadow: 0 6px 18px rgba(2,6,23,0.04) !important;
            }

            /* ensure difficulty-option and its strip sit above nearby cute-card backgrounds on mobile */
            #startScreen .cute-card > .space-y-3 .difficulty-option {
                position: relative !important;
                z-index: 30 !important; /* above the parent cute-card but below modals */
                /* reserve space on the right for the big label 配對ＸＸ */
                padding-right: clamp(4.5rem, 28vw, 9rem) !important;
            }
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-mobile-strip {
                position: relative !important;
                z-index: 31 !important; /* make the strip visually above the tile edges */
            }

            /* adjust inner strip layout */
            #startScreen .difficulty-mobile-strip .mobile-strip-icon { width: 36px; display: inline-flex; align-items: center; justify-content: center; opacity: 0.95; }
            /* keep the original icon area visible */
            /* (previous override that hid .col-span-1 removed) */

            #startScreen .difficulty-mobile-strip .mobile-strip-content { display: flex; align-items: center; gap: 0.5rem; width: 100%; }
            #startScreen .difficulty-mobile-strip .mobile-strip-left { display: flex; flex-direction: column; }
            #startScreen .difficulty-mobile-strip .mobile-strip-right { display: flex; align-items: center; }

            /* per-difficulty strip tints (subtle) */
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="easy"] .difficulty-mobile-strip {
                background: linear-gradient(180deg, rgba(236,253,245,0.9), rgba(255,255,255,0.55)) !important;
            }
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="normal"] .difficulty-mobile-strip {
                background: linear-gradient(180deg, rgba(255,250,235,0.9), rgba(255,255,255,0.55)) !important;
            }
            #startScreen .cute-card > .space-y-3 .difficulty-option[data-difficulty="hard"] .difficulty-mobile-strip {
                background: linear-gradient(180deg, rgba(255,244,244,0.9), rgba(255,255,255,0.55)) !important;
            }

            /* better spacing for labels */
            #startScreen .difficulty-mobile-strip .mobile-label { font-size: 0.98rem !important; }
            #startScreen .difficulty-mobile-strip .mobile-hint { font-size: 0.78rem !important; color: rgba(31,41,55,0.65) !important; }
            #startScreen .difficulty-mobile-strip .mobile-rarity { font-size: 0.72rem !important; opacity: 0.95 !important; }

            /* On mobile, hide the middle badge line (配對經文/書卷/章節) to avoid duplication with the large right label */
            #startScreen .cute-card > .space-y-3 .difficulty-option .difficulty-badges > div:nth-child(2) { display: none !important; }

            /* ensure the cute-card itself doesn't force extra vertical stacking for difficulty area */
            #startScreen .cute-card.bg-white.p-6 { padding-bottom: 0.5rem !important; }

            /* Add vertical spacing between the white info cards on the start screen for better separation on mobile */
            #startScreen .cute-card {
                margin-bottom: 0.9rem !important;
            }

            /* Defensive: if the start screen is visible, ensure the game screen is hidden to avoid scrolling into it.
               Use the general sibling selector so the rule still applies when modals or other elements are between them. */
            #startScreen:not(.hidden) ~ #gameScreen {
                display: none !important;
                visibility: hidden !important;
                pointer-events: none !important;
            }

            /* Verse cards become full-width tappable rows */
            .verse-card {
                display: flex !important;
                align-items: center !important;
                justify-content: space-between !important;
                width: 100% !important;
                margin-bottom: 0.6rem !important;
                padding: 0.9rem !important;
                font-size: 1.05rem !important;
                touch-action: manipulation !important;
                /* reserve a little space at the bottom so the overlaid ref-label won't cover text */
                padding-bottom: calc(0.9rem + 1.1rem) !important;
            }

            /* Title container adjustments for small screens: allow wrapping and reduce spacing */
            .title-container {
                display: block !important;
                width: 100% !important;
                padding: 0.8rem 1rem !important;
                overflow: visible !important;
                border-radius: 12px !important;
            }

            /* Compact labels and improved button style for difficulty and range cards on mobile */
            #difficultyCard h2, #rangeCard h2 {
                font-size: 1.25rem !important;
                letter-spacing: 0.03em !important;
                margin-bottom: 0.6rem !important;
            }
            /* Make the range buttons visually tighter and unified on mobile */
            #rangeCard .range-option {
                padding: 0.6rem !important;
                border-radius: 12px !important;
                font-size: 0.95rem !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                gap: 0.5rem !important;
                box-shadow: 0 6px 18px rgba(2,6,23,0.04) !important;
            }

            /* differentiate the practice/testament options with subtle tint and smaller badges */
            #rangeCard .range-option .label { font-weight: 700 !important; }
            #rangeCard .range-option.selected { box-shadow: 0 10px 28px rgba(0,0,0,0.08) !important; transform: translateY(-2px) !important; }
            #rangeCard .range-option .label { padding: 0.2rem 0.4rem !important; border-radius: 8px !important; }

            #startScreen h1 {
                font-size: 1.6rem !important;
                line-height: 1.05 !important;
                letter-spacing: 0.04em !important;
                white-space: normal !important;
                text-shadow: 0 0 8px rgba(255,255,255,0.4) !important;
                padding: 0.1rem 0.2rem !important;
                display: block !important;
                word-break: keep-all !important;
            }

            /* make the little emoji icons slightly smaller to avoid wrapping issues */
            #titleLeftIcon, #titleRightIcon { font-size: 1.1rem !important; margin: 0 .25rem !important; }

            /* --- Mobile: force entire game screen to fit within one viewport --- */
            #gameScreen {
                height: 100vh !important;
                padding: 0.3rem !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: space-between !important;
                overflow: hidden !important;
            }

            /* Make the main content area grow to fill the available space so the carousel can use full height */
            #gameScreen > .max-w-7xl {
                margin: 0 !important;
                padding: 0.25rem !important;
                max-width: 100% !important;
                display: flex !important;
                flex-direction: column !important;
                flex: 1 1 auto !important;
                overflow: hidden !important; /* panels manage their own internal scrolling */
            }

            /* Let the carousel and panels grow to fill the middle area */
            .verses-carousel {
                flex: 1 1 auto !important;
                display: flex !important;
                overflow-x: auto !important;
            }
            .verses-carousel .panel {
                display: flex !important;
                flex-direction: column !important;
                height: 100% !important;
                overflow-y: auto !important; /* allow the content inside each panel to scroll vertically */
                padding-top: 0.4rem !important; /* reduce extra top space above titles */
                padding-bottom: 0.6rem !important; /* small internal bottom padding */
            }

            /* Ensure the lists inside panels have safe bottom padding so the last item is reachable above pinned controls */
            .verses-list, .chapter-list {
                padding-bottom: calc(4.5rem + env(safe-area-inset-bottom, 0px)) !important; /* provide space for pinned controls */
                overflow-y: auto !important;
            }

            /* Extra small spacer element at the end of lists if needed (keeps last card tappable) */
            .verses-list::after, .chapter-list::after { content: ''; display: block; height: 0.8rem; }

            /* Hide non-essential info on mobile to ensure the gameplay fits in one viewport.
               Keep level progress, hint and back buttons visible per request. */
            #questionProgressCard, #gameInfoSettings, #gameInfoCard {
                display: none !important;
                visibility: hidden !important;
                height: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
                overflow: hidden !important;
            }

            /* Ensure level progress card stays visible but compact */
            #levelProgressCard {
                display: block !important;
                padding: 0.5rem !important;
                margin-bottom: 0.35rem !important;
            }

            /* Pin controls (hint + back) to the bottom for easy reach without hiding them */
            #gameControlsPinned {
                position: fixed !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                z-index: 9999 !important;
                padding: 0.5rem !important;
                background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.9)) !important;
                backdrop-filter: blur(6px) !important;
                box-shadow: 0 -6px 24px rgba(2,6,23,0.06) !important;
            }

            /* Keep hint and back buttons large and side-by-side inside the pinned controls */
            #gameControlsPinned .cute-button {
                width: 48% !important;
                display: inline-block !important;
                font-size: 1rem !important;
                padding: 0.7rem 0.9rem !important;
            }

            /* Mobile: make the hint/back buttons horizontal (icon + text inline), same-height and more compact */
            @media (max-width: 640px) {
                #gameControlsPinned { padding: 0.35rem !important; }
                #gameControlsPinned .cute-button {
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    flex-direction: row !important;
                    gap: 0.4rem !important;
                    height: 44px !important; /* uniform height */
                    padding: 0 0.6rem !important; /* horizontal padding only */
                    font-size: 0.95rem !important;
                    width: 48% !important;
                    white-space: nowrap !important;
                }

                /* Ensure the inline content inside the button stays on one line */
                #gameControlsPinned .cute-button > span { display: inline-flex !important; align-items: center !important; gap: 0.4rem !important; flex-direction: row !important; white-space: nowrap !important; }

                /* Shrink the hint-count badge to match button height */
                #hintCount {
                    height: 36px !important;
                    min-width: 36px !important;
                    padding: 0 0.6rem !important;
                    display: inline-flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    font-size: 0.88rem !important;
                }

                /* Slightly reduce pinned area vertical footprint */
                #gameControlsPinned { background: linear-gradient(180deg, rgba(255,255,255,0.66), rgba(255,255,255,0.92)) !important; }
            }

            /* Reduce margins around verse/chapter areas to save vertical space */
            .max-w-7xl.mx-auto.mb-6.relative.z-10 { margin-bottom: 0.25rem !important; padding: 0 !important; }
            .p-8.relative.overflow-hidden { padding: 0.5rem !important; }

            /* Reduce top info area and make it compact */
            #gameScreen > .max-w-7xl {
                margin: 0 !important;
                padding: 0.25rem !important;
                max-width: 100% !important;
            }

            /* compact the three-column header into a vertical stack that fits */
            #gameScreen .flex.items-center.justify-between.gap-6 {
                display: flex !important;
                flex-direction: column !important;
                gap: 0.5rem !important;
                align-items: stretch !important;
            }

            /* Reduce whitespace above panel titles and make titles compact */
            .panel-title { margin: 0.15rem 0 0.25rem 0 !important; padding: 0 !important; }
            .panel .mb-8 { margin-bottom: 0.3rem !important; }

            /* shrink score panel and allow it to scale responsively */
            #gameScreen .cute-card[style*="min-w"] {
                min-width: auto !important;
                padding: 0.6rem !important;
            }

            #centerScore {
                font-size: clamp(2.2rem, 10vw, 3.6rem) !important;
                line-height: 1 !important;
            }

            /* reduce progress card sizes and paddings */
            #gameScreen .cute-card.p-5, #gameScreen .cute-card.p-4 {
                padding: 0.5rem !important;
            }

            /* compress titles and verse/chapter areas */
            #verseTitle, #chapterTitle {
                font-size: clamp(1rem, 4.5vw, 1.4rem) !important;
                margin-bottom: 0.35rem !important;
                letter-spacing: 0.06em !important;
            }

            /* make verse and chapter containers smaller and ensure cards wrap compactly */
            #gameVerses, #gameChapters {
                gap: 6px !important;
                justify-content: center !important;
            }

            .verse-card {
                padding: 0.5rem !important;
                min-height: 44px !important;
                font-size: 0.95rem !important;
            }

            /* controls area pinned at bottom and easy to tap */
            #gameScreen .cute-card.bg-white\/60.rounded-xl.p-3.border {
                padding: 0.45rem !important;
            }

            /* ensure control buttons are large and full-width on mobile */
            .cute-card .cute-button, .cute-card button.cute-button {
                padding: 0.7rem 0.9rem !important;
                font-size: 1rem !important;
            }

            /* hide oversized decorative fixed icons to free space */
            #gameScreen .fixed.inset-0.pointer-events-none.z-0 { display: none !important; }

            /* reduce modal/popup sizes if they appear during gameplay */
            .cute-card.max-w-2xl { max-width: 92% !important; padding: 0.8rem !important; }

            /* Choice / answer buttons larger and more touch-friendly */
            .choice-button, .choice-btn, .answer-btn {
                width: 100% !important;
                display: block !important;
                padding: 0.95rem 1rem !important;
                font-size: 1.05rem !important;
                border-radius: 12px !important;
                margin-bottom: 0.6rem !important;
                touch-action: manipulation !important;
            }

            /* Start button full width and large on mobile */
            #startGameBtn {
                font-size: 1.25rem !important;
                padding: 1rem 1.25rem !important;
                border-radius: 14px !important;
            }

            /* Leaderboard: ensure comfortable spacing and readable font sizes */
            #leaderboardList > div { padding: 0; }
            #leaderboardList .bg-white { padding: 0.75rem !important; }

            /* Compact typography inside leaderboard cards to fit more info without changing card size */
            .leaderboard-compact .text-lg { line-height: 1.05 !important; }
            .leaderboard-compact .text-sm { line-height: 1 !important; }
            .leaderboard-compact .truncate { white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; }
            #leaderboardList .bg-white { display: flex; align-items: center; }

            /* remove hover-only effects that interfere with touch */
            .cute-button:hover, .difficulty-option:hover, .range-option:hover { transform: none !important; box-shadow: 0 6px 18px rgba(0,0,0,0.06) !important; }

            /* easier-to-tap leaderboard tabs */
            .leaderboard-tab { padding: 0.6rem 0.9rem; font-size: 0.95rem; }
        }

        /* Leaderboard cards — redesigned for clearer rank styling and responsiveness */
        /* Base card */
        #leaderboardList .leaderboard-card {
            position: relative;
            background: #ffffff;
            border: 2px solid #e5e7eb; /* gray-200 */
            border-radius: 14px;
            padding: 0.85rem 0.95rem; /* default padding (mobile-first) */
            box-shadow: 0 6px 18px rgba(0,0,0,0.06);
            transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
            display: block !important; /* override any generic .bg-white flex rules */
            overflow: hidden;
        }
        #leaderboardList .leaderboard-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 35px rgba(0,0,0,0.10);
        }
        /* Rank ribbon (desktop) / chip (mobile) */
        #leaderboardList .leaderboard-card .lb-rank-ribbon {
            position: absolute;
            left: 0.5rem;
            top: 0.5rem;
            width: 2.6rem;
            height: calc(100% - 1rem);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            color: #111827; /* gray-900 */
            user-select: none;
        }
        #leaderboardList .leaderboard-card .lb-rank-ribbon span {
            writing-mode: horizontal-tb; /* keep numbers upright on desktop */
            transform: none;
            letter-spacing: 0.06em;
        }
        /* Content body */
        #leaderboardList .leaderboard-card .lb-card-body {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        @media (min-width: 640px) { /* sm+ add left padding to accommodate ribbon */
            #leaderboardList .leaderboard-card { padding-left: 3.75rem; }
        }
        #leaderboardList .leaderboard-card .lb-top-row { display: flex; align-items: baseline; gap: 0.5rem; }
        #leaderboardList .leaderboard-card .lb-score { font-size: 1.35rem; font-weight: 900; color: #111827; line-height: 1; }
        #leaderboardList .leaderboard-card .lb-score .unit { font-size: 0.7rem; font-weight: 600; margin-left: 2px; color: #6b7280; }
        #leaderboardList .leaderboard-card .lb-name { font-size: 0.95rem; font-weight: 700; color: #374151; min-width: 0; }
        #leaderboardList .leaderboard-card .lb-name .truncate { display: block; max-width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #leaderboardList .leaderboard-card .lb-meta { font-size: 0.72rem; color: #9ca3af; }
        #leaderboardList .leaderboard-card .lb-pill { font-size: 0.72rem; padding: 0.15rem 0.5rem; border-radius: 9999px; font-weight: 800; display: inline-block; }
        #leaderboardList .leaderboard-card .lb-medal { position: absolute; top: 0.4rem; right: 0.5rem; font-size: 1.15rem; line-height: 1; }

        /* Rank themes (ribbon + subtle border accent) */
        #leaderboardList .leaderboard-card.rank-1 { border-color: #f59e0b; /* amber-600 */ }
        #leaderboardList .leaderboard-card.rank-2 { border-color: #9ca3af; /* gray-400 */ }
        #leaderboardList .leaderboard-card.rank-3 { border-color: #b45309; /* amber-800 */ }

        #leaderboardList .leaderboard-card.rank-1 .lb-rank-ribbon { background: linear-gradient(180deg,#fde68a,#f59e0b); color:#1f2937; box-shadow: 0 6px 16px rgba(245,158,11,.30); }
        #leaderboardList .leaderboard-card.rank-2 .lb-rank-ribbon { background: linear-gradient(180deg,#e5e7eb,#9ca3af); color:#1f2937; box-shadow: 0 6px 16px rgba(156,163,175,.25); }
        #leaderboardList .leaderboard-card.rank-3 .lb-rank-ribbon { background: linear-gradient(180deg,#fcd34d,#b45309); color:#111827; box-shadow: 0 6px 16px rgba(180,83,9,.22); }
        #leaderboardList .leaderboard-card.rank-default .lb-rank-ribbon { background: #f3f4f6; color:#6b7280; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.02); }

        /* Mobile: turn ribbon into a circular chip at the left */
        @media (max-width: 640px) {
            #leaderboardList .leaderboard-card { display: flex !important; align-items: center; padding-left: 0.95rem; }
            #leaderboardList .leaderboard-card .lb-rank-ribbon {
                position: static;
                width: 2.75rem; height: 2.75rem; border-radius: 9999px;
                margin-right: 0.75rem;
            }
            #leaderboardList .leaderboard-card .lb-rank-ribbon span { writing-mode: horizontal-tb; transform: none; letter-spacing: 0; font-size: 1.1rem; }
            #leaderboardList .leaderboard-card .lb-medal { top: 0.45rem; right: 0.55rem; }
        }

        /* Make selected state on mobile as prominent as desktop: thicker border + larger shadow */
        @media (max-width: 760px) {
            .difficulty-option.selected, .range-option.selected {
                transform: translateY(-4px) scale(1.03) !important; /* gentle lift */
                box-shadow: 0 20px 50px rgba(0,0,0,0.18) !important;
                border-width: 4px !important;
            }

            /* Ensure selected cards keep their colored border on mobile as JS adds color classes */
            .difficulty-option.selected.border-green-600 { border-color: #16a34a !important; }
            .difficulty-option.selected.border-yellow-600 { border-color: #d97706 !important; }
            .difficulty-option.selected.border-red-600 { border-color: #dc2626 !important; }

            .range-option.selected.border-purple-600 { border-color: #7c3aed !important; }
            .range-option.selected.border-blue-600 { border-color: #2563eb !important; }
            .range-option.selected.border-orange-600 { border-color: #ea580c !important; }
        }

        /* Respect reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            * { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; }
        }

        /* heading icon + label adjustments for range card titles */
        .heading-icon { display: inline-block; margin-right: 0.5rem; }
        .heading-label { letter-spacing: 0.18em; }

        /* Verses carousel styles are mobile-only. Keep desktop layout intact. */
        @media (max-width: 760px) {
            /* Verses carousel: two panels side-by-side on the x-axis. Mobile users can swipe between them. */
            .verses-carousel {
                display: flex;
                width: 100%;
                overflow-x: auto;
                scroll-snap-type: x mandatory;
                -webkit-overflow-scrolling: touch;
            }
            .verses-carousel .panel {
                flex: 0 0 100%; /* each panel takes full viewport width */
                scroll-snap-align: start;
                box-sizing: border-box;
                /* prevent inner horizontal scrolling - only the outer carousel should scroll horizontally */
                overflow-x: hidden !important;
                overflow-y: auto !important; /* vertical scrolling inside panel */
            }

            /* Ensure the lists inside panels are vertical stacks */
            .verses-list .verse-card,
            .chapter-list .chapter-card {
                width: 100% !important;
                max-width: 100% !important;
                display: block !important;
                padding: 0.9rem 1rem !important;
                box-shadow: 0 6px 18px rgba(14, 30, 37, 0.06);
                border-radius: 0.5rem;
                overflow-x: hidden !important; /* ensure card content doesn't create horizontal overflow */
                box-sizing: border-box !important;
            }

            /* Small spacing and larger tap targets on mobile */
            .verses-list,
            .chapter-list {
                display: flex;
                flex-direction: column;
                gap: 0.6rem;
                overflow-x: hidden !important; /* prevent nested horizontal scrolling */
                padding-left: 0.4rem !important; /* small inset so cards don't sit flush to panel edges */
                padding-right: 0.4rem !important;
                box-sizing: border-box !important;
            }

            /* Hide default scrollbar on supported browsers for a cleaner look */
            .verses-carousel::-webkit-scrollbar { height: 6px; }
            .verses-carousel::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); border-radius: 3px; }
        }
        
        .verse-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.12);
        }

        /* Ensure selected cards float above neighbors and are not clipped: use border+shadow highlight instead of scaling */
        .selected-verse {
            position: relative !important;
            z-index: 50 !important;
            transform: none !important;
            border-width: 3px !important;
            box-shadow: 0 12px 34px rgba(0,0,0,0.18) !important;
        }

        /* If a selected card sits inside an overflow-hidden container, allow its visible overflow within panels specifically */
        .panel .selected-verse {
            overflow: visible !important;
            box-shadow: 0 12px 34px rgba(0,0,0,0.18) !important;
        }

        /* General safety rules to avoid clipping on transforms */
        .verse-card, .chapter-card, .verse-card > div, .chapter-card > div {
            box-sizing: border-box !important;
            transform-origin: center center !important;
            -webkit-transform-origin: center center !important;
            will-change: transform, box-shadow !important;
        }

        /* Ensure inner text doesn't overflow when card is scaled */
        .verse-card > div, .chapter-card > div { overflow-wrap: break-word; word-break: break-word; }
        
        .chapter-card {
            transition: all 0.3s ease;
            border-radius: 15px;
            cursor: pointer;
        }
        
        .chapter-card:hover {
            transform: scale(1.05);
        }
        
        .hint-flash {
            animation: hintPulse 1s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
            border: 3px solid #FFD700 !important;
        }
        
        @keyframes hintPulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            }
        }

        /* encouragement pulse available globally; class only applied on mobile via media query */
        @keyframes encouragementPulseMobile {
            0% { transform: translate(-50%, -50%) scale(0.95); opacity: 0; }
            10% { transform: translate(-50%, -50%) scale(1.08); opacity: 1; }
            40% { transform: translate(-50%, -50%) scale(1.03); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        @-webkit-keyframes encouragementPulseMobile {
            0% { -webkit-transform: translate(-50%, -50%) scale(0.95); opacity: 0; }
            10% { -webkit-transform: translate(-50%, -50%) scale(1.08); opacity: 1; }
            40% { -webkit-transform: translate(-50%, -50%) scale(1.03); opacity: 1; }
            100% { -webkit-transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* when JS adds this class, the animation will run (kept global to avoid media-query quirks) */
        #encouragementText.mobile-pulse {
            animation: encouragementPulseMobile 700ms cubic-bezier(.2,.9,.2,1) 0s 1 both;
            -webkit-animation: encouragementPulseMobile 700ms cubic-bezier(.2,.9,.2,1) 0s 1 both;
        }

        /* inner span scale-only pulse (more reliable on mobile/webviews) */
        .encourage-inner { display: inline-block; transform-origin: center center; }
        @keyframes encourageInnerPulse {
            0% { transform: scale(0.96); }
            30% { transform: scale(1.12); }
            60% { transform: scale(1.04); }
            100% { transform: scale(1); }
        }
        @-webkit-keyframes encourageInnerPulse {
            0% { -webkit-transform: scale(0.96); }
            30% { -webkit-transform: scale(1.12); }
            60% { -webkit-transform: scale(1.04); }
            100% { -webkit-transform: scale(1); }
        }
        .encourage-inner.pulse {
            animation: encourageInnerPulse 700ms cubic-bezier(.2,.9,.2,1) 0s 1 both;
            -webkit-animation: encourageInnerPulse 700ms cubic-bezier(.2,.9,.2,1) 0s 1 both;
        }

        /* floating score popup animation */
        .score-popup {
            animation: scoreFloat 1.2s ease-out forwards;
        }

        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-30px) scale(1.08); opacity: 1; }
            100% { transform: translateY(-60px) scale(1.2); opacity: 0; }
        }

        .celebration-popup {
            animation: celebrationFloat 3s ease-out forwards;
            text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 60px rgba(255, 255, 255, 0.8), 0 8px 16px rgba(255, 255, 255, 0.4) !important;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 1)) drop-shadow(0 8px 16px rgba(255, 255, 255, 0.4));
        }
        
        @keyframes celebrationFloat {
            0% { transform: translateY(0) scale(0.8); opacity: 1; }
            20% { transform: translateY(-20px) scale(1.2); opacity: 1; }
            60% { transform: translateY(-40px) scale(1.1); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.4); opacity: 0; }
        }
        
        .perfect-popup {
            animation: perfectFloat 4s ease-out forwards;
            text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 60px rgba(255, 255, 255, 0.8), 0 8px 16px rgba(255, 255, 255, 0.4) !important;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 1)) drop-shadow(0 8px 16px rgba(255, 255, 255, 0.4));
        }

        /* keep encouragement text out of document flow so it won't shift the score box */
        #encouragementText {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 8px;
            pointer-events: none;
            z-index: 25; /* above card content but doesn't change layout */
            width: calc(100% - 3rem);
            text-align: center;
            line-height: 1.1;
            display: inline-block;
            /* softer shadow so glyph本身不變暗 + 細白描邊提升對比 */
            text-shadow: 0 1px 1px rgba(0,0,0,0.16), 0 0 10px rgba(255,255,255,0.30);
            -webkit-text-stroke: 0.4px rgba(255,255,255,0.35);
        }

        /* Mobile tweaks: ensure the floating +score / encouragement text is visible
           above the pinned controls on small viewports. Use a fixed position so
           it won't be clipped/covered by the bottom control bar. */
        @media (max-width: 640px) {
            :root { --pinned-controls-height: 64px; }
            #encouragementText {
                position: fixed !important;
                left: 50% !important;
                /* place it just above the pinned controls (use CSS var with fallback) */
                bottom: calc(var(--pinned-controls-height, 64px) + 12px) !important;
                z-index: 45 !important; /* ensure it's above #gameControlsPinned (z-40) but below modals (z-50) */
                width: min(92%, 520px) !important;
                font-size: 1.6rem !important; /* increased for readability on small screens */
                /* keep encouragement on a single line on mobile */
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                line-height: 1.08 !important;
                pointer-events: none !important;
                /* lighter neutral陰影 + 細白描邊：不讓字變黑，仍能壓住白底 */
                text-shadow: 0 1px 2px rgba(0,0,0,0.18), 0 0 12px rgba(255,255,255,0.26) !important;
                -webkit-text-stroke: 0.4px rgba(255,255,255,0.35);
            }

            /* give the score card a little extra bottom padding so its internal
               progress bar / labels aren't accidentally clipped when the viewport
               is very tight. This is minimal and only on small screens. */
            .cute-card[style*="min-w-[320px]"] {
                padding-bottom: 4.5rem !important;
            }
                /* Mobile overlay badge that will be inserted into the two panel titles
                    or next to the main score. Use a dedicated center badge style for
                    positioning beside the gold score. */
                .mobile-score-badge {
                position: absolute;
                left: 50%;
                top: -1.6rem; /* float above the title text */
                transform: translateX(-50%);
                background: linear-gradient(90deg,#16a34a,#4ade80);
                color: white;
                padding: 6px 10px;
                border-radius: 999px;
                font-weight: 800;
                font-size: 0.95rem;
                line-height: 1;
                box-shadow: 0 6px 18px rgba(16,185,129,0.18), 0 2px 6px rgba(0,0,0,0.12);
                pointer-events: none;
                opacity: 0;
                transition: transform 420ms cubic-bezier(.2,.9,.2,1), opacity 420ms ease-out;
            }

            /* entrance/exit transforms */
            .mobile-score-badge.show {
                opacity: 1;
                transform: translateX(-50%) translateY(-6px) scale(1);
            }
            .mobile-score-badge.hide {
                opacity: 0;
                transform: translateX(-50%) translateY(-28px) scale(0.96);
            }
            /* ensure title containers can host absolute children */
            .panel .panel-front .panel-title,
            .panel .panel-back .panel-title,
            #verseTitle, #chapterTitle {
                position: relative;
                overflow: visible;
            }

            /* class applied when encouragement appears on mobile (rule moved to global scope for compatibility) */
            /* center score badge (places +/- value next to the large gold score) */
            .mobile-center-badge {
                position: absolute;
                right: -0.6rem; /* nudge slightly outside the score box */
                top: -0.45rem;
                transform: none;
                background: linear-gradient(90deg,#16a34a,#4ade80);
                color: white;
                padding: 4px 8px;
                border-radius: 999px;
                font-weight: 800;
                font-size: 1rem;
                line-height: 1;
                box-shadow: 0 6px 18px rgba(16,185,129,0.18), 0 2px 6px rgba(0,0,0,0.12);
                pointer-events: none;
                opacity: 0;
                transition: transform 260ms ease-out, opacity 260ms ease-out;
            }
            .mobile-center-badge.show { opacity: 1; transform: translateY(-4px); }
            .mobile-center-badge.hide { opacity: 0; transform: translateY(0); }
        }

    /* removed center golden halo behind the encouragement text to keep screen clean */
    #encouragementText::before { display: none !important; }
    #encouragementText:empty::before { display: none !important; }

        /* Platinum → Gold gradient text helper (used for encouragement text) */
        .platinum-gold-text {
            /* Stronger score-like gold: white → rich yellow → white, with wider gold band */
            background: linear-gradient(90deg,
                #ffffff 0%,
                #fff7d6 12%,   /* warm white */
                #ffe38a 28%,   /* soft gold */
                #ffd54d 45%,   /* mid gold (approx Tailwind amber/yellow) */
                #f6c629 55%,   /* deep gold core */
                #ffd54d 65%,   /* mid gold */
                #ffe38a 82%,   /* soft gold */
                #fff7d6 90%,   /* warm white */
                #ffffff 100%
            );
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        @keyframes perfectFloat {
            0% { transform: translateY(0) scale(0.5) rotate(0deg); opacity: 1; }
            15% { transform: translateY(-15px) scale(1.3) rotate(10deg); opacity: 1; }
            30% { transform: translateY(-30px) scale(1.1) rotate(-5deg); opacity: 1; }
            70% { transform: translateY(-50px) scale(1.2) rotate(5deg); opacity: 1; }
            100% { transform: translateY(-100px) scale(1.5) rotate(0deg); opacity: 0; }
        }
        
        @keyframes sparkleEffect {
            0% { 
                transform: translate(-50%, -50%) scale(0) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.5) rotate(180deg); 
                opacity: 1; 
            }
            100% { 
                transform: translate(-50%, -50%) scale(0.5) rotate(360deg); 
                opacity: 0; 
            }
        }
        
        @keyframes confettiEffect {
            0% { 
                transform: translateY(0) scale(1) rotate(0deg); 
                opacity: 1; 
            }
            100% { 
                transform: translateY(-80px) scale(0.8) rotate(720deg); 
                opacity: 0; 
            }
        }

        /* Lightweight score particle sprites that appear near the large center score
           Now using a sparkle/star glyph and white->gold color palette. Animation duration
           doubled per user request but travel distance remains controlled by --dx/--dy.
        */
        .score-particle {
            position: fixed;
            pointer-events: none;
            z-index: 10003;
            will-change: transform, opacity;
            opacity: 1;
            transform-origin: center center;
            display: inline-block;
            line-height: 1;
            font-weight: 700;
            animation: scoreParticleMove 1400ms cubic-bezier(.2,.9,.2,1) forwards;
        }

        @keyframes scoreParticleMove {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0.6) rotate(0deg);
            }
            60% {
                opacity: 1;
                transform: translate(var(--dx, 0px), var(--dy, -28px)) scale(1.05) rotate(90deg);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--dx, 0px) * 1.2), calc(var(--dy, -28px) * 1.4)) scale(0.8) rotate(180deg);
            }
        }

        /* Confetti rain pieces (colorful ribbons) */
    .confetti-piece {
            position: fixed;
            pointer-events: none;
            z-index: 10005;
            will-change: transform, opacity;
            width: 10px;
            height: 16px;
            border-radius: 2px;
            opacity: 1;
            transform-origin: center center;
            animation: confettiFallLinear 5600ms cubic-bezier(.2,.8,.2,1) forwards;
        }

        @keyframes confettiFallLinear {
            0% { transform: translateY(-6vh) rotate(0deg) translateX(0); opacity: 1; }
            60% { opacity: 1; }
            100% { transform: translateY(110vh) rotate(540deg) translateX(var(--conf-x, 0px)); opacity: 0; }
        }

        /* Gold glitter: small shimmering particles that fall/sparkle */
        .gold-glitter {
            position: fixed;
            pointer-events: none;
            z-index: 10006;
            color: #FFD700;
            text-shadow: 0 0 6px rgba(255,215,0,0.9), 0 0 14px rgba(255,240,200,0.45);
            font-weight: 800;
            font-size: 10px;
            will-change: transform, opacity;
            opacity: 1;
            animation: goldGlitterFall 2000ms ease-out forwards;
        }

        @keyframes goldGlitterFall {
            0% { transform: translateY(0) scale(0.85) rotate(0deg); opacity: 1; }
            60% { opacity: 1; }
            100% { transform: translateY(140px) scale(0.6) rotate(180deg); opacity: 0; }
        }
        
    /* medal badge backgrounds & readable text colors */
    .medal-gold { background: linear-gradient(135deg,#D69E2E,#FFD700); color: #111827; box-shadow: 0 2px 6px rgba(214,158,46,0.2); }
    .medal-silver { background: linear-gradient(135deg,#9CA3AF,#C0C0C0); color: #111827; box-shadow: 0 2px 6px rgba(156,163,175,0.12); }
    .medal-bronze { background: linear-gradient(135deg,#b36b2a,#CD7F32); color: #ffffff; box-shadow: 0 2px 6px rgba(205,127,50,0.18); }
    .medal-default { background: #e5e7eb; color: #6b7280; }
    /* Rank header styles for the end-game modal */
    .rank-header { display:inline-flex; align-items:center; gap:0.6rem; justify-content:center; }
    .rank-badge { width:40px; height:40px; border-radius:9999px; display:inline-flex; align-items:center; justify-content:center; font-weight:800; font-size:1rem; }
    .rank-title { font-weight:900; font-size:1.15rem; background:linear-gradient(90deg,#7c3aed,#ec4899); -webkit-background-clip:text; background-clip:text; color:transparent; }
    .rank-gold .rank-badge { background: linear-gradient(135deg,#D69E2E,#FFD700); color:#111827; box-shadow:0 4px 14px rgba(214,158,46,0.18); }
    .rank-silver .rank-badge { background: linear-gradient(135deg,#9CA3AF,#C0C0C0); color:#111827; box-shadow:0 4px 12px rgba(156,163,175,0.12); }
    .rank-bronze .rank-badge { background: linear-gradient(135deg,#b36b2a,#CD7F32); color:#fff; box-shadow:0 4px 12px rgba(205,127,50,0.14); }
    .rank-default .rank-badge { background:#e5e7eb; color:#6b7280; }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .score-flash {
            animation: scoreFlash 1.5s ease-in-out;
        }
        
        @keyframes scoreFlash {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .score-animate {
            animation: scoreShow 2s ease-out forwards;
        }
        
        @keyframes scoreShow {
            0% { opacity: 1; transform: translateX(0); }
            70% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(20px); }
        }
        

        
        /* 數字計數動畫 */
        .counting-animation {
            animation: countingPulse 0.1s ease-in-out;
        }
        
        @keyframes countingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* --- Compact modal styles for score/finish modal --- */
        /* Keep the finish modal compact and consistent across desktop and mobile. */
        #playerNameModal .cute-card {
            max-width: 760px !important;
            width: min(92%, 760px) !important;
            padding: 1rem !important; /* reduced outer padding */
            box-sizing: border-box !important;
        }

        #playerNameModal .cute-card h2, #playerNameModal .cute-card h3, #playerNameModal .cute-card h4 {
            line-height: 1.04 !important;
            margin-bottom: 0.35rem !important;
        }

        #playerNameModal .cute-card .bg-white\/70 {
            padding: 0.6rem !important; /* reduce inner panel padding */
        }

        /* Closing verse: auto-size on desktop to avoid overlapping the reference line; keep text clamped to 2 lines */
        #closingVerse {
            max-height: none !important;
            overflow: visible !important;
            text-overflow: clip !important;
            white-space: normal !important;
            padding: 0.5rem !important;
            margin-bottom: 0.45rem !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: stretch !important;
            justify-content: flex-start !important;
            gap: 0.25rem !important;
        }

        /* Helper for clamping the closing verse text (2 lines) */
        .closing-verse-clamp {
            display: -webkit-box !important;
            -webkit-line-clamp: 2 !important;
            -webkit-box-orient: vertical !important;
            line-clamp: 2 !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }

        /* Compact name input and buttons inside modal */
        #playerNameModal input#playerNameInput { padding: 0.6rem !important; font-size: 0.96rem !important; }
        #playerNameModal #confirmNameBtn { padding: 0.7rem 0.9rem !important; font-size: 1rem !important; }
        #playerNameModal .cute-button.w-full { margin-bottom: 0.35rem !important; }

        #replaySameQuestionsBtn { padding: 0.5rem 0.6rem !important; font-size: 0.95rem !important; }
        #sameReplayNote { margin-top: 0.35rem !important; font-size: 0.85rem !important; }

        @media (max-width: 640px) {
            /* Mobile: allow inner content to scroll and keep action footer sticky/visible */
            #playerNameModal .cute-card {
                padding: 0.9rem !important;
                max-height: 90vh !important;
                overflow: visible !important; /* allow body to scroll while footer stays sticky */
                border-radius: 1rem !important; /* stronger rounded corners on mobile */
                box-shadow: 0 18px 40px rgba(6,21,38,0.16) !important;
            }
            /* Show full closing verse on mobile */
            #closingVerse { max-height: none !important; overflow: visible !important; }
            .closing-verse-clamp { -webkit-line-clamp: unset !important; line-clamp: unset !important; }
            /* Restore internal scrolling so sticky footer stays visible while content scrolls */
            #playerNameModal .modal-body {
                -webkit-overflow-scrolling: touch !important;
                overflow-y: auto !important;
                max-height: calc(90vh - 88px) !important; /* reserve space for footer */
                padding-bottom: calc(0.75rem + env(safe-area-inset-bottom, 0px)) !important;
                touch-action: manipulation !important;
            }
            /* Sticky footer with safe-area support */
            #playerNameModal .modal-footer {
                position: sticky !important;
                bottom: env(safe-area-inset-bottom, 0px) !important;
                z-index: 70 !important;
                pointer-events: auto !important;
                background: linear-gradient(to top, rgba(255,255,255,0.96), rgba(255,255,255,0.78) 60%, rgba(255,255,255,0)) !important;
                padding-top: 0.25rem !important;
                padding-bottom: calc(0.35rem + env(safe-area-inset-bottom, 0px)) !important;
                backdrop-filter: saturate(140%) blur(6px);
            }
            #playerNameModal .modal-footer button.cute-button { padding: 0.78rem 0.9rem !important; font-size: 1.02rem !important; }
        }

        /* 倒數數字輕微上下浮動效果 */
        @keyframes countdownFloat {
            0% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
            100% { transform: translateY(0); }
        }

        .countdown-float {
            animation: countdownFloat 1.2s ease-in-out infinite;
        }
        
        .hint-blink {
            animation: hintBlink 1s ease-in-out infinite;
        }
        
        @keyframes hintBlink {
            0%, 50% { background-color: #fbbf24; }
            51%, 100% { background-color: #f59e0b; }
        }
        
        .shake-error {
            animation: shakeError 0.6s ease-in-out;
        }
        
        @keyframes shakeError {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
            20%, 40%, 60%, 80% { transform: translateX(8px); }
        }
        
        .start-button-pulse {
            animation: startButtonPulse 1s ease-in-out 5;
        }
        
        @keyframes startButtonPulse {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.05);
            }
        }
        
        .game-instruction {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 193, 7, 0.95);
            color: #856404;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            z-index: 1000;
            animation: instructionFade 15s ease-in-out;
            border: 2px solid rgba(255, 193, 7, 0.8);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
            text-shadow: none;
        }
        
        @keyframes instructionFade {
            0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
        
        @keyframes instructionFadeOut {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
        
        @keyframes instructionEnhanced {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5) rotate(-5deg); 
                filter: blur(5px);
            }
            10% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1) rotate(2deg); 
                filter: blur(0px);
            }
            15% { 
                transform: translate(-50%, -50%) scale(1) rotate(0deg); 
            }
            85% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1) rotate(0deg); 
                filter: blur(0px);
            }
            95% { 
                opacity: 0.3; 
                transform: translate(-50%, -50%) scale(0.9) rotate(-2deg); 
                filter: blur(2px);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.7) rotate(-5deg); 
                filter: blur(5px);
            }
        }
        
        /* 慶祝彩帶動畫 */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f39c12;
            animation: confetti-fall 3s linear infinite;
        }
        
        .confetti:nth-child(odd) {
            background: #e74c3c;
            width: 8px;
            height: 8px;
            animation-duration: 2.5s;
        }
        
        .confetti:nth-child(even) {
            background: #3498db;
            width: 6px;
            height: 6px;
            animation-duration: 3.5s;
        }
        
        .confetti:nth-child(3n) {
            background: #2ecc71;
            width: 12px;
            height: 12px;
            animation-duration: 2.8s;
        }
        
        .confetti:nth-child(4n) {
            background: #9b59b6;
            width: 9px;
            height: 9px;
            animation-duration: 3.2s;
        }
        
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        /* 拉炮效果 */
        .party-popper {
            position: absolute;
            font-size: 4rem;
            animation: party-pop 2s ease-out;
        }
        
        @keyframes party-pop {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.2) rotate(180deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(360deg);
                opacity: 0.8;
            }
        }
        
        .selected-verse {
            border-width: 4px !important;
            transform: scale(1.05);
        }
        
        .selected-verse.bg-blue-50 {
            border-color: #1d4ed8 !important;
            box-shadow: 0 10px 25px rgba(29, 78, 216, 0.3);
        }
        
        .selected-verse.bg-yellow-100 {
            border-color: #d97706 !important;
            box-shadow: 0 10px 25px rgba(217, 119, 6, 0.3);
        }
        
        .selected-verse.bg-orange-100 {
            border-color: #ea580c !important;
            box-shadow: 0 10px 25px rgba(234, 88, 12, 0.3);
        }
        
        .hint-reminder {
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(255, 193, 7, 0.95);
            color: #856404;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            z-index: 100;
            animation: hintReminder 2s ease-in-out;
            border: 1px solid rgba(255, 193, 7, 0.8);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }
        
        @keyframes hintReminder {
            0%, 100% { opacity: 0; transform: translateY(10px); }
            20%, 80% { opacity: 1; transform: translateY(0); }
        }
        
        /* 背景經文跑馬燈效果 */
        .verse-marquee {
            position: fixed;
            /* expand container and rotate so lines move diagonally (counter-clockwise -45deg) */
            top: -25%;
            left: -25%;
            width: 150%;
            height: 150%;
            pointer-events: none;
            z-index: 0;
            overflow: visible; /* allow entries from outside viewport */
            transform: rotate(-45deg);
            transform-origin: 50% 50%;
        }
        
        .verse-text {
            position: absolute;
            white-space: nowrap;
            font-size: 4.5rem;
            font-weight: 800;
            color: rgba(139, 69, 19, 0.08);
            animation: marquee-horizontal 25s linear infinite;
            transform-origin: center;
            letter-spacing: 0.3rem;
            opacity: 1;
            text-shadow: 0 0 20px rgba(0,0,0,0.05);
            /* keep line spacing consistent even if font-size varies (halved as requested) */
            line-height: 3.5rem;
        }
        
        @keyframes marquee-horizontal {
            0% {
                /* start well outside the right edge */
                transform: translateX(calc(100vw + 300px));
                opacity: 0.0;
            }
            6% {
                opacity: 1;
            }
            94% {
                opacity: 1;
            }
            100% {
                /* end well past the left edge */
                transform: translateX(calc(-100vw - 300px));
                opacity: 0.0;
            }
        }
        
        .verse-text:nth-child(1) {
            top: 5%;
            color: rgba(107, 114, 128, 0.12);
        }
        
        .verse-text:nth-child(2) {
            top: 18%;
            color: rgba(75, 85, 99, 0.12);
        }
        
        .verse-text:nth-child(3) {
            top: 31%;
            color: rgba(156, 163, 175, 0.12);
        }
        
        .verse-text:nth-child(4) {
            top: 44%;
            color: rgba(139, 69, 19, 0.12);
        }
        
        .verse-text:nth-child(5) {
            top: 57%;
            color: rgba(120, 113, 108, 0.12);
        }
        
        .verse-text:nth-child(6) {
            top: 70%;
            color: rgba(99, 102, 241, 0.12);
        }
        
        .verse-text:nth-child(7) {
            top: 83%;
            color: rgba(168, 85, 247, 0.12);
        }
        

        </style>
        <style>
            /* Cute hint bar shared styles */
            .cute-hint { 
                display: none; align-items: center; gap: .5rem; 
                position: fixed; left: 50%; transform: translateX(-50%) translateY(24px);
                bottom: 12px; opacity: 0;
                max-width: 56rem; width: max-content; 
                padding: .6rem .9rem; border-radius: 9999px; 
                border: 2px solid; background: white; 
                box-shadow: 0 10px 30px rgba(2,6,23,.1);
                font-weight: 700; letter-spacing: .02em; z-index: 1000;
                pointer-events: none; /* do not block clicks */
                transition: opacity .2s ease, transform .2s ease;
                white-space: nowrap !important; /* keep hint in a single line */
                overflow: hidden !important; /* clip overflow on small screens */
                text-overflow: ellipsis !important;
            }
            .cute-hint.show { opacity: 1; transform: translateX(-50%) translateY(0); }
            .cute-hint .cute-hint-icon { font-size: 1.1rem; }
            .cute-hint .cute-hint-text { font-size: .95rem; color: #334155; white-space: nowrap !important; }
            /* Neutralize the cute icon for a more professional tone */
            .cute-hint .cute-hint-icon { display: inline-block !important; margin-right: 2px; }
            /* theme colors */
            .cute-hint.green { border-color: #86efac; background: #f0fdf4; }
            .cute-hint.green .cute-hint-text { color: #065f46; }
            .cute-hint.amber { border-color: #fcd34d; background: #fffbeb; }
            .cute-hint.amber .cute-hint-text { color: #92400e; }
            .cute-hint.red { border-color: #fca5a5; background: #fef2f2; }
            .cute-hint.red .cute-hint-text { color: #991b1b; }
            .cute-hint.purple { border-color: #c4b5fd; background: #faf5ff; }
            .cute-hint.purple .cute-hint-text { color: #6b21a8; }
            .cute-hint.blue { border-color: #93c5fd; background: #eff6ff; }
            .cute-hint.blue .cute-hint-text { color: #1d4ed8; }
            /* mobile fit */
            @media (max-width: 640px) {
                .cute-hint { 
                    max-width: calc(100% - 1rem); width: auto; 
                    transform: translateX(-50%) translateY(24px); 
                    /* keep hint bar above pinned controls and safe-area */
                    bottom: calc(var(--pinned-controls-height, 64px) + env(safe-area-inset-bottom, 0px) + 8px);
                    padding: .55rem .8rem; border-width: 2px; border-radius: 16px; 
                }
                .cute-hint .cute-hint-text { font-size: .9rem; }
            }
        </style>
    <style>
        /* Startup overlay: subtle shimmer for loading text */
        @keyframes loadingShimmer {
            0%   { text-shadow: 0 0 8px rgba(255,255,255,0.30); opacity: 0.92; }
            50%  { text-shadow: 0 0 16px rgba(255,255,255,0.65); opacity: 1.00; }
            100% { text-shadow: 0 0 8px rgba(255,255,255,0.30); opacity: 0.92; }
        }
        #startupOverlay .loading-shimmer { animation: loadingShimmer 2s ease-in-out infinite; }
    /* Simple fade-in for startup elements */
    @keyframes softFadeIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    #startupOverlay .fade-in-1 { opacity: 0; animation: softFadeIn 1.2s ease-out .1s forwards; }
    #startupOverlay .fade-in-2 { opacity: 0; animation: softFadeIn 1.4s ease-out .25s forwards; }
    #startupOverlay .fade-in-3 { opacity: 0; animation: softFadeIn 1.6s ease-out .4s forwards; }
        /* Startup overlay theme backgrounds */
        #startupOverlay.theme-light {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 35%, #dbeafe 70%, #bfdbfe 100%);
        }
        #startupOverlay.theme-dark {
            background: linear-gradient(135deg, #1f2937 0%, #273244 40%, #334155 100%);
        }
        /* Optional startup logo sizing */
        #startupOverlay #startupLogo {
            max-width: clamp(420px, 60vw, 960px);
            max-height: clamp(240px, 45vh, 420px);
            width: auto; height: auto;
            margin-bottom: 14px;
            filter: drop-shadow(0 8px 18px rgba(0,0,0,0.18));
            opacity: 0.98;
            user-select: none;
            -webkit-user-drag: none;
        }
    /* Version at top-right */
    #startupOverlay #startupVersion { top: 14px !important; right: 16px !important; bottom: auto !important; }
        /* Bottom-left wordmark */
        #startupOverlay #startupWord {
            position: absolute; left: calc(env(safe-area-inset-left, 0px) + 0px); bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
            width: auto; height: auto; max-width: clamp(210px, 42vw, 540px); max-height: 30vh;
            filter: drop-shadow(0 6px 14px rgba(0,0,0,0.18));
            opacity: 0.95; pointer-events: none; user-select: none; -webkit-user-drag: none;
        }
        /* Tighter corner fit for word2 variants */
        #startupOverlay #startupWord.variant-word2 {
            left: calc(env(safe-area-inset-left, 0px) - 6px);
            bottom: calc(env(safe-area-inset-bottom, 0px) - 6px);
            transform: scale(0.8);
            transform-origin: left bottom;
        }
        /* Loading text: center horizontally, at 25vh from the bottom (viewport-based) */
        #startupOverlay #startupLoadingText {
            position: absolute; left: 0; right: 0; bottom: calc(25vh + env(safe-area-inset-bottom, 0px)); transform: none;
            width: 100%; text-align: center;
            color: rgba(255,255,255,0.95); font-weight: 800; letter-spacing: 0.25em;
            text-shadow: 0 0 14px rgba(0,0,0,0.25);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-pink-100 via-purple-50 to-blue-100 min-h-screen">
    <!-- Startup overlay: 可變主題（亮/暗），中間 LOGO、左下 wordmark、底部 Loading 與右下版本 -->
    <div id="startupOverlay" class="fixed inset-0 z-[9999] flex items-center justify-center select-none theme-light"
         style="transition: opacity 1s ease;">
        <div class="absolute inset-0" aria-hidden="true" style="
            background:
                radial-gradient(1000px 600px at 15% 25%, rgba(255,255,255,0.28) 0%, rgba(255,255,255,0.18) 40%, transparent 55%),
                radial-gradient(900px 540px at 85% 20%, rgba(255,255,255,0.24) 0%, rgba(255,255,255,0.16) 38%, transparent 52%),
                radial-gradient(1100px 660px at 60% 80%, rgba(255,255,255,0.22) 0%, rgba(255,255,255,0.14) 36%, transparent 50%);
        "></div>
        <div class="relative flex flex-col items-center">
            <img id="startupLogo" class="fade-in-1" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='420' height='240'%3E%3C/svg%3E" alt="App logo" decoding="async" fetchpriority="high" />
        </div>
        <img id="startupWord" class="fade-in-2" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='280' height='120'%3E%3C/svg%3E" alt="Wordmark" decoding="async" fetchpriority="high" />
        <div id="startupLoadingText" class="fade-in-2 text-base md:text-lg font-black tracking-widest loading-shimmer">Loading...</div>
        <div id="startupVersion" class="fade-in-3 absolute bottom-3 right-4 text-white/90 text-sm md:text-base font-semibold select-none">
            <!-- set dynamically -->
        </div>
    </div>
    <!-- 背景經文跑馬燈 -->
    <div class="verse-marquee" id="verseMarquee">
        <!-- 跑馬燈經文將在這裡生成 -->
    </div>

    <!-- 開始畫面 -->
    <div id="startScreen" class="min-h-screen p-4">
        <div class="max-w-6xl mx-auto">
            <!-- 標題 -->
            <div class="text-center mb-4">
                <div class="title-container bg-gradient-to-br from-slate-700 via-slate-800 to-slate-900 p-6 text-center border-2 border-slate-600 shadow-2xl relative overflow-hidden inline-block rounded-3xl">
                    <!-- 標題背景裝飾 -->
                    <div class="absolute inset-0 bg-gradient-to-br from-slate-700/40 to-slate-800/40 rounded-3xl"></div>
                    <div class="relative z-10">
                        <h1 class="text-4xl font-black bg-gradient-to-r from-gray-200 via-yellow-200 to-gray-200 bg-clip-text text-transparent mb-2 drop-shadow-lg" style="letter-spacing: 0.3em; text-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);">
                            <span id="titleLeftIcon" class="mr-4">📖</span>
                            <span id="mainTitle" class="mx-2" style="cursor:pointer;">經夠盃挑戰</span>
                            <span id="titleRightIcon" class="ml-4">📖</span>
                        </h1>
                    </div>
                </div>
            </div>
            
            <!-- 可愛語氣提示條（桌面/手機通用） -->
            <div id="cuteHintBar" class="cute-hint" role="status" aria-live="polite" aria-atomic="true">
                <span class="cute-hint-icon" aria-hidden="true">✨</span>
                <span class="cute-hint-text">提示文字</span>
            </div>

            <div class="grid lg:grid-cols-3 gap-4">
                <!-- 計分說明區 -->
                <div id="scoringCard" class="cute-card bg-white p-4 scoring-card">
                    <!-- 開始遊戲按鈕 -->
                    <div class="text-center mb-4">
                        <button id="startGameBtn" class="cute-button bg-gradient-to-r from-purple-500 to-pink-500 text-white py-4 px-8 text-2xl font-bold hover:from-purple-600 hover:to-pink-600 shadow-xl w-full" style="letter-spacing: 0.3em;">
                            開始遊戲
                        </button>
                        <div id="gameStartHint" class="text-sm text-gray-500 mt-2 opacity-0 transition-opacity duration-300">
                            請先選擇難度和出題範圍
                        </div>
                        <!-- Mobile: toggle to show/hide scoring details (keeps desktop unchanged) -->
                        <!-- (moved down under the time reward switch on mobile) -->
                    </div>
                    
                    <!-- 時間獎懲開關 -->
                    <div class="flex items-center justify-center mb-4 p-2 bg-gray-50 rounded-lg">
                        <span class="text-sm text-gray-700 font-medium mr-3">時間獎懲：</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="countdownToggle" class="sr-only peer" checked>
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                            <span class="ml-2 text-sm text-gray-600 font-medium" id="countdownToggleText">開啟</span>
                        </label>
                    </div>

                    <!-- Mobile: toggle to show/hide scoring details (keeps desktop unchanged) -->
                    <div class="text-center mb-2" style="display:block;">
                        <button id="toggleScoringBtn" class="toggle-scoring-btn" aria-expanded="false" aria-controls="scoringBody" style="display:none; margin-top:.25rem; font-size:0.95rem;" title="顯示/收起計分說明">
                            <span aria-hidden="true">📊</span>
                            <span>顯示計分說明</span>
                            <span class="chev" aria-hidden="true">▾</span>
                        </button>
                        <div id="toggleScoringA11y" class="sr-only" aria-live="polite"></div>
                    </div>
                    
                    <!-- 分割線 -->
                    <div class="border-t border-gray-300 mb-4"></div>
                    
                    <div id="scoringBody" class="scoring-body">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">📊 計分說明</h2>
                    
                    <div class="space-y-1 text-sm text-gray-700 scoring-remarks">
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 基礎分數：</span>
                            <span id="baseScoreRuleValue" class="font-bold text-green-600">+100/125/150分/題</span>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 失誤扣分：</span>
                            <span class="font-bold text-red-600">-25分/次</span>
                        </div>
                        
                        <div id="timeRewardRule" class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 時間獎懲：</span>
                            <span class="font-bold text-blue-600">+50~-50分</span>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 全對獎勵：</span>
                            <span class="font-bold text-yellow-600">+100分</span>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 完美獎勵：</span>
                            <span class="font-bold text-purple-600">+300分</span>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="font-medium text-gray-800">• 提示獎勵：</span>
                            <span class="font-bold text-orange-600">+50分/剩餘</span>
                        </div>
                    </div>
                    
                        <div class="mt-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
                                <div class="text-xs text-gray-600 scoring-remarks">
                                            <div>※ 失誤扣分：每次答錯扣25分</div>
                                            <div>※ 完美獎勵：全對且無失誤且無提示</div>
                                            <div id="timeRewardNote">※ 時間獎懲：8秒內 +50；至120秒降為 -50</div>
                                </div>
                            </div>
                    </div>
                </div>
                
                <!-- 難度選擇區 -->
                <div id="difficultyCard" class="cute-card bg-white p-6">
                    <h2 class="text-3xl font-bold text-gray-800 mb-6 text-center">⚙️ 難度選擇</h2>
                    
                    <div class="space-y-3">
                        <div class="difficulty-option cute-button bg-gradient-to-br from-green-50 to-green-100 border-2 border-green-300 p-4 cursor-pointer shadow-lg hover:shadow-xl transition-all duration-300" data-difficulty="easy" tabindex="0" role="button">
                            <div class="grid grid-cols-5 gap-4 items-center">
                                <div class="col-span-1 flex flex-col items-center justify-center">
                                    <div class="text-3xl">🌱</div>
                                    <div class="mt-1 text-lg font-semibold text-green-700 tracking-widest">簡單</div>
                                    <div class="difficulty-hint text-sm text-gray-600">配對經文</div>
                                </div>
                                <div class="col-span-4">
                                    <div class="difficulty-badges">
                                        <div class="text-green-700 font-semibold text-center">失誤：2次</div>
                                        <div class="text-green-700 font-semibold text-center">配對經文</div>
                                        <div class="text-green-700 font-semibold text-center">提示：5次</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="difficulty-option cute-button bg-gradient-to-br from-yellow-50 to-yellow-100 border-2 border-yellow-300 p-4 cursor-pointer shadow-lg hover:shadow-xl transition-all duration-300" data-difficulty="normal" tabindex="0" role="button">
                            <div class="grid grid-cols-5 gap-4 items-center">
                                <div class="col-span-1 flex flex-col items-center justify-center">
                                    <div class="text-3xl">⭐</div>
                                    <div class="mt-1 text-lg font-semibold text-yellow-700 tracking-widest">普通</div>
                                    <div class="difficulty-hint text-sm text-gray-600">配對書卷</div>
                                </div>
                                <div class="col-span-4">
                                    <div class="difficulty-badges">
                                        <div class="text-yellow-700 font-semibold text-center">失誤：1次</div>
                                        <div class="text-yellow-700 font-semibold text-center">配對書卷</div>
                                        <div class="text-yellow-700 font-semibold text-center">提示：3次</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="difficulty-option cute-button bg-gradient-to-br from-red-50 to-red-100 border-2 border-red-300 p-4 cursor-pointer shadow-lg hover:shadow-xl transition-all duration-300" data-difficulty="hard" tabindex="0" role="button">
                            <div class="grid grid-cols-5 gap-4 items-center">
                                <div class="col-span-1 flex flex-col items-center justify-center">
                                    <div class="text-3xl">🔥</div>
                                    <div class="mt-1 text-lg font-semibold text-red-700 tracking-widest">困難</div>
                                    <div class="difficulty-hint text-sm text-gray-600">配對章節</div>
                                </div>
                                <div class="col-span-4">
                                    <div class="difficulty-badges">
                                        <div class="text-red-700 font-semibold text-center">失誤：0次</div>
                                        <div class="text-red-700 font-semibold text-center">配對章節</div>
                                        <div class="text-red-700 font-semibold text-center">提示：1次</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 出題範圍區 -->
                <div id="rangeCard" class="cute-card bg-white p-6">
                    <h2 class="text-3xl font-bold text-gray-800 mb-4 text-center">📚 出題範圍</h2>

                    <div class="grid grid-cols-1 gap-4">
                        <!-- 上區（排行模式：選擇罕見度） -->
                        <div class="p-4 rounded-xl bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-200 h-full flex flex-col justify-center">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center">
                                    <span class="heading-icon mr-1">🏆</span>
                                    <h3 class="text-base md:text-xl font-bold text-purple-700"><span class="heading-label">排行模式</span></h3>
                                </div>
                                <div class="heading-sub text-purple-500 opacity-80 text-xs md:text-sm font-semibold">經文罕見度</div>
                            </div>

                            <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                                <div class="rarity-option cute-button bg-white/70 border-purple-300 border-2 p-2 rounded-md cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex items-center justify-center min-h-[36px]" data-rarity="common" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-purple-700 text-sm font-bold tracking-wider">常見</span>
                                </div>
                                
                                <div class="rarity-option cute-button bg-white/70 border-purple-300 border-2 p-2 rounded-md cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex items-center justify-center min-h-[36px]" data-rarity="rare" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-purple-700 text-sm font-bold tracking-wider">冷門</span>
                                </div>
                                <div class="rarity-option cute-button bg-white/70 border-purple-300 border-2 p-2 rounded-md cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex items-center justify-center min-h-[36px]" data-rarity="all" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-purple-700 text-sm font-bold tracking-wider">全部</span>
                                </div>
                            </div>
                        </div>

                        <!-- 下區（原練習模式） -->
                        <div class="p-4 rounded-xl bg-gradient-to-br from-blue-50 to-cyan-50 border-2 border-blue-200 h-full flex flex-col justify-center">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center">
                                    <span class="heading-icon mr-1">📝</span>
                                    <h3 class="text-base md:text-xl font-bold text-blue-700"><span class="heading-label">練習模式</span></h3>
                                </div>
                                <div class="heading-sub text-blue-500 opacity-80 text-xs md:text-sm font-semibold">不列入排行</div>
                            </div>

                            <div class="grid grid-cols-2 gap-3 items-stretch">
                                <div class="range-option cute-button bg-white/80 border-blue-300 border-2 p-3 rounded-lg cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex-1" data-range="testament" data-testament="old" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-blue-700">舊約</span>
                                </div>

                                <div class="range-option cute-button bg-white/80 border-blue-300 border-2 p-3 rounded-lg cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full flex-1" data-range="testament" data-testament="new" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-blue-700">新約</span>
                                </div>

                                <div class="col-span-2 range-option cute-button bg-white/80 border-orange-300 border-2 p-3 rounded-lg cursor-pointer shadow-sm hover:shadow-md transition-all duration-200 w-full" data-range="custom" tabindex="0" role="button" aria-pressed="false">
                                    <span class="label text-orange-600">自訂書卷</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 自訂書卷擴展卡片（保留現有 id/行為） -->
                    <div id="customBooksExpandCard" class="cute-card bg-white p-3 mt-4 hidden">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-sm font-bold text-orange-700">🎯 選擇書卷</h3>
                            <div class="flex items-center gap-2">
                                <button id="selectAllBooksExpand" class="text-xs bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded">全選</button>
                                <button id="clearAllBooksExpand" class="text-xs bg-red-400 hover:bg-red-500 text-white px-2 py-1 rounded">取消勾選</button>
                            </div>
                        </div>

                        <div class="mb-2">
                            <input type="text" id="bookSearchExpand" placeholder="搜尋書卷..." class="w-full p-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-orange-400">
                        </div>

                        <div id="customBooksExpand" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2 max-h-32 overflow-y-auto" style="grid-auto-rows: minmax(44px, auto);">
                            <!-- 書卷選項將在這裡生成 -->
                        </div>
                    </div>

                    <div id="rangeWarning" class="text-red-500 text-center text-sm hidden mt-4">
                        ⚠️ 選擇的書卷過少，無法開始遊戲！
                    </div>
                </div>
            </div>
            
            <!-- 排行榜區 -->
            <div id="leaderboardSection" class="cute-card bg-white p-6 mt-6">
                <!-- 標題與難度選擇標籤同行 -->
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-800">🏆 排行榜</h2>
                    <div class="flex items-center space-x-3">
                        <div class="bg-gray-100 rounded-full p-1 flex">
                        <button class="leaderboard-tab px-4 py-2 rounded-full bg-blue-500 text-white text-sm font-bold" data-difficulty="easy">簡單</button>
                        <button class="leaderboard-tab px-4 py-2 rounded-full text-gray-600 text-sm font-bold" data-difficulty="normal">普通</button>
                        <button class="leaderboard-tab px-4 py-2 rounded-full text-gray-600 text-sm font-bold" data-difficulty="hard">困難</button>
                        </div>
                    </div>
                </div>
                
                <div id="leaderboardList" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
                    <!-- 排行榜項目將在這裡生成 -->
                </div>
                <div id="leaderboardOnlineNote" class="text-xs text-gray-500 mt-2"></div>
                
                <!-- 清空排行榜確認 Modal -->
                <div id="clearLeaderboardModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-60">
                    <div class="cute-card bg-white p-6 rounded-lg max-w-sm mx-4">
                        <h3 class="text-lg font-bold text-gray-800 mb-3">清空排行榜</h3>
                        <p class="text-sm text-gray-600 mb-4">確定要清空所有排行榜紀錄嗎？此操作無法復原。</p>
                        <div class="flex justify-end space-x-3">
                            <button id="cancelClearLeaderboard" class="cute-button bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded">取消</button>
                            <button id="confirmClearLeaderboard" class="cute-button bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">確定清空</button>
                        </div>
                    </div>
                </div>
            </div>
            

        </div>
    </div>

    <!-- 自訂書卷選擇視窗 -->
    <div id="customBooksModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="cute-card bg-white p-6 max-w-2xl mx-4 max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-green-700">🎯 選擇書卷</h3>
                <button id="closeCustomModal" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            
            <div class="mb-4">
                <input type="text" id="bookSearch" placeholder="搜尋書卷..." class="w-full p-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-400">
            </div>
            
            <div class="flex justify-between items-center mb-4">
                <div class="flex space-x-2">
                    <button id="selectAllBooks" class="text-sm bg-green-500 hover:bg-green-600 text-white px-3 py-2 rounded">全選</button>
                    <button id="selectOldTestament" class="text-sm bg-blue-400 hover:bg-blue-500 text-white px-3 py-2 rounded">選擇舊約</button>
                    <button id="selectNewTestament" class="text-sm bg-purple-400 hover:bg-purple-500 text-white px-3 py-2 rounded">選擇新約</button>
                    <button id="clearAllBooks" class="text-sm bg-red-400 hover:bg-red-500 text-white px-3 py-2 rounded">清除全部</button>
                </div>
                <span id="selectedCount" class="text-sm text-gray-600 font-bold">已選: 0本</span>
            </div>
            
            <div id="customBooks" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2 mb-4 max-h-64 overflow-y-auto" style="grid-auto-rows: minmax(48px, auto);">
                <!-- 書卷選項將在這裡生成 -->
            </div>
            
            <div class="flex justify-end space-x-3">
                <button id="cancelCustomSelection" class="cute-button bg-gray-400 hover:bg-gray-500 text-white px-4 py-2 font-bold">取消</button>
                <button id="confirmCustomSelection" class="cute-button bg-green-500 hover:bg-green-600 text-white px-4 py-2 font-bold">確認選擇</button>
            </div>
        </div>
    </div>



    <!-- 遊戲畫面 -->
    <div id="gameScreen" class="min-h-screen p-4 hidden bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50">
        <!-- 遊戲背景裝飾 -->
        <div class="fixed inset-0 pointer-events-none z-0">
            <div class="absolute top-10 left-10 text-6xl opacity-10 animate-pulse">📖</div>
            <div class="absolute top-20 right-20 text-5xl opacity-10 animate-bounce">✨</div>
            <div class="absolute bottom-20 left-20 text-4xl opacity-10 animate-pulse">🙏</div>
            <div class="absolute bottom-10 right-10 text-6xl opacity-10 animate-bounce">⭐</div>
            <div class="absolute top-1/2 left-5 text-3xl opacity-10 animate-pulse">🕊️</div>
            <div class="absolute top-1/3 right-5 text-4xl opacity-10 animate-bounce">💫</div>
        </div>
        
        <!-- 遊戲主要資訊區 -->
        <div class="max-w-7xl mx-auto mb-6 relative z-10">
            <div class="flex items-center justify-between gap-6">
                <!-- 左側：進度條區域 -->
                <div class="flex-1 space-y-4">
                    <!-- 關卡進度條 -->
                    <div id="levelProgressCard" class="cute-card bg-gradient-to-r from-purple-50 to-indigo-50 p-3 border-2 border-purple-200 shadow-xl">
                        <div class="mb-4 flex items-center space-x-2">
                            <span class="text-2xl">🎯</span>
                            <span class="text-lg font-bold text-purple-700">關卡進度</span>
                        </div>
                        <div id="levelOvals" class="flex space-x-2">
                            <!-- 橢圓條將在這裡生成 -->
                        </div>
                    </div>
                    
                    <!-- 題目進度條 -->
                    <div id="questionProgressCard" class="cute-card bg-gradient-to-r from-blue-50 to-cyan-50 p-3 border-2 border-blue-200 shadow-xl">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center space-x-2">
                                <span class="text-2xl">📝</span>
                                <span class="text-lg font-bold text-blue-700">題目進度</span>
                            </div>
                            <span id="currentQuestion" class="text-lg font-bold text-blue-600 bg-blue-100 px-3 py-1 rounded-full">0/5</span>
                        </div>
                        <div id="questionOvals" class="flex space-x-2">
                            <!-- 題目橢圓條將在這裡生成 -->
                        </div>
                    </div>
                </div>

                <!-- 中間：分數顯示 -->
                <div class="cute-card bg-gradient-to-br from-slate-700 via-slate-800 to-slate-900 p-8 text-center min-w-[320px] border-2 border-slate-600 shadow-2xl relative overflow-hidden">
                    <!-- 分數背景裝飾 -->
                    <div class="absolute inset-0 bg-gradient-to-br from-slate-700/40 to-slate-800/40 rounded-3xl"></div>
                    <div class="relative z-10">
                        <div class="flex items-center justify-center space-x-6 mb-4">
                            <div class="flex items-center space-x-2">
                                <span id="centerScore" class="text-7xl font-black bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent drop-shadow-lg" style="text-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 0 0 60px rgba(255, 255, 255, 0.6);">0</span>
                                <span class="text-2xl font-bold bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent" style="text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);">分</span>
                            </div>
                        </div>
                        <!-- ARIA live region for score updates (visually hidden) -->
                        <div id="scoreAriaLive" aria-live="polite" class="sr-only" style="position:absolute; width:1px; height:1px; overflow:hidden; clip:rect(1px, 1px, 1px, 1px);">分數 0 分</div>

                        
                        <!-- 時間獎勵溫度計 -->
                        <div id="timeRewardProgressContainer" class="space-y-2 mb-3">
                            <div class="relative">
                                <div id="scoreProgressBar" class="w-full bg-gray-200 rounded-full h-6 shadow-inner border-2 border-gray-300">
                                    <div id="scoreProgressFill" class="bg-green-500 h-full rounded-full transition-all duration-300 shadow-sm" style="width: 100%"></div>
                                </div>
                                <!-- 溫度計刻度 (已根據 TIME_SCALE 放大顯示：-50 ~ +50) -->
                                <div class="flex justify-between text-xs text-gray-500 mt-1 px-0 relative">
                                    <span class="text-left">-50</span>
                                    <span class="text-center">-40</span>
                                    <span class="text-center">-30</span>
                                    <span class="text-center">-20</span>
                                    <span class="text-center">-10</span>
                                    <span class="text-center">0</span>
                                    <span class="text-center">+10</span>
                                    <span class="text-center">+20</span>
                                    <span class="text-center">+30</span>
                                    <span class="text-center">+40</span>
                                    <span class="text-right">+50</span>
                                </div>
                            </div>
                        </div>
                        <div id="timeRewardProgressText" class="text-sm text-gray-400 mb-4 font-normal opacity-70">時間獎懲倒數</div>
                        
                        <div id="encouragementText" role="status" aria-live="polite" class="text-2xl font-extrabold platinum-gold-text transition-opacity duration-500 opacity-0"></div>
                    </div>
                </div>

                <!-- 右側：遊戲資訊與控制 -->
                <div class="flex-1">
                    <!-- 整合的遊戲資訊與控制卡片 -->
                    <div id="gameInfoCard" class="cute-card bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 p-4 border-2 border-indigo-200 shadow-xl">
                        <!-- 標題 -->
                        <div class="flex items-center justify-center space-x-2 mb-4">
                            <span class="text-xl">🎮</span>
                            <span class="text-lg font-bold text-indigo-700">遊戲資訊</span>
                            <span class="text-xl">⚙️</span>
                        </div>
                        
                        <!-- 設定資訊 -->
                        <div id="gameInfoSettings" class="bg-white/60 rounded-xl p-3 mb-4 border border-indigo-200">
                            <div class="flex items-center justify-center space-x-4 text-center">
                                <div class="bg-blue-100 rounded-lg p-2 border border-blue-200 flex-1">
                                    <div class="text-xs text-indigo-700 font-bold mb-1">🎯 難度</div>
                                    <div id="gameDifficultyDisplay" class="font-bold text-blue-700 text-sm">簡單</div>
                                </div>
                                <div class="bg-green-100 rounded-lg p-2 border border-green-200 flex-1">
                                    <div class="text-xs text-emerald-700 font-bold mb-1">📚 範圍</div>
                                    <div id="gameRangeDisplay" class="font-bold text-green-700 text-sm">全部</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 控制按鈕區已移出以便在隱藏遊戲資訊卡時仍可顯示 (see #gameControlsPinned inserted below) -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Pinned controls (hint + back) moved here so they remain visible when the game-info card is hidden on mobile -->
        <div id="gameControlsPinned" class="fixed inset-x-0 bottom-0 z-40 p-3 bg-white/70 backdrop-blur-md border-t border-gray-200 sm:relative sm:bg-white/60 sm:rounded-xl sm:border sm:border-indigo-200 sm:p-3">
            <div class="flex items-center justify-between max-w-[520px] mx-auto">
                <!-- 提示功能 -->
                <div class="flex items-center space-x-2">
                    <button id="hintBtn" class="cute-button bg-gradient-to-r from-amber-500 via-yellow-500 to-amber-600 hover:from-amber-600 hover:via-yellow-600 hover:to-amber-700 text-white font-bold text-sm px-4 py-3 shadow-xl border-2 border-yellow-300 hover:border-yellow-400 transition-all duration-300 transform hover:scale-105">
                        <span class="flex items-center space-x-1">
                            <span class="text-base animate-pulse">💡</span>
                            <span>提示</span>
                        </span>
                    </button>
                    <div id="hintCount" class="text-sm font-bold text-blue-600 bg-blue-100 px-3 py-2 rounded-full border-2 border-blue-200 shadow-md">
                        ⭐×5
                    </div>
                </div>

                <!-- 返回按鈕 -->
                <button id="backToMenuFromGame" class="cute-button bg-gradient-to-r from-gray-400 to-gray-500 hover:from-gray-500 hover:to-gray-600 text-white px-4 py-3 font-bold text-sm shadow-lg">
                    🏠 返回主選單
                </button>
            </div>
        </div>

        <!-- 遊戲內容 -->
        <div class="max-w-7xl mx-auto space-y-6 relative z-10">
            <!-- Carousel container: two panels (前段經文 / 後段經文) that swipe horizontally on mobile -->
            <div id="versesCarousel" class="verses-carousel relative">
                <!-- Panel: 前段經文 -->
                <div class="panel panel-front p-8 relative">
                    <div class="absolute top-4 right-4 text-6xl opacity-5">📜</div>
                    <div class="absolute bottom-4 left-4 text-5xl opacity-5">✍️</div>
                    <div class="mb-8 relative z-10">
                        <h3 id="verseTitle" class="panel-title text-4xl font-bold text-gray-700 flex items-center justify-center relative" style="letter-spacing:0.12em; margin-bottom:0.25rem;">
                            <span class="text-4xl animate-pulse mr-4">📜</span>
                            <span class="tracking-widest bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">經文</span>
                            <span class="text-4xl animate-pulse ml-4">📜</span>
                        </h3>
                    </div>
                    <div id="gameVerses" class="verses-list flex flex-col gap-3 justify-start relative z-10">
                        <!-- 經文卡片將在這裡生成 -->
                    </div>
                </div>

                <!-- Panel: 後段經文 (章節/配對選項) -->
                <div class="panel panel-back p-8 relative">
                    <div class="absolute top-4 left-4 text-6xl opacity-5">📍</div>
                    <div class="absolute bottom-4 right-4 text-5xl opacity-5">🎯</div>
                    <div class="mb-8 relative z-10">
                        <h3 id="chapterTitle" class="panel-title text-4xl font-bold text-gray-700 flex items-center justify-center relative" style="letter-spacing:0.12em; margin-bottom:0.25rem;">
                            <span class="text-4xl animate-pulse mr-4">📍</span>
                            <span class="tracking-widest bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">章節</span>
                            <span class="text-4xl animate-pulse ml-4">📍</span>
                        </h3>
                    </div>
                    <div id="gameChapters" class="chapter-list flex flex-col gap-3 justify-start relative z-10">
                        <!-- 章節卡片將在這裡生成 -->
                    </div>
                </div>
            </div>
        </div>





        <!-- 確認返回視窗 -->
        <div id="confirmBackModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="confirmBackTitle" tabindex="-1">
            <div class="cute-card bg-white p-8 max-w-md mx-4 text-center">
                <div class="text-4xl mb-4">⚠️</div>
                <h3 id="confirmBackTitle" class="text-xl font-bold text-gray-800 mb-4">確認返回</h3>
                <p class="text-gray-600 mb-6">確定要中斷遊戲並返回首頁嗎？<br><span class="text-sm text-red-500">（中斷遊戲將不會計入排行榜）</span></p>
                <div class="flex space-x-3">
                    <button id="confirmBackBtn" class="cute-button flex-1 bg-red-500 hover:bg-red-600 text-white px-6 py-3 font-bold">
                        確認返回
                    </button>
                    <button id="cancelBackBtn" class="cute-button flex-1 bg-gray-400 hover:bg-gray-500 text-white px-6 py-3 font-bold">
                        繼續遊戲
                    </button>
                </div>
            </div>
        </div>

        <!-- 結算視窗 -->
    <div id="playerNameModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="playerNameModalTitle" tabindex="-1">
            <div class="cute-card bg-gradient-to-br from-white via-blue-50 to-purple-50 p-6 md:p-8 max-w-2xl mx-4 text-center rounded-3xl border-2 border-purple-200 shadow-2xl max-h-[90vh]">
                <div class="modal-body" style="overflow-y:auto; max-height: calc(90vh - 84px); padding-right: 0.25rem;"> 
                <!-- 完成遊戲標題 -->
                <div class="mb-6">
                    <!-- celebratory emoji removed per request -->
            <h2 id="playerNameModalTitle" class="text-3xl font-black bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent mb-2">分數結算</h2>
                    <div class="w-20 h-1 bg-gradient-to-r from-purple-500 to-pink-500 mx-auto rounded-full"></div>
                </div>
                
                <!-- 分數資訊 -->
                <div class="bg-white/70 rounded-2xl p-6 mb-6 border-2 border-purple-200 shadow-lg">
                    <div class="grid grid-cols-2 gap-4 text-center mb-4">
                        <div class="bg-gradient-to-br from-green-100 to-emerald-100 rounded-xl p-4 border-2 border-green-300">
                            <div class="text-2xl font-black text-green-600" id="finalScore">0</div>
                            <div class="text-sm font-bold text-green-700">總分數</div>
                        </div>
                        <div class="bg-gradient-to-br from-blue-100 to-cyan-100 rounded-xl p-4 border-2 border-blue-300">
                            <div class="flex items-center justify-center gap-3">
                                <div class="text-2xl font-black text-blue-600" id="finalAccuracy">0%</div>
                                <div id="finalAccuracyRatio" class="text-sm text-blue-600"><strong>(0/0)</strong></div>
                            </div>
                            <div class="text-sm font-bold text-blue-700">答對率</div>
                        </div>
                    </div>
                    
                    <!-- 詳細計分數據 -->
                    <div id="scoreBreakdown" class="bg-gray-50 rounded-xl p-4 border border-gray-200">
                        <h4 class="text-sm font-bold text-gray-700 mb-3">📊 詳細計分</h4>
                        <div id="scoreBreakdownContent" class="grid grid-cols-2 gap-2 text-xs">
                            <!-- 計分詳情將在這裡生成 -->
                        </div>
                    </div>
                </div>
                
                <!-- 結語經文 -->
                <div id="closingVerse" class="bg-gradient-to-r from-yellow-100 to-orange-100 rounded-2xl p-4 mb-6 border-2 border-yellow-300 shadow-lg">
                    <div id="closingVerseText" class="text-lg font-bold text-gray-800 mb-1 closing-verse-clamp"></div>
                    <div id="closingVerseRef" class="text-sm text-gray-600 font-semibold" style="margin-top:4px;"></div>
                </div>
                
                <!-- 排行榜訊息 -->
                <div id="leaderboardMessage" class="mb-6">
                    <!-- Dynamic header: will be set to e.g. "第1名" when appropriate -->
                    <h3 id="leaderboardHeader" class="text-xl font-bold text-gray-800 mb-2"></h3>
                    <p id="rankMessage" class="text-lg text-purple-600 font-bold">您獲得了第1名！</p>
                </div>
                
                <!-- 名稱輸入 -->
                <div id="nameInputSection" class="mb-6">
                    <label class="block text-lg font-bold text-gray-700 mb-3">請輸入您的名稱：</label>
                    <input type="text" id="playerNameInput" class="w-full p-4 text-lg border-2 border-purple-300 rounded-xl focus:outline-none focus:ring-4 focus:ring-purple-200 focus:border-purple-500 bg-white/80" maxlength="10" placeholder="留空將顯示為匿名">
                    <div class="text-gray-500 text-sm mt-1">可留空，或輸入2-10個中英文字元</div>
                    <div id="nameError" class="text-red-500 text-sm mt-2 hidden font-bold"></div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-1 gap-3 mb-3">
                    <button id="replaySameQuestionsBtn" class="cute-button w-full bg-yellow-500 hover:bg-yellow-600 text-white px-6 py-3 rounded-xl font-bold flex items-center justify-center gap-3">
                        <span class="text-xl">🎯</span>
                        <span class="text-left">同題重玩<br><span class="text-xs font-normal">不列入排行榜</span></span>
                    </button>
                </div>

                </div>
                <!-- Sticky footer so confirm button is always reachable on small viewports -->
                <div class="modal-footer" style="position:sticky; bottom:0; background: transparent; padding-top:0.2rem; padding-bottom:0.2rem;">
                    <!-- 確認按鈕（主要行動） -->
                    <button id="confirmNameBtn" class="cute-button w-full bg-gradient-to-r from-purple-600 to-pink-500 hover:from-purple-700 hover:to-pink-600 text-white px-6 py-3 font-extrabold text-lg rounded-2xl shadow-2xl">
                        ✅ 確認並返回主選單
                    </button>

                    <!-- sameReplayNote removed as requested -->
                </div>

                <input type="hidden" id="currentViewedRecordId" value="" />
            </div>
        </div>
    </div>

    <script>
        // 遊戲狀態
        let gameState = {
            difficulty: null,
            // ranking/practice model
            mode: null, // 'ranking' or 'practice' (derived from UI selection); optional display helper
            rarity: null, // 'common' | 'rare' | 'all' (for 排行模式；少見 'uncommon' 僅作內部分類)
            range: null,
            testament: 'old',
            customBooks: [],
            currentLevel: 1,
            currentQuestion: 1,
            score: 0,
            hintsUsed: 0,
            levelPerfect: true,
            questionData: [],
            currentQuestionIndex: 0,
            questionAttempts: {},
            usedHints: new Set(),
            selectedVerseIndex: null,
            levelStartTime: null,
            timerInterval: null,
            totalCorrectAnswers: 0,
            totalQuestions: 0,
            gameStartTime: null,
            gameCompleted: false,
            levelResults: {},
            hintsRemaining: 5,
            isFirstQuestionOfLevel: true,
            consecutiveMistakes: 0,
            hintReminderShown: false,
            showTimeReward: true // 時間獎懲開關狀態，預設開啟
        };

    // 是否啟用外部經文載入（關閉則完全不嘗試抓取 external-verses.json）
    const ENABLE_EXTERNAL_VERSES = true;

        // 嘗試載入外部經文資料（非同步、可快取），失敗則保留內建資料
    async function attemptLoadExternalVerses() {
            // 若不啟用外部載入，直接返回
            if (!ENABLE_EXTERNAL_VERSES) return;
            try {
                // 使用 sessionStorage 作為快取，避免重複讀取
        const cacheKey = 'bibleChallenge.externalVerses.v2';
                const cached = sessionStorage.getItem(cacheKey);
                if (cached) {
                    const parsed = JSON.parse(cached);
                    if (Array.isArray(parsed) && parsed.length > 0) {
                        window.verseDatabase = parsed;
                        try { updateStartButtonState(); } catch(e) {}
                        try { refreshVerseMarqueeData(); } catch(e) {}
                        try {
                            const evt = new CustomEvent('externalVersesLoaded', { detail: { hasData: true, source: 'cache' } });
                            window.dispatchEvent(evt);
                        } catch(_) {}
                        return;
                    }
                }
                // 嘗試抓取同目錄的 external-verses.json（若不存在將拋錯）
                const res = await fetch('external-verses.json', { cache: 'no-store' });
                let ok = res.ok;
                let data = [];
                if (ok) {
                    try { data = await res.json(); } catch(_) { data = []; }
                }
                // 若主檔不存在或為空，嘗試 fallback 到最近的備份檔
                if (!ok || !Array.isArray(data) || data.length === 0) {
                    try {
                        const fbPath = 'external-verses.backup_20250819_171140.json';
                        const fbRes = await fetch(fbPath, { cache: 'no-store' });
                        if (fbRes.ok) {
                            const fbData = await fbRes.json();
                            if (Array.isArray(fbData) && fbData.length > 0) {
                                data = fbData;
                            }
                        }
                    } catch(_) {}
                }
                if (Array.isArray(data) && data.length > 0) {
                    // 先存原始資料，實際使用時會再經 normalize 與驗證
                    window.verseDatabase = data;
                    try { sessionStorage.setItem(cacheKey, JSON.stringify(data)); } catch(e){}
                    try { updateStartButtonState(); } catch(e) {}
                    try { refreshVerseMarqueeData(); } catch(e) {}
                    try {
                        const evt = new CustomEvent('externalVersesLoaded', { detail: { hasData: true, source: ok ? 'fetch' : 'fallback' } });
                        window.dispatchEvent(evt);
                    } catch(_) {}
                }
            } catch (e) {
                // 記錄失敗，以便 UI 顯示明確提示（例如 file:// 或 CORS/路徑問題）
                try { window.externalVersesLoadError = (e && e.message) ? String(e.message) : 'unknown'; } catch(_) {}
                try { updateStartButtonState(); } catch(_) {}
                try {
                    const evt = new CustomEvent('externalVersesLoaded', { detail: { hasData: false, source: 'error', error: (e && e.message) || 'unknown' } });
                    window.dispatchEvent(evt);
                } catch(_) {}
            }
        }

        // 聖經書卷數據
        const bibleBooks = {
            old: ['創世記', '出埃及記', '利未記', '民數記', '申命記', '約書亞記', '士師記', '路得記', 
                  '撒母耳記上', '撒母耳記下', '列王紀上', '列王紀下', '歷代志上', '歷代志下', 
                  '以斯拉記', '尼希米記', '以斯帖記', '約伯記', '詩篇', '箴言', '傳道書', '雅歌', 
                  '以賽亞書', '耶利米書', '耶利米哀歌', '以西結書', '但以理書', '何西阿書', 
                  '約珥書', '阿摩司書', '俄巴底亞書', '約拿書', '彌迦書', '那鴻書', '哈巴谷書', 
                  '西番雅書', '哈該書', '撒迦利亞書', '瑪拉基書'],
            new: ['馬太福音', '馬可福音', '路加福音', '約翰福音', '使徒行傳', '羅馬書', 
                  '哥林多前書', '哥林多後書', '加拉太書', '以弗所書', '腓立比書', '歌羅西書', 
                  '帖撒羅尼迦前書', '帖撒羅尼迦後書', '提摩太前書', '提摩太後書', '提多書', 
                  '腓利門書', '希伯來書', '雅各書', '彼得前書', '彼得後書', '約翰一書', 
                  '約翰二書', '約翰三書', '猶大書', '啟示錄']
        };

        // 書卷簡稱對照表
        const bookAbbreviations = {
            '創世記': '創', '出埃及記': '出', '利未記': '利', '民數記': '民', '申命記': '申',
            '約書亞記': '書', '士師記': '士', '路得記': '得', '撒母耳記上': '撒上', '撒母耳記下': '撒下',
            '列王紀上': '王上', '列王紀下': '王下', '歷代志上': '代上', '歷代志下': '代下',
            '以斯拉記': '拉', '尼希米記': '尼', '以斯帖記': '斯', '約伯記': '伯', '詩篇': '詩',
            '箴言': '箴', '傳道書': '傳', '雅歌': '歌', '以賽亞書': '賽', '耶利米書': '耶',
            '耶利米哀歌': '哀', '以西結書': '結', '但以理書': '但', '何西阿書': '何',
            '約珥書': '珥', '阿摩司書': '摩', '俄巴底亞書': '俄', '約拿書': '拿', '彌迦書': '彌',
            '那鴻書': '鴻', '哈巴谷書': '哈', '西番雅書': '番', '哈該書': '該',
            '撒迦利亞書': '亞', '瑪拉基書': '瑪',
            '馬太福音': '太', '馬可福音': '可', '路加福音': '路', '約翰福音': '約',
            '使徒行傳': '徒', '羅馬書': '羅', '哥林多前書': '林前', '哥林多後書': '林後',
            '加拉太書': '加', '以弗所書': '弗', '腓立比書': '腓', '歌羅西書': '西',
            '帖撒羅尼迦前書': '帖前', '帖撒羅尼迦後書': '帖後', '提摩太前書': '提前',
            '提摩太後書': '提後', '提多書': '多', '腓利門書': '門', '希伯來書': '來',
            '雅各書': '雅', '彼得前書': '彼前', '彼得後書': '彼後', '約翰一書': '約一',
            '約翰二書': '約二', '約翰三書': '約三', '猶大書': '猶', '啟示錄': '啟'
        };

        // 將各種可能的書卷名稱（含簡稱）正規化為此程式所使用的「完整中文書名」
        function normalizeBookName(name) {
            try {
                if (!name) return name;
                const raw = String(name).trim();
                // 如果本就為完整中文書名且存在於清單中，直接回傳
                if ([...bibleBooks.old, ...bibleBooks.new].includes(raw)) return raw;

                // 嘗試用簡稱（如「太、林前、彼後、創、詩」）反查完整書名
                for (const [full, abbr] of Object.entries(bookAbbreviations)) {
                    if (raw === abbr) return full;
                }

                // 寬鬆處理：移除空白再比對一次
                const compact = raw.replace(/\s+/g, '');
                for (const [full, abbr] of Object.entries(bookAbbreviations)) {
                    if (compact === abbr) return full;
                    if (compact === full.replace(/\s+/g, '')) return full;
                }

                // 未辨識則回傳原值（後續過濾可能會略過此書名）
                return raw;
            } catch (e) {
                return name;
            }
        }

    // 內建題庫已移除，改用 external-verses.json 作為唯一資料來源

        // 清理經文：移除說明用括號內容與多餘空白（保留原文語句）
        function sanitizeVerseText(text) {
            try {
                if (text == null) return text;
                let s = String(text);
                // 反覆移除半形與全形括號內的內容（不跨越嵌套，迭代處理多段）
                const patterns = [/\([^()]*\)/g, /（[^（）]*）/g];
                let changed = true;
                while (changed) {
                    changed = false;
                    for (const re of patterns) {
                        const next = s.replace(re, '');
                        if (next !== s) { s = next; changed = true; }
                    }
                }
                // 收斂空白與標點周圍空白
                s = s.replace(/\s{2,}/g, ' ').replace(/\s*([，。！？…；;:：,\.\!\?])\s*/g, '$1').trim();
                return s;
            } catch (_) { return text; }
        }

        // 主題性偵測：盡量避開不具主題性的對話型經文（如「百姓回答說：…」）
        function hasTopicalKeywords(text) {
            try {
                if (!text) return false;
                const keywords = [
                    '耶和華','主','神','耶穌','基督','聖靈','信','愛','義','罪','救','救恩','恩典','福',
                    '讚美','稱謝','敬畏','盼望','永生','生命','聖潔','公義','真理','福音','喜樂','平安','智慧','祈求','禱告'
                ];
                return keywords.some(k => text.includes(k));
            } catch (_) { return false; }
        }

        function looksLikeAmbiguousDialogue(text) {
            try {
                if (!text) return false;
                const t = String(text).trim().replace(/^^[「『\"]+/, '');
                // 通用對話觸發詞
                const genericSubjects = '(百姓|眾人|人們|他|他們|門徒|婦人|僕人|朋友|眾弟兄|眾民|長老|祭司|文士|法利賽人|官長|王|母親|父親|群眾|有人)';
                const say = '(說|回答說|回說|問|對)';
                // 1) 主語 + 對/問 + 說：
                const re1 = new RegExp('^' + genericSubjects + '[^，。！？:：]{0,8}?' + say + '[^，。！？:：]{0,6}?(說|)[：:]');
                // 2) 主語 + 回答說：
                const re2 = new RegExp('^' + genericSubjects + '(?:[^，。！？:：]{0,6})?回答說[：:]');
                // 3) 對他(們)說 / 問他(們)說：
                const re3 = /^(他|他們|眾人|百姓|人|門徒)[^，。！？:：]{0,6}(對|問)[^，。！？:：]{0,6}說[：:]/;
                return re1.test(t) || re2.test(t) || re3.test(t);
            } catch (_) { return false; }
        }

        function isWeakTopicalVerse(text) {
            try {
                if (!text) return true;
                const cleaned = String(text).trim();
                const len = cleaned.replace(/[\s，。！？…；:：、\-—\(\)（）\u3000\'\"「」『』《》〈〉]/g, '').length;
                const dialogue = looksLikeAmbiguousDialogue(cleaned);
                const topical = hasTopicalKeywords(cleaned);
                // 規則：
                // - 若像是含糊對話且無明顯主題關鍵詞 → 視為弱主題
                // - 或者字數極短且無關鍵詞 → 視為弱主題
                if ((dialogue && !topical) || (len < 8 && !topical)) return true;
                // 放行例外：出現「耶穌」「主」「耶和華」「神」等即使是對話也常具主題性
                if (/耶穌|主|耶和華|神/.test(cleaned)) return false;
                return false;
            } catch (_) { return false; }
        }

        // --- 題庫整理與難度對應：統一出題來源、去重、罕見度標註、難度過濾 ---
    // 罕見度類別（UI 僅三種）：
    // - common    常見
    // - uncommon  少見（內部用；UI 已併入冷門）
    // - rare      冷門
            // 備註：可在 external-verses.json 直接提供 rarity 屬性（支援英文或中文：常見/中等/少見/冷門/全部）以覆蓋預設分類

    function classifyRarity(v) {
            try {
                if (v && typeof v.rarity === 'string') {
                    // 支援中英文標註
                    const raw = v.rarity.trim().toLowerCase();
                    const map = {
                        '常見': 'common', '中等': 'common', '少見': 'uncommon', '冷門': 'rare', '全部': 'all',
                        'common': 'common', 'medium': 'common', 'uncommon': 'uncommon', 'rare': 'rare', 'all': 'all'
                    };
                    const m = map[raw];
                    if (m) return m;
                }
            } catch (e) {}
            const key = `${v.book}|${v.chapter}`;
            // 章號擷取（支援 "章:節" 或 "章:起-迄"）
            function chapterNumber(ch) {
                try {
                    const s = String(ch || '');
                    const m = s.match(/^(\d+):/);
                    return m ? parseInt(m[1], 10) : NaN;
                } catch (_) { return NaN; }
            }
            // 常見名節（非完整清單，外部資料若標註則以外部為準）
            const COMMON = new Set([
                '約翰福音|3:16', '約翰福音|14:6', '約翰福音|1:1', '約翰福音|1:12',
                '約翰福音|10:11', '約翰福音|11:25', '約翰福音|15:5', '約翰福音|16:33',
                '腓立比書|4:13', '腓立比書|4:6', '腓立比書|4:7', '腓立比書|4:4',
                '羅馬書|8:28', '羅馬書|6:23', '羅馬書|8:1', '羅馬書|1:16',
                '馬太福音|6:33', '馬太福音|7:7', '馬太福音|5:3', '馬太福音|5:14', '馬太福音|28:19', '馬太福音|28:20',
                '詩篇|23:1', '詩篇|23:4', '詩篇|119:105', '詩篇|46:1', '詩篇|46:10',
                '箴言|3:5', '箴言|3:6', '創世記|1:1', '創世記|1:27',
                '以賽亞書|40:31', '耶利米書|29:11', '約書亞記|1:9', '民數記|6:24', '民數記|6:25', '民數記|6:26',
            ]);
            // 書卷層級預設：把較少出現於常見引文的書卷分散到 uncommon/rare
            const RARE_BOOKS = new Set([
                '俄巴底亞書','那鴻書','西番雅書','哈該書','約拿書',
                '腓利門書','約翰二書','約翰三書','猶大書'
            ]);
            const UNCOMMON_BOOKS = new Set([
                '何西阿書','約珥書','阿摩司書','彌迦書','哈巴谷書','撒迦利亞書','瑪拉基書',
                '以斯拉記','尼希米記','以斯帖記','耶利米哀歌','傳道書','雅歌',
                '歷代志上','歷代志下','列王紀上','列王紀下','利未記','民數記'
            ]);
            // 常見章節（整章視為常見，擴大常見池以支援簡單難度）
            const COMMON_CHAPTERS = {
                '詩篇': [23, 27, 46, 51, 91, 100, 121, 127, 139],
                '箴言': [3, 4, 16],
                '創世記': [1, 12, 22, 28, 50],
                '出埃及記': [20],
                '以賽亞書': [40, 41, 43, 53, 55],
                '耶利米書': [17, 29, 33],
                '約書亞記': [1],
                '馬太福音': [5, 6, 7, 11, 28],
                '馬可福音': [12],
                '路加福音': [2, 15],
                '約翰福音': [1, 3, 6, 10, 11, 13, 14, 15, 16],
                '使徒行傳': [1, 2],
                '羅馬書': [5, 6, 8, 10, 12],
                '哥林多前書': [10, 13, 15],
                '哥林多後書': [4, 5, 12],
                '加拉太書': [2, 5, 6],
                '以弗所書': [2, 3, 6],
                '腓立比書': [1, 3, 4],
                '歌羅西書': [3],
                '帖撒羅尼迦前書': [4, 5],
                '提摩太後書': [1, 3, 4],
                '希伯來書': [4, 11, 12, 13],
                '雅各書': [1, 4, 5],
                '彼得前書': [2, 5],
                '約翰一書': [1, 4, 5],
                '啟示錄': [3, 21, 22]
            };
            // 針對特定冷門名節仍保留（即便書卷不在最冷門清單）
            const RARE_KEYS = new Set([
                '俄巴底亞書|1:21','那鴻書|1:7','西番雅書|3:17','哈該書|2:9','哈該書|2:4',
                '約拿書|2:9','阿摩司書|5:24','彌迦書|6:8','何西阿書|2:19',
                '提多書|1:9','腓利門書|1:10','約翰二書|1:5','約翰三書|1:2',
                '以斯拉記|7:10','歷代志上|16:23'
            ]);
            if (COMMON.has(key)) return 'common';
            // 廣義常見章節提升為 common
            try {
                const chNum = chapterNumber(v.chapter);
                const list = COMMON_CHAPTERS[v.book];
                if (Array.isArray(list) && Number.isFinite(chNum) && list.includes(chNum)) {
                    return 'common';
                }
            } catch (_) {}
            if (RARE_KEYS.has(key)) return 'rare';
            if (RARE_BOOKS.has(v.book)) return 'rare';
            if (UNCOMMON_BOOKS.has(v.book)) return 'uncommon';
            return 'rare';
        }

        // 驗證題庫紀錄是否有效，避免「經文內夾雜其他經文參照或頁碼」等髒資料
        function isValidVerseRecord(v) {
            try {
                if (!v || typeof v !== 'object') return false;
                const book = String(v.book || '').trim();
                const chapter = String(v.chapter || '').trim();
                const verse = String(v.verse || '').trim();

                // 書卷需存在於清單
                const allBooks = [...bibleBooks.old, ...bibleBooks.new];
                if (!allBooks.includes(book)) return false;

                // 章節格式：N:N 或 N:N-N
                if (!/^\d+:\d+(?:-\d+)?$/.test(chapter)) return false;

                // 經文內不應再出現第二個書卷參照，例如「民數記 4:43-44」
                const bookNamePattern = /(創世記|出埃及記|利未記|民數記|申命記|約書亞記|士師記|路得記|撒母耳記上|撒母耳記下|列王紀上|列王紀下|歷代志上|歷代志下|以斯拉記|尼希米記|以斯帖記|約伯記|詩篇|箴言|傳道書|雅歌|以賽亞書|耶利米書|耶利米哀歌|以西結書|但以理書|何西阿書|約珥書|阿摩司書|俄巴底亞書|約拿書|彌迦書|那鴻書|哈巴谷書|西番雅書|哈該書|撒迦利亞書|瑪拉基書|馬太福音|馬可福音|路加福音|約翰福音|使徒行傳|羅馬書|哥林多前書|哥林多後書|加拉太書|以弗所書|腓立比書|歌羅西書|帖撒羅尼迦前書|帖撒羅尼迦後書|提摩太前書|提摩太後書|提多書|腓利門書|希伯來書|雅各書|彼得前書|彼得後書|約翰一書|約翰二書|約翰三書|猶大書|啟示錄)\s+\d+:\d+/;
                if (bookNamePattern.test(verse)) return false;

                // 破碎續行的負號段號，如「-40 從三十歲…」
                if (/^-\d+\b/.test(verse)) return false;

                // 明顯頁碼殘留：空白夾著 2-4 位數字（保守處理）
                if (/\s\d{2,4}\s/.test(verse)) return false;

                return true;
            } catch (_) {
                return false;
            }
        }

        function normalizeVerseDatabase(db) {
            const out = [];
            const seen = new Set();
            const defaultVersion = '新標點和合本 神版';
            if (!Array.isArray(db)) return out;
            for (const raw of db) {
                const v = raw || {};
                // 正規化書卷名稱以對齊本遊戲清單（避免外部資料使用簡稱或其他變體造成過濾失敗）
                try { v.book = normalizeBookName(v.book); } catch (e) {}
                // 將數字章轉成字串以統一選擇器與渲染（external JSON 可能為數字）
                try { if (typeof v.chapter === 'number') v.chapter = String(v.chapter); } catch(e){}
                // 先清理經文中的括號說明，提升可讀性與易分段性
                try { if (typeof v.verse === 'string') v.verse = sanitizeVerseText(v.verse); } catch(e){}
                // 先做資料面向的有效性驗證（在建立 key 之前）
                if (!isValidVerseRecord(v)) continue;
                // 過濾主題性較弱或含糊對話型的經文（例如：「百姓回答說：…」）
                try {
                    if (isWeakTopicalVerse(v.verse)) continue;
                } catch(_) {}
                const key = `${v.book}|${v.chapter}|${v.verse}|${v.version||''}`;
                if (seen.has(key)) continue;
                seen.add(key);
                // 保留外部提供的版本與稀有度；僅在缺失時回填預設與分類
                try { if (!v.version) v.version = defaultVersion; } catch(e){}
                try {
                    // 將外部提供的罕見度（支援中英文）統一到 canonical 值；若缺失則自動分類
                    const rawR = (v && v.rarity != null) ? String(v.rarity).trim().toLowerCase() : '';
                    if (rawR) {
                        const map = {
                            '常見': 'common', '中等': 'common', '少見': 'uncommon', '冷門': 'rare', '全部': 'all',
                            'common': 'common', 'medium': 'common', 'uncommon': 'uncommon', 'rare': 'rare', 'all': 'all'
                        };
                        v.rarity = map[rawR] || classifyRarity(v);
                    } else {
                        v.rarity = classifyRarity(v);
                    }
                } catch(e){}
                out.push(v);
            }
            return out;
        }

        function getActiveVerseDB() {
            // 改為只使用外部題庫（external-verses.json）；不再使用內建備援
            try {
                const active = (Array.isArray(window.verseDatabase) && window.verseDatabase.length) ? window.verseDatabase : [];
                return normalizeVerseDatabase(active);
            } catch (e) {
                return [];
            }
        }

    // 已棄用：舊版難度→罕見度過濾器（現行模型改為：練習=範圍優先、排行=罕見度優先）
    // function filterByDifficultyAndRarity(...) { /* removed */ }

        function summarizeRarity(db) {
            const sum = { total: 0, common: 0, uncommon: 0, rare: 0 };
            for (const v of (db || [])) {
                sum.total++;
                const r = (v && v.rarity) || 'common';
                if (r === 'common' || r === 'uncommon' || r === 'rare') sum[r]++;
            }
            return sum;
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            initializeGame();
            // Trigger a non-blocking load of leaderboard (online adapter may resolve later)
            try { const r = loadLeaderboard(); if (r && typeof r.then === 'function') { r.then(()=>updateLeaderboardDisplay()); } } catch(_){ }
            initializeVerseMarquee();
            // 啟動起始遮罩：至少顯示 2 秒；待題庫載入完成後淡出約 1 秒
            try {
                const APP_VERSION = 'v0.9.0';
                const overlay = document.getElementById('startupOverlay');
                const ver = document.getElementById('startupVersion');
                const logoEl = document.getElementById('startupLogo');
                const wordEl = document.getElementById('startupWord');
                const loadingEl = document.getElementById('startupLoadingText');
                if (overlay) {
                    if (ver) ver.textContent = APP_VERSION;
                    // 隨機挑選四種版本：
                    // 1) 暗底 + logo1-light / word1-light
                    // 2) 暗底 + logo2-light / word2-light
                    // 3) 亮底 + logo1-dark  / word1-dark
                    // 4) 亮底 + logo2-dark  / word2-dark
                    try {
                        const isDark = (window.__startupIsDark === true);
                        const logoSrc = window.__startupLogoSrc;
                        const wordSrc = window.__startupWordSrc;
                        // 切換主題 class
                        overlay.classList.remove('theme-light','theme-dark');
                        overlay.classList.add(isDark ? 'theme-dark' : 'theme-light');
                        // 立即設定圖片來源（已由 <head> 預先決定並 preload）
                        if (logoEl && logoSrc) logoEl.src = logoSrc;
                        if (wordEl && wordSrc) {
                            wordEl.src = wordSrc;
                            const isWord2 = /word2-(light|dark)\.png$/i.test(wordSrc);
                            wordEl.classList.toggle('variant-word2', !!isWord2);
                        }
                        // Loading 文字固定英文
                        if (loadingEl) loadingEl.textContent = 'Loading...';
                        // 依主題微調 Loading/版本的可讀性
                        if (isDark) {
                            if (ver) ver.style.color = 'rgba(255,255,255,0.9)';
                            if (loadingEl) loadingEl.style.color = 'rgba(255,255,255,0.96)';
                        } else {
                            if (ver) ver.style.color = 'rgba(17,24,39,0.9)';
                            if (loadingEl) loadingEl.style.color = 'rgba(31,41,55,0.95)';
                        }
                    } catch (_) {}
                    const start = Date.now();
                    const minWait = 5000;

                    const waitMin = new Promise(resolve => setTimeout(resolve, minWait));
                    // 若資料已可用，直接視為已載入；否則等待事件
                    const waitLoaded = new Promise(resolve => {
                        try {
                            const hasDataNow = Array.isArray(window.verseDatabase) && window.verseDatabase.length > 0;
                            if (hasDataNow) return resolve();
                            const onLoaded = (ev) => {
                                // 無論成功或失敗，都解除遮罩，讓主畫面顯示相應提示
                                try {
                                    if (ev && ev.detail && typeof ev.detail.hasData !== 'undefined') resolve();
                                } catch(_) {}
                                window.removeEventListener('externalVersesLoaded', onLoaded);
                            };
                            window.addEventListener('externalVersesLoaded', onLoaded);
                            // 保險：若事件未觸發，最長等待 8 秒
                            setTimeout(resolve, 8000);
                        } catch(_) { resolve(); }
                    });

                    Promise.all([waitMin, waitLoaded]).then(() => {
                        // 觸發淡出；transition 結束後移除遮罩
                        overlay.style.opacity = '0';
                        const finalize = () => {
                            overlay.style.display = 'none';
                        };
                        overlay.addEventListener('transitionend', finalize, { once: true });
                        // 保險：若 transitionend 沒觸發，1.1 秒後隱藏
                        setTimeout(finalize, 1100);
                    });
                }
            } catch (e) { /* ignore overlay init errors */ }
        });

        function initializeGame() {
            // 預設：不選罕見度；練習模式預設為整本聖經（range=all），與罕見度互斥
            gameState.range = 'all';
            gameState.rarity = null;
            gameState.mode = null;
            // 初始更新計分規則顯示（時間與基礎分數）
            updateScoreRulesDisplay();
            // 顯式同步時間獎懲說明可視狀態
            const timeRewardNote = document.getElementById('timeRewardNote');
            if (timeRewardNote) timeRewardNote.style.display = gameState.showTimeReward ? 'block' : 'none';
            updateBaseScoreRuleDisplay();
            // ...existing code...
            // 開始畫面按鈕事件
            document.getElementById('startGameBtn').addEventListener('click', startGame);

            // 難度選擇事件
            document.querySelectorAll('.difficulty-option').forEach(option => {
                option.addEventListener('click', selectDifficulty);
                // keyboard activation (Enter / Space)
                option.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        option.click();
                    }
                });
            });

            // 出題範圍事件
            document.querySelectorAll('.range-option').forEach(option => {
                option.addEventListener('click', selectRange);
                // keyboard activation (Enter / Space)
                option.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        option.click();
                    }
                });
            });
            // 罕見度（排行模式）事件
            document.querySelectorAll('.rarity-option').forEach(option => {
                option.addEventListener('click', selectRarity);
                option.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        option.click();
                    }
                });
            });
            
            // 倒數顯示開關事件
            document.getElementById('countdownToggle').addEventListener('change', toggleCountdownDisplay);

            // 恢復使用者偏好設定（難度/罕見度/範圍/時間獎勵）
            // Suppress cute hints while applying saved selections to avoid popping on initial menu
            const __prevSuppress = window.__suppressCuteHints;
            window.__suppressCuteHints = true;
            try {
                const saved = JSON.parse(localStorage.getItem('bibleChallenge.prefs') || '{}');
                if (saved && typeof saved === 'object') {
                    // migrate deprecated rarity 'medium' -> 'common'
                    if (saved.rarity === 'medium') saved.rarity = 'common';
                    if (saved.difficulty) {
                        const btn = document.querySelector(`.difficulty-option[data-difficulty="${saved.difficulty}"]`);
                        if (btn && !btn.classList.contains('selected')) btn.click();
                    }
                    if (saved.rarity) {
                        const btn = document.querySelector(`.rarity-option[data-rarity="${saved.rarity}"]`);
                        if (btn && !btn.classList.contains('selected')) btn.click();
                        // 可能未觸發 click: 確保文字更新
                        updateBaseScoreRuleDisplay();
                    }
                    if (saved.range) {
                        const btn = document.querySelector(`.range-option[data-range="${saved.range}"]`);
                        if (btn && !btn.classList.contains('selected')) btn.click();
                    }
                    if (typeof saved.showTimeReward === 'boolean') {
                        const toggle = document.getElementById('countdownToggle');
                        const txt = document.getElementById('countdownToggleText');
                        if (toggle && txt) {
                            toggle.checked = saved.showTimeReward;
                            gameState.showTimeReward = saved.showTimeReward;
                            txt.textContent = saved.showTimeReward ? '開啟' : '關閉';
                            const note = document.getElementById('timeRewardNote');
                            if (note) note.style.display = saved.showTimeReward ? 'block' : 'none';
                            updateScoreRulesDisplay();
                            updateBaseScoreRuleDisplay();
                        }
                    }
                }
            } catch (e) { /* ignore */ }
            finally { window.__suppressCuteHints = __prevSuppress; }
            
            // 自訂書卷視窗事件
            document.getElementById('closeCustomModal').addEventListener('click', closeCustomModal);
            document.getElementById('cancelCustomSelection').addEventListener('click', closeCustomModal);
            document.getElementById('confirmCustomSelection').addEventListener('click', confirmCustomSelection);

            // 遊戲事件
            document.getElementById('hintBtn').addEventListener('click', useHint);

            document.getElementById('backToMenuFromGame').addEventListener('click', () => {
                document.getElementById('confirmBackModal').classList.remove('hidden');
            });
            document.getElementById('confirmBackBtn').addEventListener('click', () => {
                document.getElementById('confirmBackModal').classList.add('hidden');
                // 強制移除所有遊戲提示
                document.querySelectorAll('.game-instruction').forEach(inst => {
                    if (inst.parentElement) inst.parentElement.removeChild(inst);
                });
                if (gameState.score > 0) {
                    // 中途退出，遊戲未完成
                    gameState.gameCompleted = false;
                    saveScore(gameState.score);
                }
                if (gameState.timerInterval) {
                    clearInterval(gameState.timerInterval);
                }
                showStartScreen();
            });
            document.getElementById('cancelBackBtn').addEventListener('click', () => {
                document.getElementById('confirmBackModal').classList.add('hidden');
            });
            document.getElementById('confirmNameBtn').addEventListener('click', confirmPlayerName);
            document.getElementById('clearAllBooks').addEventListener('click', clearAllBooks);
            
            // 排行榜標籤事件
            document.querySelectorAll('.leaderboard-tab').forEach(tab => {
                tab.addEventListener('click', selectLeaderboardTab);
            });

            // 使用標題左右圖示觸發清空排行榜：任一順序（左->右 或 右->左）在 500ms 內完成皆可
            let lastTitleIconClickedAt = 0;
            let lastTitleIcon = null; // 'left' 或 'right'
            const leftIcon = document.getElementById('titleLeftIcon');
            const rightIcon = document.getElementById('titleRightIcon');

            const openClearModal = () => {
                const modal = document.getElementById('clearLeaderboardModal');
                if (modal) modal.classList.remove('hidden');
                lastTitleIconClickedAt = 0;
                lastTitleIcon = null;
            };

            if (leftIcon) {
                leftIcon.style.cursor = 'pointer';
                leftIcon.addEventListener('click', () => {
                    const now = Date.now();
                    if (lastTitleIcon === 'right' && (now - lastTitleIconClickedAt) <= 700) {
                        openClearModal();
                        return;
                    }
                    lastTitleIcon = 'left';
                    lastTitleIconClickedAt = now;
                });
            }

            if (rightIcon) {
                rightIcon.style.cursor = 'pointer';
                rightIcon.addEventListener('click', () => {
                    const now = Date.now();
                    if (lastTitleIcon === 'left' && (now - lastTitleIconClickedAt) <= 700) {
                        openClearModal();
                        return;
                    }
                    lastTitleIcon = 'right';
                    lastTitleIconClickedAt = now;
                });
            }

            document.getElementById('cancelClearLeaderboard')?.addEventListener('click', () => {
                document.getElementById('clearLeaderboardModal')?.classList.add('hidden');
                lastTitleIconClickedAt = 0;
                lastTitleIcon = null;
            });

            document.getElementById('confirmClearLeaderboard')?.addEventListener('click', () => {
                // 清除排行榜：優先線上，否則清本機
                if (window.Leaderboard && typeof window.Leaderboard.clear === 'function') {
                    window.Leaderboard.clear().catch(()=>{}).finally(() => { updateLeaderboardDisplay(); });
                } else {
                    localStorage.removeItem('bibleGameLeaderboard');
                    updateLeaderboardDisplay();
                }
                document.getElementById('clearLeaderboardModal')?.classList.add('hidden');
                lastTitleIconClickedAt = 0;
                lastTitleIcon = null;
            });

            // 重新播放排行榜紀錄或使用相同題目再來一局的處理
            window.openLeaderboardRecordById = async function(id, difficulty) {
                const ldr = loadLeaderboard();
                const all = (ldr && typeof ldr.then === 'function') ? await ldr : ldr;
                if (!all || !all[difficulty]) return;
                const record = all[difficulty].find(r => String(r.id) === String(id));
                if (!record) return;

                // debug helper: surface whether timeReward was present/estimated for this record
                try {
                    console.log('[DEBUG] openLeaderboardRecordById record:', { id: record.id, score: record.score, timeReward: record.timeReward, timeRewardEstimated: record.timeRewardEstimated, hintsRemaining: record.hintsRemaining, totalHints: record.totalHints });
                } catch (e) {}

                // 填入結算視窗內容（從儲存紀錄填充，不會進行新的儲存）
                document.getElementById('finalScore').textContent = record.score || 0;
                const accuracy = record.totalQuestions ? Math.round(((record.correctAnswers||0)/record.totalQuestions)*100) : 0;
                document.getElementById('finalAccuracy').textContent = `${accuracy}%`;
                const ratioEl = document.getElementById('finalAccuracyRatio');
                if (ratioEl) ratioEl.innerHTML = `<strong>(${record.correctAnswers||0}/${record.totalQuestions||0})</strong>`;

                // 優先使用儲存的結語經文（若有），否則以遊戲結束相同的方式自動選詩句
                const closingTextEl = document.getElementById('closingVerseText');
                const closingRefEl = document.getElementById('closingVerseRef');
                if (record.closingVerse || record.closingVerseRef) {
                    applyClosingVerse(record.closingVerse, record.closingVerseRef, false);
                } else {
                    updateClosingVerse(accuracy);
                }
                // 計算該記錄在該難度排行榜中的名次（若存在）以供顯示標頭
                let computedRank = null;
                try {
                    const list = all[difficulty] || [];
                    for (let idx = 0; idx < list.length; idx++) {
                        const r = list[idx];
                        if (String(r.id) === String(record.id)) {
                            computedRank = idx + 1;
                            break;
                        }
                    }
                } catch (e) { computedRank = null; }

                // Show the player's name for this record
                document.getElementById('rankMessage').textContent = record.playerName || '匿名';
                const hdr = document.getElementById('leaderboardHeader');
                if (hdr) {
                    if (computedRank) {
                        hdr.innerHTML = `
                            <span style="font-weight:800; font-size:1.15rem; background:linear-gradient(90deg,#7c3aed,#ec4899); -webkit-background-clip:text; color:transparent;">第${computedRank}名</span>
                        `;
                    } else {
                        hdr.innerHTML = `<span style="font-weight:700;">檢視記錄</span>`;
                    }
                }

                // 填入隱藏欄位以便後續按鈕使用
                document.getElementById('currentViewedRecordId').value = record.id || '';

                // 填充計分詳細（使用統一的渲染器，與遊戲結束時相同的格式）
                const breakdown = document.getElementById('scoreBreakdownContent');
                if (breakdown) {
                    breakdown.innerHTML = '';
                    try {
                        // use unified renderer; if it throws, fall back to a minimal summary
                        renderScoreBreakdownFromRecord(record);
                    } catch (e) {
                        const rows = [];
                        rows.push(`<div>總分：<strong>${record.score || 0}</strong></div>`);
                        rows.push(`<div>答對：<strong>${(record.correctAnswers||0)}/${(record.totalQuestions||0)}</strong></div>`);
                        rows.push(`<div>失誤：<strong>${record.totalMistakes != null ? record.totalMistakes : '--'}</strong></div>`);
                        // omit time display for record view per UX request
                        breakdown.innerHTML = rows.map(r=>`<div class="text-xs text-gray-700">${r}</div>`).join('');
                    }
                }

                // 顯示 modal
                const modal = document.getElementById('playerNameModal');
                if (modal) {
                    // If modal is nested under a hidden parent (like #gameScreen), move it to document.body
                    if (modal.parentElement !== document.body) {
                        document.body.appendChild(modal);
                    }
                    // 標記為檢視模式，避免在關閉時再次儲存或修改名稱
                    modal.dataset.viewingRecord = 'true';
                    // 記錄當前檢視的排行榜難度，以便關閉後還原同一標籤
                    modal.dataset.viewingDifficulty = difficulty || gameState.difficulty || '';

                    // 隱藏名稱輸入區，禁止在首頁檢視時更改名稱
                    const nameInputSection = document.getElementById('nameInputSection');
                    if (nameInputSection) nameInputSection.classList.add('hidden');
                    const leaderboardMessage = document.getElementById('leaderboardMessage');
                    if (leaderboardMessage) leaderboardMessage.classList.remove('hidden');

                    // When viewing a saved leaderboard record (opened from leaderboard cards),
                    // show the same-question replay button so users can replay that saved snapshot.
                    const replayBtn = document.getElementById('replaySameQuestionsBtn');
                    if (replayBtn) {
                        replayBtn.classList.remove('hidden');
                    }

                    modal.classList.remove('hidden');
                    // lock background scroll for mobile comfort (match showPlayerNameModal)
                    lockBodyScroll();
                    // attach record object for later use
                    modal.dataset.currentRecord = JSON.stringify(record);
                }
            };

            // (removed) replayAgainBtn event listener - button removed from DOM

            // 同樣題目再來一局（不列入排行榜）：載入題組快照並開始遊戲，並設定 skipLeaderboardOnComplete 標誌
            document.getElementById('replaySameQuestionsBtn').addEventListener('click', async () => {
                const modal = document.getElementById('playerNameModal');
                // Detach Enter hotkey as we are leaving the modal context
                try { detachPlayerNameModalEnterHotkey(); } catch (e) {}
                const raw = modal.dataset.currentRecord;
                if (!raw) return;
                const record = JSON.parse(raw);
                // 若沒有快照則無法執行
                if (!record.questionSnapshot) {
                    alert('此紀錄不包含題組快照，無法使用相同題目再來一局。');
                    return;
                }

                // 如果該紀錄已儲存到排行榜（有 id）且玩家名稱為空或為匿名，先提醒使用者
                const nameIsEmptyOrAnonymous = !record.playerName || record.playerName === '匿名';
                const isSavedRecord = !!record.id;
                console.log('[REPLAY] clicked replaySameQuestionsBtn', { recordId: record.id, playerName: record.playerName, isSavedRecord, nameIsEmptyOrAnonymous });
                // 需求：匿名玩家排行榜卡片 → 同題重玩不再跳出確認視窗，直接進行
                // 因此當為匿名紀錄時不顯示任何確認。若未來需對具名紀錄提示，可在此加入額外條件與詢問。

                // 載入快照（快照可能為新格式 { questionData, levelResults, totalQuestions } 或舊格式的陣列）
                gameState.difficulty = record.difficulty || gameState.difficulty;
                gameState.range = record.range || gameState.range;
                gameState.testament = record.testament || gameState.testament;
                gameState.customBooks = record.customBooks || gameState.customBooks;

                // 將題組替換為快照（優先使用 snapshot.questionData），並設定不要儲存排行榜的旗標
                try {
                    const snapshot = (record.questionSnapshot && typeof record.questionSnapshot === 'object' && record.questionSnapshot.questionData) ? record.questionSnapshot.questionData : record.questionSnapshot;
                    gameState.questionData = JSON.parse(JSON.stringify(snapshot || []));
                } catch (e) {
                    // 退回至原值
                    const snapshot = (record.questionSnapshot && record.questionSnapshot.questionData) ? record.questionSnapshot.questionData : record.questionSnapshot;
                    gameState.questionData = snapshot || [];
                }
                gameState.skipLeaderboardOnComplete = true;
                // remember the original record so end-of-replay modal can reuse its static fields (closing verse, date/time)
                gameState.replaySourceRecord = record;
                console.log('[REPLAY] initialized replay flags', { skipLeaderboardOnComplete: gameState.skipLeaderboardOnComplete, replaySourceRecordId: gameState.replaySourceRecord && gameState.replaySourceRecord.id });

                // 關閉 modal 並開始遊戲介面（直接顯示 gameScreen 並初始化狀態為該快照）
                document.getElementById('playerNameModal').classList.add('hidden');
                // ensure background scrolling is restored on mobile
                try { unlockBodyScroll(); } catch(e) {}
                // 手動進入遊戲畫面，避免重新生成題組
                hideAllScreens();
                document.getElementById('gameScreen').classList.remove('hidden');

                // 初始化遊戲狀態 but keep questionData
                gameState.currentLevel = 1;
                gameState.currentQuestion = 1;
                gameState.score = 0;
                gameState.hintsUsed = 0;
                gameState.levelPerfect = true;
                gameState.questionAttempts = {};
                gameState.usedHints = new Set();
                gameState.gameStartTime = Date.now();
                gameState.gameCompleted = false;
                gameState.isFirstQuestionOfLevel = true;
                gameState.consecutiveMistakes = 0;
                gameState.hintReminderShown = false;
                gameState.levelHintReminderShown = false;
                gameState.totalCorrectAnswers = 0;
                gameState.totalQuestions = record.totalQuestions || (gameState.questionData ? gameState.questionData.length : 0);
                // initialize attempts per question so UI logic (selecting / coloring) works
                (function initAttemptsForReplay() {
                    const maxAttemptsMap = { easy: 3, normal: 2, hard: 1 };
                    const perQuestion = maxAttemptsMap[gameState.difficulty] || 3;
                    if (Array.isArray(gameState.questionData)) {
                        gameState.questionData.forEach((q, i) => {
                            gameState.questionAttempts[i] = perQuestion;
                        });
                    }
                    // restore hint counts according to difficulty so hint button behaves
                    const hintCounts = { easy: 5, normal: 3, hard: 1 };
                    gameState.hintsRemaining = hintCounts[gameState.difficulty] || 3;
                })();
                gameState.totalMistakes = 0;
                // For a replay we must start with fresh level results so progress ovals reflect the new run
                gameState.levelResults = {};

                // 初始化題目相關 UI
                updateGameUI();
                displayQuestions();
                updateQuestionOvals();

                // start level timer so time-reward and score updates work for the replayed session
                try {
                    gameState.levelStartTime = Date.now();
                    startLevelTimer();
                } catch (e) {
                    console.warn('Unable to start level timer after replay:', e);
                }
            });
            
            // 書卷搜尋和快速選擇事件
            document.getElementById('bookSearch').addEventListener('input', filterBooks);
            document.getElementById('selectAllBooks').addEventListener('click', selectAllBooksInModal);
            document.getElementById('selectOldTestament').addEventListener('click', selectOldTestamentBooks);
            document.getElementById('selectNewTestament').addEventListener('click', selectNewTestamentBooks);
            
            // 擴展卡片搜尋功能
            document.getElementById('bookSearchExpand').addEventListener('input', filterBooksInExpandCard);
            document.getElementById('selectAllBooksExpand').addEventListener('click', selectAllBooksInExpandCard);
            document.getElementById('clearAllBooksExpand').addEventListener('click', clearAllBooksInExpandCard);

            // 初始化自訂書卷選項
            initializeCustomBooks();
            
            // 初始化排行榜顯示
            updateLeaderboardDisplay();
            try {
                const note = document.getElementById('leaderboardOnlineNote');
                if (note) {
                    if (window.Leaderboard && typeof window.Leaderboard.load === 'function') {
                        note.textContent = '線上排行榜已啟用（Supabase）。';
                    } else {
                        note.textContent = '目前使用本機排行榜（僅此裝置可見）。';
                    }
                }
            } catch(_) {}
            
            // 初始化設定顯示
            updateSettingsDisplay();
            updateStartButtonState();
            updateScoreRulesDisplay();
            // mobile score badge setup: clones encouragement text into front/back titles on narrow viewports
            try { setupMobileScoreBadges(); } catch (e) { console.warn('setupMobileScoreBadges failed', e); }
        }

        // Mobile badge behavior caused duplicate encouragement text on some devices.
        // To preserve the original single `#encouragementText` behavior we clean up
        // any previously-created mobile badges and disconnect observers.
        function setupMobileScoreBadges() {
            try {
                // remove any existing mobile badge elements created previously
                document.querySelectorAll('.mobile-center-badge, .mobile-score-badge').forEach(el => {
                    try {
                        if (el.__hideTimer) {
                            clearTimeout(el.__hideTimer);
                            el.__hideTimer = null;
                        }
                    } catch (e) {}
                    try { if (el.parentElement) el.parentElement.removeChild(el); } catch(e) {}
                });

                // disconnect any mutation observers attached to the encouragement element
                const encEl = document.getElementById('encouragementText');
                if (encEl && encEl.__mobileBadgeObserver) {
                    try { encEl.__mobileBadgeObserver.disconnect(); } catch(e) {}
                    try { delete encEl.__mobileBadgeObserver; } catch(e) {}
                }

                // ensure the original encouragement text is visible and left to its original logic
                try { if (encEl) encEl.style.visibility = ''; } catch(e) {}
            } catch (e) {
                console.warn('setupMobileScoreBadges cleanup failed', e);
            }
            // intentionally do not create badges here — original element will control display
            return;
        }

        function showStartScreen() {
            // 直接顯示開始畫面
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('verseMarquee').style.display = 'block';
            // Ensure body scroll is restored when showing the start screen
            try { unlockBodyScroll(); } catch (e) {}
            // Hide any lingering cute hint when returning to start screen
            try { hideCuteHint(); } catch (e) {}
            // ...existing code...
            // 解鎖所有主畫面按鈕
            lockMainScreenButtons(false);
            
            // 重置開始按鈕狀態
            const startBtn = document.getElementById('startGameBtn');
            startBtn.style.border = '';
            startBtn.style.boxShadow = '';
            startBtn.disabled = false;
            startBtn.style.opacity = '';
            startBtn.style.cursor = '';
            startBtn.style.pointerEvents = '';
            
            // 更新按鈕狀態
            updateStartButtonState();
            
            // 如果有遊戲狀態，切換到對應難度的排行榜
            if (gameState.difficulty) {
                updateLeaderboardDisplay(gameState.difficulty);
                // 更新排行榜標籤
                document.querySelectorAll('.leaderboard-tab').forEach(tab => {
                    tab.classList.remove('bg-blue-500', 'text-white');
                    tab.classList.add('text-gray-600');
                });
                const targetTab = document.querySelector(`.leaderboard-tab[data-difficulty="${gameState.difficulty}"]`);
                if (targetTab) {
                    targetTab.classList.add('bg-blue-500', 'text-white');
                    targetTab.classList.remove('text-gray-600');
                }
            } else {
                updateLeaderboardDisplay();
            }
        }
        
    // 副標題功能已移除

        function hideAllScreens() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('verseMarquee').style.display = 'none';
        }

    // Cute hint bar helpers and message pools
    let cuteHintTimer = null;
    // Global flag to suppress cute hints during programmatic initialization
    window.__suppressCuteHints = window.__suppressCuteHints || false;
        const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
        const randBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const formatTemplate = (tpl, data) => tpl.replace(/\{(\w+)\}/g, (_, k) => (data && k in data) ? data[k] : _);

        const HINTS = {
            difficulty: {
                easy: [
                    '耶～簡單入門！配對經文暖暖上手～',
                    '簡單模式啟動，先感受一下節奏吧～'
                ],
                normal: [
                    '普通模式來囉！配對書卷，挑戰剛剛好～',
                    '中等挑戰開啟，穩穩來最厲害～'
                ],
                hard: [
                    '困難模式點亮！配對章節，高手請進～',
                    '進階挑戰開打，深呼吸～衝！'
                ],
                cancel: [
                    '先不選難度也可以～慢慢挑喔！'
                ]
            },
            rarity: {
                common: [
                    '選了常見經文～經典不敗，讚讚！',
                    '常見池上線，熟悉的味道來了～'
                ],
                rare: [
                    '挑戰冷門經文！小眾也很寶貴～',
                    '冷門＆少見集合，準備挖寶囉～'
                ],
                all: [
                    '全範圍任你挑～豐富又好玩！',
                    '全部經文開放，出題更有驚喜～'
                ],
                cancel: [
                    '先不排排行也行～之後再選！'
                ]
            },
            range: {
                all: [
                    '整本聖經走起～冒險從創世記到啟示錄！'
                ],
                old: [
                    '鎖定舊約～智慧與歷史滿滿的祝福！'
                ],
                new: [
                    '新約專區～福音與書信給你力量！'
                ],
                custom: [
                    '自訂範圍上線～照你的步調就對了！'
                ],
                cancel: [
                    '先選出題範圍吧～我在這裡等你！'
                ]
            },
            time: {
                on: [
                    '時間獎懲開啟！快狠準再加分～',
                    '計時啟動～把握節奏更刺激！'
                ],
                off: [
                    '時間獎懲關閉～專心沉浸不趕時間～',
                    '先不計時也很棒～慢慢享受文字～'
                ]
            },
            hintReminder: [
                '卡住沒關係～提示在這裡等你喔！',
                '需要小幫手嗎？點提示一起前進～'
            ],
            customConfirm: [
                '已選 {count} 本書卷～客製化最貼心！',
                '自訂範圍完成：{count} 本，讚讚！'
            ],
            play: {
                introEasy: [
                    '先挑一段經文吧～出發！',
                    '選一段喜歡的經文，開始暖身～'
                ],
                introOther: [
                    '先挑一段經文吧～準備配對囉！',
                    '請先選一段經文～等等要來配對了！'
                ],
                pairEasy: [
                    '把它跟另一半配對起來～加油！',
                    '找找看後半段在哪裡～你可以的！'
                ],
                pairOther: [
                    '選出正確的章節～穩穩拿分！',
                    '章節在哪裡呢？鎖定它！'
                ]
            }
        };

        function showCuteHint(messageOrArray, theme = 'purple', duration, icon = '✨') {
            // Skip toasts when suppressed (e.g., on initial default selections)
            if (window.__suppressCuteHints) return;
            const bar = document.getElementById('cuteHintBar');
            if (!bar) return;

            const message = Array.isArray(messageOrArray) ? pick(messageOrArray) : messageOrArray;
            const showMs = typeof duration === 'number' ? (duration <= 0 ? null : duration) : randBetween(2200, 2600);

            // Apply content and theme
            bar.className = `cute-hint ${theme}`;
            bar.querySelector('.cute-hint-icon').textContent = icon;
            bar.querySelector('.cute-hint-text').textContent = message;

            // Show with slide-up + fade-in
            if (cuteHintTimer) { clearTimeout(cuteHintTimer); cuteHintTimer = null; }
            bar.style.display = 'flex';
            // force reflow then add .show
            void bar.offsetWidth; 
            bar.classList.add('show');

            // Auto hide with fade-out then display:none (skip when duration<=0)
            if (showMs !== null) {
                cuteHintTimer = setTimeout(() => {
                    bar.classList.remove('show');
                    const hideDelay = 220; // match CSS transition
                    setTimeout(() => { bar.style.display = 'none'; }, hideDelay);
                }, showMs);
            }
        }

        // Hide the cute hint immediately (used when user已經進入下一步或作答)
        function hideCuteHint() {
            const bar = document.getElementById('cuteHintBar');
            if (!bar) return;
            if (cuteHintTimer) { try { clearTimeout(cuteHintTimer); } catch (_) {} cuteHintTimer = null; }
            try {
                bar.classList.remove('show');
                setTimeout(() => { bar.style.display = 'none'; }, 200);
            } catch (_) {}
        }

        function selectDifficulty(e) {
            const clickedOption = e.currentTarget;
            const isCurrentlySelected = clickedOption.classList.contains('selected');
            
            // 移除所有選中/高亮相關狀態，並還原為每種難度的原始淺色背景與細邊框
            document.querySelectorAll('.difficulty-option').forEach(opt => {
                // remove any possible selected/highlight classes (including color variants)
                opt.classList.remove(
                    'selected', 'border-amber-500', 'border-4', 'shadow-lg',
                    'border-green-600', 'border-yellow-600', 'border-red-600',
                    'bg-green-100', 'bg-yellow-100', 'bg-red-100'
                );

                // 恢復原始邊框與背景（淺色）
                if (opt.dataset.difficulty === 'easy') {
                    opt.classList.add('border-green-300', 'border-2', 'bg-gradient-to-br', 'from-green-50', 'to-green-100');
                } else if (opt.dataset.difficulty === 'normal') {
                    opt.classList.add('border-yellow-300', 'border-2', 'bg-gradient-to-br', 'from-yellow-50', 'to-yellow-100');
                } else if (opt.dataset.difficulty === 'hard') {
                    opt.classList.add('border-red-300', 'border-2', 'bg-gradient-to-br', 'from-red-50', 'to-red-100');
                }
            });
            
            if (isCurrentlySelected) {
                // 如果點擊的是已選中的選項，則取消選擇
                gameState.difficulty = null;
                showCuteHint(HINTS.difficulty.cancel, 'purple', undefined, '🎯');
            } else {
                // 選中新的選項
                if (clickedOption.dataset.difficulty === 'easy') {
                    clickedOption.classList.add('selected', 'border-green-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-green-300', 'border-2');
                    showCuteHint(HINTS.difficulty.easy, 'green', undefined, '🌱');
                } else if (clickedOption.dataset.difficulty === 'normal') {
                    clickedOption.classList.add('selected', 'border-yellow-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-yellow-300', 'border-2');
                    showCuteHint(HINTS.difficulty.normal, 'amber', undefined, '⭐');
                } else if (clickedOption.dataset.difficulty === 'hard') {
                    clickedOption.classList.add('selected', 'border-red-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-red-300', 'border-2');
                    showCuteHint(HINTS.difficulty.hard, 'red', undefined, '🔥');
                }
                gameState.difficulty = clickedOption.dataset.difficulty;
            }
            
            updateSettingsDisplay();
            updateStartButtonState();
            // 儲存偏好
            persistPrefs({ difficulty: gameState.difficulty });
        }

    function updateSettingsDisplay() {
            // 更新遊戲中的設定顯示
            const difficultyText = { easy: '簡單（配對經文）', normal: '普通（配對書卷）', hard: '困難（配對章節）' };
            const gameDifficultyDisplay = document.getElementById('gameDifficultyDisplay');
            const gameRangeDisplay = document.getElementById('gameRangeDisplay');
            
            if (gameDifficultyDisplay && gameState.difficulty) {
                gameDifficultyDisplay.textContent = difficultyText[gameState.difficulty];
                
                // 更新難度卡片顏色
                const difficultyCard = gameDifficultyDisplay.parentElement;
                difficultyCard.className = 'rounded-lg p-2 border flex-1';
                
                if (gameState.difficulty === 'easy') {
                    // 清除任何潛在的錯誤類別再套用綠色樣式
                    clearErrorState(difficultyCard);
                    difficultyCard.classList.add('bg-green-100', 'border-green-200');
                    gameDifficultyDisplay.className = 'font-bold text-green-700 text-base';
                } else if (gameState.difficulty === 'normal') {
                    difficultyCard.classList.add('bg-yellow-100', 'border-yellow-200');
                    gameDifficultyDisplay.className = 'font-bold text-yellow-700 text-base';
                } else if (gameState.difficulty === 'hard') {
                    difficultyCard.classList.add('bg-red-100', 'border-red-200');
                    gameDifficultyDisplay.className = 'font-bold text-red-700 text-base';
                }
            }
            
            if (gameRangeDisplay) {
                // 練習模式：顯示出題範圍（舊約/新約/自訂/整本）
                let rangeText = '整本聖經';
                if (gameState.range === 'testament') {
                    rangeText = gameState.testament === 'old' ? '舊約' : '新約';
                } else if (gameState.range === 'custom') {
                    rangeText = `自訂 (${gameState.customBooks.length}本)`;
                }
                // 若選擇排行模式（選了罕見度），於此也提示罕見度
                if (gameState.rarity) {
                    const rarityLabel = { common: '常見', rare: '冷門', all: '全部' }[gameState.rarity] || '';
                    gameRangeDisplay.textContent = `排行：${rarityLabel}`;
                } else {
                    gameRangeDisplay.textContent = rangeText;
                }
                
                // 更新範圍卡片顏色
                const rangeCard = gameRangeDisplay.parentElement;
                rangeCard.className = 'rounded-lg p-2 border flex-1';
                
                if (gameState.rarity) {
                    // 排行模式色系沿用紫色
                    rangeCard.classList.add('bg-purple-100', 'border-purple-200');
                    gameRangeDisplay.className = 'font-bold text-purple-700 text-sm';
                } else if (gameState.range === 'all') {
                    rangeCard.classList.add('bg-purple-100', 'border-purple-200');
                    gameRangeDisplay.className = 'font-bold text-purple-700 text-sm';
                } else if (gameState.range === 'testament') {
                    rangeCard.classList.add('bg-blue-100', 'border-blue-200');
                    gameRangeDisplay.className = 'font-bold text-blue-700 text-sm';
                } else if (gameState.range === 'custom') {
                    rangeCard.classList.add('bg-orange-100', 'border-orange-200');
                    gameRangeDisplay.className = 'font-bold text-orange-700 text-sm';
                }
            }
        }

        function selectRarity(e) {
            const clicked = e.currentTarget;
            const isSelected = clicked.classList.contains('selected');
            // reset visual state
            document.querySelectorAll('.rarity-option').forEach(opt => {
                opt.classList.remove('selected', 'border-purple-600', 'border-4', 'shadow-lg');
                opt.setAttribute('aria-pressed', 'false');
                opt.classList.add('border-purple-300', 'border-2');
            });
            if (isSelected) {
                gameState.rarity = null;
                gameState.mode = null;
                clicked.setAttribute('aria-pressed', 'false');
                showCuteHint(HINTS.rarity.cancel, 'purple', undefined, '🏆');
            } else {
                clicked.classList.add('selected', 'border-purple-600', 'border-4', 'shadow-lg');
                clicked.classList.remove('border-purple-300', 'border-2');
                clicked.setAttribute('aria-pressed', 'true');
                gameState.rarity = clicked.dataset.rarity;
                gameState.mode = 'ranking';
                // rarity hints
                const r = gameState.rarity;
                const pool = (r === 'common') ? HINTS.rarity.common
                           : (r === 'rare') ? HINTS.rarity.rare
                           : HINTS.rarity.all;
                showCuteHint(pool, 'purple', undefined, '🔎');
                // 與練習範圍互斥：清除任何範圍選擇
                document.querySelectorAll('.range-option').forEach(opt => {
                    opt.classList.remove('selected', 'border-purple-600', 'border-blue-600', 'border-orange-600', 'border-4', 'shadow-lg');
                    opt.setAttribute('aria-pressed', 'false');
                    // 恢復原始邊框樣式
                    if (opt.dataset.range === 'all') {
                        opt.classList.add('border-purple-300', 'border-2');
                    } else if (opt.dataset.range === 'testament') {
                        opt.classList.add('border-blue-300', 'border-2');
                    } else if (opt.dataset.range === 'custom') {
                        opt.classList.add('border-orange-300', 'border-2');
                    }
                });
                gameState.range = null;
            }
            // 清除自訂擴展卡片顯示（避免同時展開）
            document.getElementById('rangeWarning')?.classList.add('hidden');
            document.getElementById('customBooksExpandCard')?.classList.add('hidden');
            updateSettingsDisplay();
            updateBaseScoreRuleDisplay();
            updateStartButtonState();
            persistPrefs({ rarity: gameState.rarity, range: gameState.range });
        }

        function selectLeaderboardTab(e) {
            // 更新標籤樣式
            document.querySelectorAll('.leaderboard-tab').forEach(tab => {
                tab.classList.remove('bg-blue-500', 'text-white');
                tab.classList.add('text-gray-600');
            });
            e.currentTarget.classList.add('bg-blue-500', 'text-white');
            e.currentTarget.classList.remove('text-gray-600');
            
            // 更新排行榜顯示
            const selectedDifficulty = e.currentTarget.dataset.difficulty;
            updateLeaderboardDisplay(selectedDifficulty);
        }

        function selectRange(e) {
            const clickedOption = e.currentTarget;
            const isCurrentlySelected = clickedOption.classList.contains('selected');
            
            // 移除所有選中狀態
            document.querySelectorAll('.range-option').forEach(opt => {
                opt.classList.remove('selected', 'border-purple-600', 'border-blue-600', 'border-orange-600', 'border-4', 'shadow-lg');
                opt.setAttribute('aria-pressed', 'false');
                // 恢復原始邊框樣式
                if (opt.dataset.range === 'all') {
                    opt.classList.add('border-purple-300', 'border-2');
                } else if (opt.dataset.range === 'testament' && opt.dataset.testament === 'old') {
                    opt.classList.add('border-blue-300', 'border-2');
                } else if (opt.dataset.range === 'testament' && opt.dataset.testament === 'new') {
                    opt.classList.add('border-blue-300', 'border-2');
                } else if (opt.dataset.range === 'custom') {
                    opt.classList.add('border-orange-300', 'border-2');
                }
            });

            // 與排行罕見度互斥：清除罕見度選擇
            document.querySelectorAll('.rarity-option').forEach(opt => {
                opt.classList.remove('selected', 'border-purple-600', 'border-4', 'shadow-lg');
                opt.classList.add('border-purple-300', 'border-2');
                opt.setAttribute('aria-pressed', 'false');
            });
            gameState.rarity = null;
            gameState.mode = null;

            // 隱藏警告訊息和自訂擴展卡片
            document.getElementById('rangeWarning').classList.add('hidden');
            document.getElementById('customBooksExpandCard').classList.add('hidden');
            
            if (isCurrentlySelected) {
                // 如果點擊的是已選中的選項，則取消選擇
                gameState.range = null;
                gameState.testament = 'old'; // 重置為預設值
                clickedOption.setAttribute('aria-pressed', 'false');
                showCuteHint(HINTS.range.cancel, 'blue', undefined, '📚');
            } else {
                // 選中新的選項
                if (clickedOption.dataset.range === 'all') {
                    clickedOption.classList.add('selected', 'border-purple-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-purple-300', 'border-2');
                    showCuteHint(HINTS.range.all, 'purple', undefined, '📖');
                } else if (clickedOption.dataset.range === 'testament') {
                    clickedOption.classList.add('selected', 'border-blue-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-blue-300', 'border-2');
                    const t = clickedOption.dataset.testament === 'old' ? HINTS.range.old : HINTS.range.new;
                    showCuteHint(t, 'blue', undefined, '🧭');
                } else if (clickedOption.dataset.range === 'custom') {
                    clickedOption.classList.add('selected', 'border-orange-600', 'border-4', 'shadow-lg');
                    clickedOption.classList.remove('border-orange-300', 'border-2');
                    showCuteHint(HINTS.range.custom, 'amber', undefined, '🧩');
                }
                gameState.range = clickedOption.dataset.range;
                clickedOption.setAttribute('aria-pressed', 'true');
                
                // 處理不同範圍類型
                if (gameState.range === 'testament') {
                    gameState.testament = clickedOption.dataset.testament;
                } else if (gameState.range === 'custom') {
                    // 顯示自訂書卷擴展卡片
                    showCustomBooksExpandCard();
                }
            }
            
            updateSettingsDisplay();
            updateBaseScoreRuleDisplay();
            updateStartButtonState();
            // 儲存偏好
            persistPrefs({ range: gameState.range, rarity: gameState.rarity });
        }



        function toggleCountdownDisplay() {
            const toggle = document.getElementById('countdownToggle');
            const toggleText = document.getElementById('countdownToggleText');
            
            gameState.showTimeReward = toggle.checked;
            toggleText.textContent = gameState.showTimeReward ? '開啟' : '關閉';
            // cute hint for time reward toggle
            if (gameState.showTimeReward) {
                showCuteHint(HINTS.time.on, 'blue', 2400, '⏱️');
            } else {
                showCuteHint(HINTS.time.off, 'blue', 2400, '😌');
            }
            
            // 更新計分說明顯示
            updateScoreRulesDisplay();
            
            // 如果在遊戲中，立即更新顯示
            if (!document.getElementById('gameScreen').classList.contains('hidden')) {
                updateTimeRewardVisibility();
            }
            // 儲存偏好
            persistPrefs({ showTimeReward: gameState.showTimeReward });
        }

        function persistPrefs(partial) {
            try {
                const key = 'bibleChallenge.prefs';
                const saved = JSON.parse(localStorage.getItem(key) || '{}') || {};
                const next = { ...saved, ...partial };
                localStorage.setItem(key, JSON.stringify(next));
            } catch (e) { /* ignore */ }
        }

        function updateTimeRewardVisibility() {
            const currentScoreDisplay = document.getElementById('currentScoreDisplay');
            const timeRewardProgressContainer = document.getElementById('timeRewardProgressContainer');
            const timeRewardProgressText = document.getElementById('timeRewardProgressText');
            
            if (gameState.showTimeReward) {
                if (currentScoreDisplay) currentScoreDisplay.style.display = 'block';
                if (timeRewardProgressContainer) timeRewardProgressContainer.style.display = 'block';
                if (timeRewardProgressText) timeRewardProgressText.style.display = 'block';
            } else {
                if (currentScoreDisplay) currentScoreDisplay.style.display = 'none';
                if (timeRewardProgressContainer) timeRewardProgressContainer.style.display = 'none';
                if (timeRewardProgressText) timeRewardProgressText.style.display = 'none';
            }
        }

        function updateScoreRulesDisplay() {
            const timeRewardRule = document.getElementById('timeRewardRule');
            const timeRewardNote = document.getElementById('timeRewardNote');
            
            if (gameState.showTimeReward) {
                if (timeRewardRule) timeRewardRule.style.display = 'flex';
                if (timeRewardNote) timeRewardNote.style.display = 'block';
                // 排行模式每題基礎分：common=100, rare=150, all=200（顯示於下方規則區）
            } else {
                if (timeRewardRule) timeRewardRule.style.display = 'none';
                if (timeRewardNote) timeRewardNote.style.display = 'none';
            }
        }

        // 更新「基礎分數」說明字樣，會隨罕見度按鈕切換
    function updateBaseScoreRuleDisplay() {
            const el = document.getElementById('baseScoreRuleValue');
            if (!el) return;
            const labelMap = { common: '常見', rare: '冷門', all: '全部' };
            // 練習模式（有 range）一律顯示 100；排行模式時依罕見度
            const inPractice = !!gameState.range;
            const perQMap = { common: 100, rare: 125, all: 150 };
            if (inPractice) {
                el.textContent = '+100分/題';
                return;
            }
            if (gameState.rarity && perQMap[gameState.rarity]) {
                const perQ = perQMap[gameState.rarity];
                el.textContent = `+${perQ}分/題`;
            } else {
                el.textContent = '+100/125/150分/題';
            }
        }



        function showCustomBooksExpandCard() {
            const expandCard = document.getElementById('customBooksExpandCard');
            expandCard.classList.remove('hidden');
            // 初始化書卷選項
            initializeCustomBooksInExpandCard();
        }

        function openCustomModal() {
            document.getElementById('customBooksModal').classList.remove('hidden');
            // 重新初始化書卷選項
            initializeCustomBooksInModal();
        }

        function closeCustomModal() {
            document.getElementById('customBooksModal').classList.add('hidden');
            // 如果沒有選擇任何書卷，取消自訂範圍選擇
            if (gameState.customBooks.length === 0) {
                gameState.range = null;
                document.querySelectorAll('.range-option').forEach(opt => {
                    opt.classList.remove('selected', 'border-purple-500', 'border-4', 'shadow-lg');
                    opt.classList.add('border-gray-300', 'border-2');
                });
                updateSettingsDisplay();
                updateStartButtonState();
            }
        }

        function confirmCustomSelection() {
            // 檢查各難度的最低書卷要求
            if (gameState.difficulty === 'normal' && gameState.customBooks.length < 3) {
                showCuteHint('普通難度：自訂範圍至少選 3 本書卷', 'rose', undefined, '⚠️');
                return;
            }
            if ((gameState.difficulty === 'easy' || gameState.difficulty === 'hard') && gameState.customBooks.length < 1) {
                showCuteHint(`${gameState.difficulty === 'easy' ? '簡單' : '困難'}難度：自訂範圍至少選 1 本書卷`, 'rose', undefined, '⚠️');
                return;
            }
            
            // 確認選擇，關閉視窗
            showCuteHint(formatTemplate(pick(HINTS.customConfirm), { count: gameState.customBooks.length }), 'amber', undefined, '✅');
            closeCustomModal();
            updateSettingsDisplay();
            updateStartButtonState();
        }

        function initializeCustomBooks() {
            // 這個函數現在只是為了保持兼容性，實際初始化在各自的函數中進行
        }

        function initializeCustomBooksInExpandCard() {
            const container = document.querySelector('#customBooksExpandCard #customBooksExpand');
            container.innerHTML = '';
            const allBooks = [...bibleBooks.old, ...bibleBooks.new];
            allBooks.forEach(book => {
                const isSelected = gameState.customBooks.includes(book);
                const abbreviation = bookAbbreviations[book] || book;
                const btn = document.createElement('button');
                btn.type = 'button';
                // larger tappable target, centered abbreviation, visual selected state
                // don't force full width so grid can place multiple items per row on small screens
                btn.className = `inline-flex items-center justify-center px-3 py-2 rounded-lg border text-sm font-medium transition-all duration-150 ${isSelected ? 'bg-orange-400 text-white border-orange-600 shadow-md scale-105' : 'bg-white text-gray-700 border-gray-300 hover:bg-orange-50'}`;
                btn.style.minWidth = '64px';
                btn.style.width = 'auto';
                btn.title = book;
                btn.textContent = abbreviation;
                btn.setAttribute('data-book', book);
                btn.addEventListener('click', function() {
                    // toggle selection state
                    if (gameState.customBooks.includes(book)) {
                        gameState.customBooks = gameState.customBooks.filter(b => b !== book);
                    } else {
                        gameState.customBooks.push(book);
                    }
                    // re-render to reflect selection
                    initializeCustomBooksInExpandCard();
                    updateSettingsDisplay();
                    updateStartButtonState();
                });
                container.appendChild(btn);
            });
            // ensure the container uses an auto-fit responsive grid so many items can appear per row on narrow screens
            container.style.gridTemplateColumns = 'repeat(auto-fit, minmax(64px, 1fr))';
        }

        function initializeCustomBooksInModal() {
            const container = document.querySelector('#customBooksModal #customBooks');
            container.innerHTML = ''; // 清空容器

            // render as responsive auto-fit grid of tiles for easier mobile tapping
            container.className = 'grid gap-2 mb-4 max-h-64 overflow-y-auto';
            container.style.gridTemplateColumns = 'repeat(auto-fit, minmax(80px, 1fr))';

            const allBooks = [...bibleBooks.old, ...bibleBooks.new];

            allBooks.forEach(book => {
                const isSelected = gameState.customBooks.includes(book);
                const tile = document.createElement('label');
                // use inline-flex so tiles can size to the grid cell and allow multiple per row
                tile.className = `relative cursor-pointer select-none inline-flex items-center justify-center rounded-lg p-2 text-center border ${isSelected ? 'bg-orange-400 text-white border-orange-600 shadow-md' : 'bg-white text-gray-800 border-gray-200 hover:bg-gray-50'}`;
                tile.style.minHeight = '44px';
                tile.style.alignItems = 'center';
                tile.style.justifyContent = 'center';
                tile.setAttribute('data-book', book);

                tile.innerHTML = `
                    <input type="checkbox" class="absolute left-2 top-2" data-book="${book}" ${isSelected ? 'checked' : ''} />
                    <div class="flex items-center justify-center h-full">
                        <div class="text-sm font-medium truncate" title="${book}">${book}</div>
                    </div>
                `;

                container.appendChild(tile);

                // toggle when clicking tile or checkbox
                const input = tile.querySelector('input');
                input.addEventListener('change', () => {
                    updateCustomBooks();
                });
                tile.addEventListener('click', (e) => {
                    // avoid double-toggling when clicking the checkbox
                    if (e.target === input) return;
                    input.checked = !input.checked;
                    updateCustomBooks();
                });
            });

            // 更新選擇數量顯示
            updateSelectedCount();
        }

        function updateCustomBooksFromExpandCard() {
            const checkboxes = document.querySelectorAll('#customBooksExpandCard #customBooksExpand input[type="checkbox"]');
            gameState.customBooks = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.book);
            
            updateSettingsDisplay();
            updateStartButtonState();
        }

        function updateCustomBooks() {
            const checkboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');
            gameState.customBooks = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.book);
            
            updateSelectedCount();
        }

        function updateSelectedCount() {
            const countElement = document.querySelector('#customBooksModal #selectedCount');
            if (countElement) {
                countElement.textContent = `已選: ${gameState.customBooks.length}本`;
            }
        }

        function clearAllBooks() {
            // 檢查是在擴展卡片還是模態視窗中
            const expandCardCheckboxes = document.querySelectorAll('#customBooksExpandCard #customBooksExpand input[type="checkbox"]');
            const modalCheckboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');
            
            if (expandCardCheckboxes.length > 0) {
                expandCardCheckboxes.forEach(cb => cb.checked = false);
                gameState.customBooks = [];
                updateSettingsDisplay();
                updateStartButtonState();
                
                // 如果沒有選擇任何書卷，隱藏擴展卡片
                if (gameState.customBooks.length === 0) {
                    document.getElementById('customBooksExpandCard').classList.add('hidden');
                    // 取消自訂範圍選擇
                    gameState.range = null;
                    document.querySelectorAll('.range-option').forEach(opt => {
                        opt.classList.remove('selected', 'border-purple-500', 'border-4', 'shadow-lg');
                        opt.classList.add('border-gray-300', 'border-2');
                    });
                    updateSettingsDisplay();
                    updateStartButtonState();
                }
            } else if (modalCheckboxes.length > 0) {
                modalCheckboxes.forEach(cb => cb.checked = false);
                gameState.customBooks = [];
                updateSelectedCount();
            }
        }
        
        function filterBooks() {
            const searchTerm = document.getElementById('bookSearch').value.toLowerCase();
            // target both modal tiles (label) and expand-card buttons
            const modalTiles = document.querySelectorAll('#customBooksModal #customBooks label');
            const expandBtns = document.querySelectorAll('#customBooksExpandCard #customBooksExpand button');
            modalTiles.forEach(tile => {
                const bookName = (tile.getAttribute('data-book') || tile.textContent || '').toLowerCase();
                tile.style.display = bookName.includes(searchTerm) ? '' : 'none';
            });
            expandBtns.forEach(btn => {
                const bookName = (btn.getAttribute('data-book') || btn.textContent || '').toLowerCase();
                btn.style.display = bookName.includes(searchTerm) ? '' : 'none';
            });
        }
        
        function selectOldTestamentBooks() {
            // 支援兩種 UI：擴展卡片（按鈕）與模態（勾選框）
            const expandButtons = document.querySelectorAll('#customBooksExpandCard #customBooksExpand button[data-book]');
            const modalCheckboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');

            if (expandButtons.length > 0) {
                const set = new Set(gameState.customBooks);
                bibleBooks.old.forEach(b => set.add(b));
                gameState.customBooks = Array.from(set);
                initializeCustomBooksInExpandCard();
                updateSettingsDisplay();
                updateStartButtonState();
            }
            if (modalCheckboxes.length > 0) {
                modalCheckboxes.forEach(cb => {
                    if (bibleBooks.old.includes(cb.dataset.book)) {
                        cb.checked = true;
                    }
                });
                updateCustomBooks();
            }
        }
        
        function selectNewTestamentBooks() {
            // 支援兩種 UI：擴展卡片（按鈕）與模態（勾選框）
            const expandButtons = document.querySelectorAll('#customBooksExpandCard #customBooksExpand button[data-book]');
            const modalCheckboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');

            if (expandButtons.length > 0) {
                const set = new Set(gameState.customBooks);
                bibleBooks.new.forEach(b => set.add(b));
                gameState.customBooks = Array.from(set);
                initializeCustomBooksInExpandCard();
                updateSettingsDisplay();
                updateStartButtonState();
            }
            if (modalCheckboxes.length > 0) {
                modalCheckboxes.forEach(cb => {
                    if (bibleBooks.new.includes(cb.dataset.book)) {
                        cb.checked = true;
                    }
                });
                updateCustomBooks();
            }
        }

        function selectAllBooksInModal() {
            const modalCheckboxes = document.querySelectorAll('#customBooksModal #customBooks input[type="checkbox"]');
            modalCheckboxes.forEach(cb => cb.checked = true);
            updateCustomBooks();
        }

        function selectAllBooksInExpandCard() {
            const allBooks = [...bibleBooks.old, ...bibleBooks.new];
            gameState.customBooks = allBooks.slice();
            initializeCustomBooksInExpandCard();
            updateSettingsDisplay();
            updateStartButtonState();
        }
        
        function filterBooksInExpandCard() {
            const searchTerm = document.getElementById('bookSearchExpand').value.toLowerCase();
            // expand card uses buttons, target those
            const btns = document.querySelectorAll('#customBooksExpandCard #customBooksExpand button');
            btns.forEach(btn => {
                const bookName = (btn.getAttribute('data-book') || btn.textContent || '').toLowerCase();
                if (bookName.includes(searchTerm)) btn.style.display = '';
                else btn.style.display = 'none';
            });
        }
        
        function clearAllBooksInExpandCard() {
            // 擴展卡片使用按鈕，不存在 checkbox；直接清空選擇
            gameState.customBooks = [];
            initializeCustomBooksInExpandCard();
            updateSettingsDisplay();
            updateStartButtonState();

            // 隱藏擴展卡片並重置自訂範圍
            document.getElementById('customBooksExpandCard').classList.add('hidden');
            gameState.range = null;
            document.querySelectorAll('.range-option').forEach(opt => {
                opt.classList.remove('selected', 'border-purple-500', 'border-4', 'shadow-lg');
                opt.classList.add('border-gray-300', 'border-2');
            });
            updateSettingsDisplay();
            updateStartButtonState();
        }

        function updateStartButtonState() {
            const startBtn = document.getElementById('startGameBtn');
            const hintElement = document.getElementById('gameStartHint');
            const activeDB = getActiveVerseDB();
            const hasData = Array.isArray(activeDB) && activeDB.length > 0;
            // 可以以「排行模式（選罕見度）」或「練習模式（選範圍）」開始
            const hasRanking = !!gameState.rarity;
            const hasPractice = !!gameState.range;
            let canStart = !!(gameState.difficulty && (hasRanking || hasPractice) && hasData);
            
            // 檢查可開始條件：所有模式至少需有基本題數；「自訂範圍」在普通 >=3，本；簡單/困難 >=1 本
            if (canStart && hasPractice) {
                const availableVerses = getAvailableVerses();
                if (gameState.range === 'custom') {
                    if (gameState.difficulty === 'normal' && gameState.customBooks.length < 3) {
                        canStart = false;
                    }
                    if ((gameState.difficulty === 'easy' || gameState.difficulty === 'hard') && gameState.customBooks.length < 1) {
                        canStart = false;
                    }
                }
                canStart = canStart && availableVerses.length >= 5;
            }
            
            if (canStart) {
                // 可以開始遊戲，添加縮放提醒效果
                startBtn.classList.add('start-button-pulse');
                startBtn.disabled = false;
                startBtn.style.cursor = 'pointer';
                startBtn.style.opacity = '1';
                hintElement.style.opacity = '0';
            } else {
                // 不能開始遊戲，移除提醒效果並顯示提示
                startBtn.classList.remove('start-button-pulse');
                startBtn.disabled = true;
                startBtn.style.cursor = 'not-allowed';
                startBtn.style.opacity = '0.6';
                hintElement.style.opacity = '1';
                
                // 根據缺少的選項更新提示文字
                if (!hasData) {
                    // 若以 file:// 開啟，瀏覽器會阻擋 fetch JSON；引導使用本機伺服器
                    if (location && location.protocol === 'file:') {
                        hintElement.textContent = '需要透過本機伺服器開啟（如 VS Code Live Server 或 python -m http.server），file:// 無法載入題庫。';
                    } else if (window && window.externalVersesLoadError) {
                        hintElement.textContent = '題庫載入失敗，請重新整理（Ctrl+F5），或確認 external-verses.json 路徑/CORS 設定。';
                    } else {
                        hintElement.textContent = '正在載入題庫…';
                    }
                } else if (!gameState.difficulty && !hasRanking && !hasPractice) {
                    hintElement.textContent = '請先選擇難度與出題範圍';
                } else if (!gameState.difficulty) {
                    hintElement.textContent = '請先選擇遊戲難度';
                } else if (!hasRanking && !hasPractice) {
                    hintElement.textContent = '請選擇「排行模式」或「練習模式」';
                } else if (gameState.range === 'custom') {
                    if (gameState.difficulty === 'normal' && gameState.customBooks.length < 3) {
                        hintElement.textContent = '普通難度：自訂範圍至少選 3 本書卷';
                    } else if ((gameState.difficulty === 'easy' || gameState.difficulty === 'hard') && gameState.customBooks.length < 1) {
                        hintElement.textContent = `${gameState.difficulty === 'easy' ? '簡單' : '困難'}難度：自訂範圍至少選 1 本書卷`;
                    } else {
                        hintElement.textContent = '此設定可用經文不足，請調整罕見度或擴大範圍';
                    }
                } else {
                    hintElement.textContent = '此設定可用經文不足，請調整罕見度或擴大範圍';
                }
            }
        }

        function startGame() {
        // 檢查是否已選擇難度，且有「排行模式（罕見度）」或「練習模式（範圍）」
        if (!gameState.difficulty || (!gameState.rarity && !gameState.range)) {
                return;
            }
            
        // 練習模式：檢查自訂範圍是否有足夠的書卷
        if (gameState.range === 'custom') {
                // 各難度的自訂範圍最低書卷數
                if (gameState.difficulty === 'normal' && gameState.customBooks.length < 3) {
                    const warn = document.getElementById('rangeWarning');
                    if (warn) {
                        warn.textContent = '⚠️ 普通難度：自訂範圍至少選 3 本書卷';
                        warn.classList.remove('hidden');
                    }
                    return;
                }
                if ((gameState.difficulty === 'easy' || gameState.difficulty === 'hard') && gameState.customBooks.length < 1) {
                    const warn = document.getElementById('rangeWarning');
                    if (warn) {
                        warn.textContent = `⚠️ ${gameState.difficulty === 'easy' ? '簡單' : '困難'}難度：自訂範圍至少選 1 本書卷`;
                        warn.classList.remove('hidden');
                    }
                    return;
                }
                
                // 檢查選擇的書卷是否有對應的經文
                const availableVerses = getAvailableVerses();
                if (availableVerses.length < 5) {
            document.getElementById('rangeWarning').innerHTML = '⚠️ 可用經文不足（至少需要 5 篇），請擴大範圍或改選罕見度/範圍！';
                    document.getElementById('rangeWarning').classList.remove('hidden');
                    return;
                }
            }
            
            // 開始倒數
            startCountdown();
        }
        
        function startCountdown() {
            // 顯示開始遊戲提示視窗
            showGameStartModal();
            
            // 鎖定所有主畫面按鈕
            lockMainScreenButtons(true);
            
            const startBtn = document.getElementById('startGameBtn');
            startBtn.style.border = '4px solid #f59e0b';
            startBtn.style.boxShadow = '0 0 20px rgba(245, 158, 11, 0.5)';
            
            let countdown = 3;
            const originalText = startBtn.innerHTML;
            
            const countdownInterval = setInterval(() => {
                if (countdown > 0) {
                    // 只更新提示視窗的倒數，不改變按鈕文字
                    updateGameStartModal(countdown);
                } else {
                    updateGameStartModal(0);
                }
                countdown--;
                
                if (countdown < -1) {
                    clearInterval(countdownInterval);
                    hideGameStartModal();
                    actuallyStartGame();
                }
            }, 1000);
        }
        
        function showGameStartModal() {
            // 創建提示視窗
            const modal = document.createElement('div');
            modal.id = 'gameStartModal';
            modal.className = 'fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50';
            
            modal.innerHTML = `
                <div class="text-center">
                    <div class="mb-8">
                        <h2 class="text-5xl font-black bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent mb-8 drop-shadow-2xl animate-pulse" style="text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);">
                            準備開始遊戲
                        </h2>
                        <div id="countdownDisplay" class="text-[8rem] font-black bg-gradient-to-r from-yellow-400 via-amber-400 to-yellow-500 bg-clip-text text-transparent drop-shadow-2xl mb-6 transition-all duration-300 min-h-[180px] flex items-center justify-center" style="text-shadow: 0 0 50px rgba(255, 215, 0, 1), 0 0 100px rgba(255, 215, 0, 0.8);">
                        </div>
                        <div id="countdownText" class="text-3xl bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent font-bold min-h-[40px] flex items-center justify-center" style="text-shadow: 0 0 30px rgba(255, 255, 255, 0.8); display: none;">
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function updateGameStartModal(countdown) {
            const countdownDisplay = document.getElementById('countdownDisplay');
            const countdownText = document.getElementById('countdownText');
            
            if (countdownDisplay && countdownText) {
                if (countdown > 0) {
                    countdownDisplay.textContent = countdown;
                    countdownDisplay.className = 'text-[8rem] font-black bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent drop-shadow-2xl mb-6 transition-all duration-300 min-h-[180px] flex items-center justify-center countdown-float';
                    countdownDisplay.style.textShadow = '0 0 30px rgba(255, 255, 255, 0.8)';
                    // 隱藏輔助文字，不顯示「秒後開始」
                    countdownText.style.display = 'none';
                } else {
                    countdownDisplay.textContent = '開始';
                    countdownDisplay.className = 'text-[8rem] font-black bg-gradient-to-r from-white via-yellow-300 to-white bg-clip-text text-transparent drop-shadow-2xl mb-6 transition-all duration-300 min-h-[180px] flex items-center justify-center';
                    countdownDisplay.style.textShadow = '0 0 30px rgba(255, 255, 255, 0.8)';
                    // 隱藏輔助文字
                    countdownText.style.display = 'none';
                }
            }
        }
        
        function hideGameStartModal() {
            const modal = document.getElementById('gameStartModal');
            if (modal) {
                modal.remove();
            }
        }

        function lockMainScreenButtons(lock) {
            // 鎖定/解鎖所有難度選擇按鈕
            document.querySelectorAll('.difficulty-option').forEach(btn => {
                btn.style.pointerEvents = lock ? 'none' : 'auto';
            });
            
            // 鎖定/解鎖所有範圍選擇按鈕
            document.querySelectorAll('.range-option').forEach(btn => {
                btn.style.pointerEvents = lock ? 'none' : 'auto';
            });
            
            // 鎖定/解鎖時間獎勵開關
            const toggle = document.getElementById('countdownToggle');
            const toggleContainer = toggle.parentElement.parentElement;
            toggleContainer.style.pointerEvents = lock ? 'none' : 'auto';
            
            // 鎖定/解鎖排行榜區域
            const leaderboardSection = document.getElementById('leaderboardSection');
            if (leaderboardSection) {
                leaderboardSection.style.pointerEvents = lock ? 'none' : 'auto';
            }
            
            // 鎖定/解鎖自訂書卷區域
            const customBooksExpandCard = document.getElementById('customBooksExpandCard');
            if (customBooksExpandCard) {
                customBooksExpandCard.style.pointerEvents = lock ? 'none' : 'auto';
            }
            
            // 鎖定/解鎖開始遊戲按鈕
            const startBtn = document.getElementById('startGameBtn');
            startBtn.disabled = lock;
            startBtn.classList.toggle('start-button-pulse', !lock);
            startBtn.style.cursor = lock ? 'not-allowed' : 'pointer';
            startBtn.style.pointerEvents = lock ? 'none' : 'auto';
        }
        
        function actuallyStartGame() {
            // 重置遊戲狀態
            gameState.currentLevel = 1;
            gameState.currentQuestion = 1;
            gameState.score = 0;
            gameState.hintsUsed = 0;
            gameState.levelPerfect = true;
            gameState.questionAttempts = {};
            gameState.usedHints = new Set();
            gameState.gameStartTime = Date.now(); // 記錄遊戲開始時間
            gameState.gameCompleted = false;
            gameState.isFirstQuestionOfLevel = true;
            gameState.consecutiveMistakes = 0;
            gameState.hintReminderShown = false;
            gameState.levelHintReminderShown = false;
            gameState.totalCorrectAnswers = 0; // 重置答對數
            gameState.totalQuestions = 0; // 重置總題數
            gameState.totalMistakes = 0; // 重置失誤次數
            gameState.levelResults = {}; // 重置關卡結果

            // track used verses across the entire game to avoid duplicates between levels
            try { gameState.usedVerses = new Set(); } catch (e) { gameState.usedVerses = new Set(); }

            // Ensure any replay-related flags are cleared for a fresh game started from the home screen
            gameState.skipLeaderboardOnComplete = false;
            gameState.replaySourceRecord = null;
            console.log('[GAME] actuallyStartGame: cleared replay flags', { skipLeaderboardOnComplete: gameState.skipLeaderboardOnComplete, replaySourceRecord: gameState.replaySourceRecord });
            // If the player-name modal was left in viewing mode, reset it so normal save flow works
            try {
                const modal = document.getElementById('playerNameModal');
                if (modal) {
                    modal.dataset.viewingRecord = '';
                    modal.dataset.viewingDifficulty = '';
                }
            } catch (e) {}

            // 強制分數顯示歸零
            const scoreElement = document.getElementById('centerScore');
            if (scoreElement) scoreElement.textContent = '0';

            // 設置提示次數
            const hintCounts = { easy: 5, normal: 3, hard: 1 };
            gameState.hintsRemaining = hintCounts[gameState.difficulty];

            hideAllScreens();
            document.getElementById('gameScreen').classList.remove('hidden');

            generateLevel();
            updateGameUI();

            // 應用時間獎勵顯示設定
            updateTimeRewardVisibility();
        }

        function generateLevel() {
            // 所有難度都是5題/關
            let questionCount = 5;
            
            // 獲取可用的經文
            let availableVerses = getAvailableVerses();
            // 簡單模式預先過濾出「可拆分」的題庫，盡可能擴大可用池
            if (gameState.difficulty === 'easy') {
                const before = availableVerses.length;
                // 僅接受「在標點切分」的可拆分題目（避免中間硬切造成語意不順）
                availableVerses = availableVerses.filter(v => trySplitVerseText(v.verse, true));
                const after = availableVerses.length;
                if (after < before) {
                    console.log(`簡單模式：可拆分題庫 ${after}/${before}`);
                }

                // 若可拆分的題庫仍不足 5 題，嘗試合併相鄰經文（同章的相鄰節）生成較長文本
                if (availableVerses.length < questionCount) {
                    const extended = synthesizeCombinedVerses(getAvailableVerses());
                    if (extended.length) {
                        // 僅保留可拆分的合併結果
                        const addable = extended.filter(v => trySplitVerseText(v.verse, true));
                        // 合併去重（避免與原本可拆分的重複）
                        const key = v => `${v.book}|${v.chapter}|${v.verse}`;
                        const seen = new Set(availableVerses.map(key));
                        for (const it of addable) {
                            const k = key(it);
                            if (!seen.has(k)) {
                                availableVerses.push(it);
                                seen.add(k);
                            }
                            if (availableVerses.length >= questionCount * 2) break; // 適度擴充，避免過大
                        }
                        console.log(`簡單模式：合併相鄰經文後，可拆分題庫 = ${availableVerses.length}`);
                    }
                }
            }
            
            // 檢查可用經文數量
            console.log(`可用經文數量: ${availableVerses.length}`);
            console.log(`選擇的書卷:`, gameState.customBooks);
            
            // 確保有足夠的經文（至少 5 題）
            if (availableVerses.length < questionCount) {
                alert('此難度可用經文不足（至少需要 5 篇），請擴大範圍或改選其他難度！');
                return;
            }
            
            // 隨機選擇經文 / 或經文對 (easy 模式)
            gameState.questionData = [];
            let attempts = 0;
            const maxAttempts = Math.max(availableVerses.length * 3, 30); // 預防 pool 很小

            // 創建可用經文的副本，並排除已在本遊戲使用過的經文
            const usedKey = (v) => `${v.book}|${v.chapter}|${v.verse}`;
            const usedVersesSet = gameState.usedVerses || new Set();
            let versesToChooseFrom = availableVerses.filter(v => !usedVersesSet.has(usedKey(v)));

            // 如果可用（未使用）經文少於所需題數，允許使用尚未選入本關但可能在之前關未使用的經文
            if (versesToChooseFrom.length < questionCount) {
                // fallback: use all availableVerses but we'll still avoid duplicates inside the same level
                versesToChooseFrom = [...availableVerses];
            }

            while (gameState.questionData.length < questionCount && attempts < maxAttempts) {
                attempts++;

                if (versesToChooseFrom.length === 0) {
                    // no candidates left; break to avoid infinite loop
                    console.log('沒有更多候選經文可供選擇');
                    break;
                }

                const randomIndex = Math.floor(Math.random() * versesToChooseFrom.length);
                let selectedVerse = versesToChooseFrom[randomIndex];
                // 保險：即便前面已按罕見度過濾，這裡也再次確認（尤其是 easy 模式合併/清理後仍應維持同來源）
                if (!gameState.range && gameState.rarity) {
                    const r = selectedVerse.rarity || 'common';
                    if (gameState.rarity === 'rare') {
                        if (!(r === 'rare' || r === 'uncommon')) { versesToChooseFrom.splice(randomIndex,1); continue; }
                    } else if (gameState.rarity === 'common') {
                        // 與 getAvailableVerses 對齊：接受所有標註為 common 的題目（移除舊的精選名節強制限制）
                        if (r !== 'common') { versesToChooseFrom.splice(randomIndex,1); continue; }
                    }
                }

                // 檢查是否在本局已選過（避免本關重複）或整個遊戲已用過
                const alreadyInThisLevel = gameState.questionData.some(q => q.book === selectedVerse.book && q.chapter === selectedVerse.chapter && q.verse === selectedVerse.verse);
                const alreadyUsedInGame = usedVersesSet.has(usedKey(selectedVerse));

                if (alreadyInThisLevel || alreadyUsedInGame) {
                    // remove candidate and continue
                    versesToChooseFrom.splice(randomIndex, 1);
                    continue;
                }

                // 選中後標記為本關題目並在整個遊戲中標記為已使用
                if (gameState.difficulty === 'easy') {
                    // 先清理括號說明，提升可讀性與穩定分段
                    const verseClean = sanitizeVerseText(selectedVerse.verse);
                    const split = trySplitVerseText(verseClean, true);
                    if (split) {
                        // 在建立題目資料時就先去除首尾「」
                        const cleanFront = stripOuterCornerQuotes(split.front);
                        const cleanBack = stripOuterCornerQuotes(split.back);
                        gameState.questionData.push({
                            pairId: `${selectedVerse.book}_${selectedVerse.chapter}_${selectedVerse.verse.slice(0,8).replace(/\s+/g,'')}`,
                            book: selectedVerse.book,
                            chapter: selectedVerse.chapter,
                            front: cleanFront,
                            back: cleanBack,
                            original: selectedVerse
                        });
                        console.log(`選擇經文對 ${gameState.questionData.length}/${questionCount}: ${selectedVerse.book} ${selectedVerse.chapter}`);
                    } else {
                        // 無法拆分則從候選中移除並繼續
                        versesToChooseFrom.splice(randomIndex, 1);
                        continue;
                    }
                } else {
                    gameState.questionData.push(selectedVerse);
                    console.log(`選擇經文 ${gameState.questionData.length}/${questionCount}: ${selectedVerse.book} ${selectedVerse.chapter}`);
                }

                // mark used in this game so later levels won't reuse it
                try { usedVersesSet.add(usedKey(selectedVerse)); } catch (e) {}

                // remove from candidate pool to avoid immediate reselection
                versesToChooseFrom.splice(randomIndex, 1);
            }

            // persist updated used set
            try { gameState.usedVerses = usedVersesSet; } catch (e) {}
            
            console.log(`最終生成 ${gameState.questionData.length} 道題目`);
            
            // 重置關卡狀態
            gameState.currentQuestion = 1;
            gameState.levelPerfect = true;
            gameState.questionAttempts = {};
            gameState.totalQuestions += gameState.questionData.length;
            gameState.isFirstQuestionOfLevel = true;
            
            // 為每個問題初始化嘗試次數
            gameState.questionData.forEach((_, index) => {
                const maxAttempts = { easy: 3, normal: 2, hard: 1 };
                gameState.questionAttempts[index] = maxAttempts[gameState.difficulty];
            });
            
            displayQuestions();
            
            // 在顯示題目後才開始計時器
            setTimeout(() => {
                gameState.levelStartTime = Date.now();
                startLevelTimer();
            }, 100);
        }

        function getAvailableVerses() {
            let availableBooks = [];
            switch (gameState.range) {
                case 'all':
                    availableBooks = [...bibleBooks.old, ...bibleBooks.new];
                    break;
                case 'testament':
                    availableBooks = bibleBooks[gameState.testament];
                    break;
                case 'custom':
                    availableBooks = gameState.customBooks;
                    break;
            }
            // 先依出題範圍過濾（若未選練習範圍則預設整本）
            if (availableBooks.length === 0) availableBooks = [...bibleBooks.old, ...bibleBooks.new];
            let pool = getActiveVerseDB().filter(v => availableBooks.includes(v.book));
            // 再依排行模式（罕見度）過濾；若已選擇練習範圍，則忽略罕見度
            const need = 5;
            const inPractice = !!gameState.range; // range: 'all' | 'testament' | 'custom' implies練習模式
            if (!inPractice && gameState.rarity) {
                if (gameState.rarity === 'all') {
                    // 不做罕見度過濾（整本聖經）
                } else if (gameState.rarity === 'rare') {
                    // 將 UI 的「冷門」擴大為資料中的 rare + uncommon
                    pool = pool.filter(v => v.rarity === 'rare' || v.rarity === 'uncommon');
                } else if (gameState.rarity === 'common') {
                    // 使用標準分類結果擴大常見池；並合併精選常見清單（簡單模式一律合併，其餘作為回補）
                    let filtered = pool.filter(v => v.rarity === 'common');
                    const shouldUnionCurated = (gameState.difficulty === 'easy') || (filtered.length < need);
                    if (shouldUnionCurated) {
                        const COMMON_KEYS = new Set([
                            '約翰福音|3:16','約翰福音|14:6','約翰福音|1:1','約翰福音|1:12','約翰福音|10:11','約翰福音|11:25','約翰福音|15:5','約翰福音|16:33',
                            '腓立比書|4:13','腓立比書|4:6','腓立比書|4:7','腓立比書|4:4','羅馬書|8:28','羅馬書|6:23','羅馬書|8:1','羅馬書|1:16',
                            '馬太福音|6:33','馬太福音|7:7','馬太福音|5:3','馬太福音|5:14','馬太福音|28:19','馬太福音|28:20',
                            '詩篇|23:1','詩篇|23:4','詩篇|119:105','詩篇|46:1','詩篇|46:10','箴言|3:5','箴言|3:6','創世記|1:1','創世記|1:27',
                            '以賽亞書|40:31','耶利米書|29:11','約書亞記|1:9','民數記|6:24','民數記|6:25','民數記|6:26'
                        ]);
                        const seen = new Set(filtered.map(v => `${v.book}|${v.chapter}|${v.verse}`));
                        for (const v of pool) {
                            if (COMMON_KEYS.has(`${v.book}|${v.chapter}`)) {
                                const k = `${v.book}|${v.chapter}|${v.verse}`;
                                if (!seen.has(k)) { filtered.push(v); seen.add(k); }
                            }
                        }
                    }
                    pool = filtered;
                }
                const sum = summarizeRarity(pool);
                if (sum.total < need && document.getElementById('rangeWarning')) {
                    document.getElementById('rangeWarning').classList.remove('hidden');
                    document.getElementById('rangeWarning').textContent = '⚠️ 此罕見度可用經文不足，請改選其他罕見度或擴大範圍。';
                }
            }
            // 回傳隨機打散後的候選池，避免集中度
            return pool.sort(() => Math.random() - 0.5);
        }

        // 合併相鄰（同書卷同章、連續節數）來產生較長文本以便簡單模式可拆分
        // 僅用於擴充 easy 題庫；維持原 book/chapter 顯示，以最小範圍的連續節合併
        function synthesizeCombinedVerses(candidates) {
            try {
                const arr = Array.isArray(candidates) ? [...candidates] : [];
                if (arr.length === 0) return [];
                // 將章節字串分離章:節; 僅處理單節（不含 '-' 範圍）的情形
                function parseChap(ch) {
                    const s = String(ch || '').trim();
                    const m = s.match(/^(\d+):(\d+)$/);
                    if (!m) return null;
                    return { c: parseInt(m[1], 10), v: parseInt(m[2], 10), raw: s };
                }
                // 排序以便尋找相鄰節
                arr.sort((a,b) => {
                    if (a.book !== b.book) return a.book.localeCompare(b.book);
                    const pa = parseChap(a.chapter) || { c: 0, v: 0 };
                    const pb = parseChap(b.chapter) || { c: 0, v: 0 };
                    if (pa.c !== pb.c) return pa.c - pb.c;
                    return pa.v - pb.v;
                });
                const out = [];
                for (let i = 0; i < arr.length - 1; i++) {
                    const cur = arr[i];
                    const nxt = arr[i+1];
                    const p1 = parseChap(cur.chapter);
                    const p2 = parseChap(nxt.chapter);
                    if (!p1 || !p2) continue;
                    // 同書卷、同章、節數相鄰
                    if (cur.book === nxt.book && p1.c === p2.c && p2.v === p1.v + 1) {
                        // 合併文本時，若前文末尾無結尾句號，適度加入空格
                        const sep = /[。！？….!?；;:]$/.test(cur.verse) ? '' : ' ';
                        const mergedText = `${cur.verse}${sep}${nxt.verse}`.trim();
                        // 新的章節顯示仍採用第一節的 chapter，避免 UI 混淆；原文保留於 originalCombined
                        const rarity = cur.rarity || nxt.rarity || 'common';
                        out.push({
                            book: cur.book,
                            chapter: cur.chapter, // 顯示以首節為主
                            verse: mergedText,
                            version: cur.version || nxt.version,
                            rarity,
                            originalCombined: [cur, nxt]
                        });
                    }
                }
                return out;
            } catch (e) {
                return [];
            }
        }

    // 嘗試將經文在合理位置拆成前後兩段（優先在標點或空白處切分）
    function trySplitVerseText(text, strictPunctuation = false) {
            // 盡可能擴充可用題庫：放寬最短字數門檻，但仍確保兩段都有可讀長度
            if (!text) return null;
            const raw = String(text).trim();
            if (raw.length < 16) return null; // 太短的不拆分

            // 強/弱標點分級，優先用強標點（句號/問號/驚嘆號/分號/冒號/省略號）
            const STRONG = new Set(['。','！','？','；','：','…','.','!','?',';',':']);
            const WEAK = new Set(['，','、',',',' ']);
            const isPunct = (ch) => STRONG.has(ch) || WEAK.has(ch);
            const mid = Math.floor(raw.length / 2);
            const searchRange = 16;

            // helper: build pair and fix leading punctuation on the back segment
            const buildPair = (cutIdxInclusive) => {
                let front = raw.slice(0, cutIdxInclusive + 1).trim();
                let back = raw.slice(cutIdxInclusive + 1).trim();
                const leading = back.match(/^[\s，。、！？…!？，.;；:："'“”『』（）()【】\[\]\-—–、，。！？…]+/);
                if (leading) {
                    const lead = leading[0];
                    const nf = (front + lead).trim();
                    const nb = back.slice(lead.length).trim();
                    if (nf.length >= 6 && nb.length >= 6) { front = nf; back = nb; }
                }
                // 進一步避免兩段頭尾落在引號或逗號等不佳位置
                const badEnd = /[“”"'『』，、,]$/;
                const badStart = /^[“”"'『』，、,]/;
                if (front.length >= 6 && back.length >= 6 && !badEnd.test(front) && !badStart.test(back)) return { front, back };
                return null;
            };

            // 1) 強標點優先，從中間向外擴散尋找
            for (let d = 0; d <= searchRange; d++) {
                const L = mid - d, R = mid + d;
                if (L > 2) {
                    const ch = raw[L];
                    if (STRONG.has(ch)) {
                        const pair = buildPair(L);
                        if (pair) return pair;
                    }
                }
                if (R < raw.length - 2) {
                    const ch = raw[R];
                    if (STRONG.has(ch)) {
                        const pair = buildPair(R);
                        if (pair) return pair;
                    }
                }
            }

            // 2) 退而求其次：弱標點（逗號/頓號/空白）
            for (let d = 0; d <= searchRange; d++) {
                const L = mid - d, R = mid + d;
                if (L > 2) {
                    const ch = raw[L];
                    if (WEAK.has(ch)) {
                        const pair = buildPair(L);
                        if (pair) return pair;
                    }
                }
                if (R < raw.length - 2) {
                    const ch = raw[R];
                    if (WEAK.has(ch)) {
                        const pair = buildPair(R);
                        if (pair) return pair;
                    }
                }
            }

            // 3) 最後：若允許，直接在中位數切分並修正後段前導標點（strict 模式下跳過）
            if (strictPunctuation) return null;
            const cut = mid;
            let front = raw.slice(0, cut).trim();
            let back = raw.slice(cut).trim();
            const leading = back.match(/^[\s，。、！？…!？，.;；:："'“”『』（）()【】\[\]\-—–、，。！？…]+/);
            if (leading) {
                const lead = leading[0];
                const nf = (front + lead).trim();
                const nb = back.slice(lead.length).trim();
                if (nf.length >= 6 && nb.length >= 6) { front = nf; back = nb; }
            }
            if (front.length >= 6 && back.length >= 6) return { front, back };
            return null;
        }

        // 小工具：移除字串頭尾的中文引號（「」與『』及英引號），僅用於簡單難度顯示的前/後段經文
        function stripOuterCornerQuotes(s) {
            if (s == null) return s;
            const str = String(s);
            // 只清除頭尾連續的引號符號，不影響中間內容
            return str
                .replace(/^[「」『』“”"']+/, '')
                .replace(/[「」『』“”"']+$/, '')
                .trim();
        }

        // --- In-page confirm modal helper (used to replace native confirm for reliability) ---
        function ensureConfirmModalExists() {
            if (document.getElementById('inPageConfirmModal')) return;
            const div = document.createElement('div');
            div.id = 'inPageConfirmModal';
            div.className = 'fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-60';
            div.innerHTML = `
                <div class="cute-card bg-white p-6 max-w-lg mx-4 text-center rounded-xl">
                    <div id="inPageConfirmMessage" class="text-base text-gray-800 mb-4"></div>
                    <div class="flex gap-3 justify-center mt-4">
                        <button id="inPageConfirmYes" class="cute-button bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-bold">繼續</button>
                        <button id="inPageConfirmNo" class="cute-button bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded-lg font-bold">取消</button>
                    </div>
                </div>
            `;
            document.body.appendChild(div);
            document.getElementById('inPageConfirmYes').addEventListener('click', () => {
                div.dataset.choice = 'yes';
                div.classList.add('hidden');
            });
            document.getElementById('inPageConfirmNo').addEventListener('click', () => {
                div.dataset.choice = 'no';
                div.classList.add('hidden');
            });
        }

        function showInPageConfirm(message) {
            return new Promise((resolve) => {
                ensureConfirmModalExists();
                const modal = document.getElementById('inPageConfirmModal');
                const msg = document.getElementById('inPageConfirmMessage');
                modal.dataset.choice = '';
                if (msg) msg.textContent = message || '';
                modal.classList.remove('hidden');

                // poll for choice (simple approach to avoid complex event plumbing)
                const interval = setInterval(() => {
                    const choice = modal.dataset.choice;
                    if (choice === 'yes' || choice === 'no') {
                        clearInterval(interval);
                        resolve(choice === 'yes');
                    }
                }, 100);
            });
        }

    // ...existing code...

        function displayQuestions() {
            const versesContainer = document.getElementById('gameVerses');
            const chaptersContainer = document.getElementById('gameChapters');
            // 清除可能殘留的吐司提示
            try { hideCuteHint(); } catch (_) {}
            // 根據難度動態顯示標題：簡單顯示「前 段 經 文 / 後 段 經 文」，其餘難度保持原本「經 文 內 容 / 章 節 選 擇」
            const verseTitleEl = document.getElementById('verseTitle');
            const chapterTitleEl = document.getElementById('chapterTitle');
            if (verseTitleEl && chapterTitleEl) {
                if (gameState.difficulty === 'easy') {
                    verseTitleEl.innerHTML = `<span class="text-4xl animate-pulse mr-4">📜</span><span class="tracking-widest bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">前 段 經 文</span><span class="text-4xl animate-pulse ml-4">📜</span>`;
                    chapterTitleEl.innerHTML = `<span class="text-4xl animate-pulse mr-4">📍</span><span class="tracking-widest bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">後 段 經 文</span><span class="text-4xl animate-pulse ml-4">📍</span>`;
                } else {
                    verseTitleEl.innerHTML = `<span class="text-4xl animate-pulse mr-4">📜</span><span class="tracking-widest bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">經 文 內 容</span><span class="text-4xl animate-pulse ml-4">📜</span>`;
                    chapterTitleEl.innerHTML = `<span class="text-4xl animate-pulse mr-4">📍</span><span class="tracking-widest bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">章 節 選 擇</span><span class="text-4xl animate-pulse ml-4">📍</span>`;
                }
            }

            versesContainer.innerHTML = '';
            chaptersContainer.innerHTML = '';
            
            // 顯示經文 (簡單難度為前段；其他為整段經文)
            gameState.questionData.forEach((item, index) => {
                // 簡單難度：移除頭尾「」符號（舊快照亦在此保險處理）
                const verseText = (gameState.difficulty === 'easy') ? stripOuterCornerQuotes(item.front) : item.verse;
                const verseCard = createVerseCard(verseText, index);
                versesContainer.appendChild(verseCard);
            });
            
            // 顯示章節選項（打亂順序）
            // 章節 / 後段顯示（簡單模式顯示後段經文作為選項）
            const shuffledChapters = [...gameState.questionData].sort(() => Math.random() - 0.5);
            shuffledChapters.forEach((item, index) => {
                let chapterText;
                if (gameState.difficulty === 'easy') {
                    // 簡單難度選項顯示後段經文，同樣移除頭尾「」
                    chapterText = stripOuterCornerQuotes(item.back);
                } else {
                    chapterText = (gameState.difficulty === 'easy' || gameState.difficulty === 'normal') ? item.book : `${item.book} ${item.chapter}`;
                }
                const chapterCard = createChapterCard(chapterText, item);
                chaptersContainer.appendChild(chapterCard);
            });
            
            // 僅在第一關的第一題顯示遊戲提示（改為可愛語氣吐司提示）
            if (gameState.currentLevel === 1 && gameState.isFirstQuestionOfLevel) {
                // 顯示提示並記錄淡出函數
                const introPool = (gameState.difficulty === 'easy') ? HINTS.play.introEasy : HINTS.play.introOther;
                gameState._fadeVerseInstruction = showGameInstruction(pick(introPool), 0);
            }
        }

        // 返回對應的文字大小 class（共用給章節卡與簡單模式的前段經文）
        function getCardTextSize(text) {
            if (!text) return 'text-lg';
            if (text.length <= 8) return 'text-xl';
            if (text.length <= 15) return 'text-lg';
            if (text.length <= 25) return 'text-base';
            return 'text-sm';
        }

        function createVerseCard(verse, index) {
            const card = document.createElement('div');
            const attempts = gameState.questionAttempts[index];
            const maxAttempts = { easy: 3, normal: 2, hard: 1 };
            const originalAttempts = maxAttempts[gameState.difficulty];
            
            // 若該經文還未作答（嘗試次數等於原始次數），一律顯示藍色
            let bgColor = 'bg-blue-50 border-blue-200';
            if (attempts < originalAttempts) {
                // 已經作答過但還有機會，根據剩餘次數顯示不同顏色
                if (attempts === 2) bgColor = 'bg-yellow-100 border-yellow-300';
                else if (attempts === 1) bgColor = 'bg-orange-100 border-orange-300';
                else if (attempts === 0) bgColor = 'bg-red-100 border-red-300';
            }
            
            // 根據是否在 carousel 內調整卡片樣式：carousel 僅在手機視窗下啟用
            const inCarousel = !!document.getElementById('versesCarousel') && window.matchMedia('(max-width: 760px)').matches;
            let widthClass = inCarousel ? 'w-full' : 'w-64'; // 使用 full-width 作為 carousel 的預設
            let heightClass = inCarousel ? 'min-h-[64px]' : 'min-h-[120px]';

            if (!inCarousel) {
                if (verse.length <= 30) {
                    widthClass = 'w-48';
                    heightClass = 'min-h-[80px]';
                } else if (verse.length <= 60) {
                    widthClass = 'w-56';
                    heightClass = 'min-h-[90px]';
                } else if (verse.length <= 100) {
                    widthClass = 'w-72';
                    heightClass = 'min-h-[100px]';
                } else {
                    widthClass = 'w-80';
                    heightClass = 'min-h-[110px]';
                }
            }

            // 在 carousel 情況下，不使用 flex-shrink-0 並改為垂直對齊
            card.className = inCarousel
                ? `verse-card ${bgColor} border-2 p-2 ${heightClass} ${widthClass} flex items-center justify-between` 
                : `verse-card ${bgColor} border-2 p-2 ${heightClass} ${widthClass} flex items-center justify-center flex-shrink-0`;
            card.dataset.index = index;
            // 綱一致化：所有難度使用與簡單模式相同的文字大小/字重規則，並以藍色文字顯示經文內容
            const textSize = getCardTextSize(verse);
            card.innerHTML = `<div class="font-normal text-blue-800 ${textSize} leading-tight break-words text-center max-w-full">${verse}</div>`;
            
            // 鍵盤可達性
            card.setAttribute('tabindex', '0');
            card.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); selectVerse(index); }
            });
            // 添加點擊事件
            card.addEventListener('click', () => selectVerse(index));
            
            return card;
        }

        function createChapterCard(chapterText, originalData) {
            const card = document.createElement('div');
            
            // 在 carousel 中使用 full-width 垂直列表樣式（僅在手機視窗）
            const inCarousel = !!document.getElementById('versesCarousel') && window.matchMedia('(max-width: 760px)').matches;
            let widthClass = inCarousel ? 'w-full' : 'w-48';
            if (!inCarousel) {
                if (chapterText.length <= 8) widthClass = 'w-36';
                else if (chapterText.length <= 15) widthClass = 'w-44';
                else if (chapterText.length <= 25) widthClass = 'w-52';
                else widthClass = 'w-60';
            }
            const textSize = getCardTextSize(chapterText);

            // On mobile (carousel) use the same compact sizing as verse cards so front/back panels match
            card.className = inCarousel
                ? `chapter-card bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-300 p-2 text-center min-h-[64px] ${widthClass} flex items-center justify-between shadow-sm transition-all duration-150`
                : `chapter-card bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-300 p-4 text-center min-h-[80px] ${widthClass} flex items-center justify-center flex-shrink-0 shadow-lg hover:shadow-xl transition-all duration-300`;
            // 標記配對資訊（若為 easy 模式，originalData 包含 front/back/pairId）
            if (gameState.difficulty === 'easy' && originalData.pairId) {
                card.dataset.pairId = originalData.pairId;
                card.dataset.book = originalData.book;
                card.dataset.chapter = originalData.chapter;
            } else {
                card.dataset.book = originalData.book;
                card.dataset.chapter = originalData.chapter;
            }
            // 顯示原始章節文字（保留標點），章節文字使用紫色系
            card.innerHTML = `<div class="font-normal text-purple-800 ${textSize} leading-tight break-words text-center max-w-full">${chapterText}</div>`;
            
            // 鍵盤可達性
            card.setAttribute('tabindex', '0');
            card.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); handleChapterClick(card, originalData); }
            });
            card.addEventListener('click', () => handleChapterClick(card, originalData));
            
            return card;
        }

        function selectVerse(index) {
            // 移除之前選中的經文樣式
            document.querySelectorAll('.verse-card').forEach(card => {
                card.classList.remove('selected-verse');
            });
            
            // 選中當前經文
            const selectedCard = document.querySelector(`[data-index="${index}"]`);
            if (selectedCard && gameState.questionAttempts[index] > 0) {
                selectedCard.classList.add('selected-verse');
                gameState.selectedVerseIndex = index;

                // 僅在第一關的第一題顯示選擇章節/配對的提示
                if (gameState.currentLevel === 1 && gameState.isFirstQuestionOfLevel) {
                    // 先淡出上一個提示
                    if (gameState._fadeVerseInstruction) {
                        gameState._fadeVerseInstruction();
                        gameState._fadeVerseInstruction = null;
                    }
                    // 顯示新提示並記錄淡出函數（改為可愛語氣吐司）
                    const pairPool = (gameState.difficulty === 'easy') ? HINTS.play.pairEasy : HINTS.play.pairOther;
                    gameState._fadeChapterInstruction = showGameInstruction(pick(pairPool), 0);
                    gameState.isFirstQuestionOfLevel = false;
                }
                // 如果是在手機並存在 carousel，將視圖自動滑到後段章節面板，協助使用者選擇
                const carousel = document.getElementById('versesCarousel');
                if (carousel && window.innerWidth <= 760) {
                    // 滑動到第二個面板 (back)
                    const panels = carousel.querySelectorAll('.panel');
                    if (panels && panels.length > 1) {
                        const backPanel = panels[1];
                        backPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                    }
                }
            }
        }

        // 手機環境下，將焦點與視窗回到前段經文面板並嘗試聚焦第一張經文卡
        function scrollToFrontPanel() {
            const carousel = document.getElementById('versesCarousel');
            if (!carousel || window.innerWidth > 760) return;
            const panels = carousel.querySelectorAll('.panel');
            if (!panels || panels.length === 0) return;
            const frontPanel = panels[0];
            try {
                frontPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });

                // 優先嘗試聚焦第一張經文卡，若不存在則聚焦 panel 本身（使用 tabindex -1 確保可聚焦）
                const firstVerse = frontPanel.querySelector('.verse-card');
                if (firstVerse) {
                    if (!firstVerse.hasAttribute('tabindex')) firstVerse.setAttribute('tabindex', '-1');
                    firstVerse.focus({ preventScroll: true });
                } else {
                    if (!frontPanel.hasAttribute('tabindex')) frontPanel.setAttribute('tabindex', '-1');
                    frontPanel.focus({ preventScroll: true });
                }
            } catch (e) {
                // defensive: ignore focus errors
            }
        }

        function startLevelTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            gameState.timerInterval = setInterval(() => {
                updateCurrentScore();
            }, 100); // 每100ms更新一次
        }

        function updateCurrentScore() {
            const elapsed = (Date.now() - gameState.levelStartTime) / 1000; // 秒
            let timeRewardScore = 0;
            const TIME_SCALE = 10; // scale time reward by 10x (original ±5 -> now ±50)
            
            if (gameState.showTimeReward) {
                // New piecewise rules (display range: +50 ... -50)
                //  - elapsed <= 8s => +50
                //  - 8s < elapsed <= 40s => linear from +50 down to 0
                //  - 40s < elapsed <= 120s => linear from 0 down to -50
                //  - elapsed > 120s => -50
                const POS_MAX = 50;
                const NEG_MIN = -50;

                if (elapsed <= 8) {
                    timeRewardScore = POS_MAX;
                } else if (elapsed <= 40) {
                    // map [8,40] -> [50,0]
                    const t = (elapsed - 8) / (40 - 8);
                    timeRewardScore = POS_MAX * (1 - t);
                } else if (elapsed <= 120) {
                    // map (40,120] -> (0,-50]
                    const t = (elapsed - 40) / (120 - 40);
                    timeRewardScore = (0) + (NEG_MIN * t);
                } else {
                    timeRewardScore = NEG_MIN;
                }

                // ensure numeric and clamp
                timeRewardScore = Math.max(NEG_MIN, Math.min(POS_MAX, timeRewardScore));
                const displayScore = Math.round(timeRewardScore);

                // 更新分數顯示（整數）
                const scoreElement = document.getElementById('currentQuestionScore');
                if (scoreElement) {
                    scoreElement.textContent = displayScore;
                    // color: positive -> green->yellow, zero -> orange, negative -> red shades
                    if (displayScore > 0) {
                        const ratio = displayScore / POS_MAX; // 0..1
                        const red = Math.floor(255 * (1 - ratio * 0.8));
                        const green = 255;
                        const blue = 0;
                        scoreElement.style.color = `rgb(${red}, ${green}, ${blue})`;
                    } else if (displayScore === 0) {
                        scoreElement.style.color = 'rgb(255,165,0)';
                    } else {
                        const ratio = Math.min(1, Math.abs(displayScore) / Math.abs(NEG_MIN));
                        const red = 255;
                        const green = Math.floor(100 * (1 - ratio));
                        const blue = Math.floor(100 * (1 - ratio));
                        scoreElement.style.color = `rgb(${red}, ${green}, ${blue})`;
                    }
                }

                // 更新進度條（範圍 -50..+50 對應 0..100）
                const scoreProgressFill = document.getElementById('scoreProgressFill');
                if (scoreProgressFill) {
                    const totalProgress = Math.max(0, Math.min(100, (((POS_MAX) - timeRewardScore) / (POS_MAX - NEG_MIN)) * 100));

                    // choose color by thresholds (preserve existing visual cues roughly)
                    let barColor = 'bg-green-500';
                    if (timeRewardScore >= 30) {
                        barColor = 'bg-green-500';
                    } else if (timeRewardScore >= 10) {
                        barColor = 'bg-lime-500';
                    } else if (timeRewardScore >= 0) {
                        barColor = 'bg-yellow-500';
                    } else if (timeRewardScore >= -25) {
                        barColor = 'bg-orange-500';
                    } else {
                        barColor = 'bg-red-600';
                    }

                    scoreProgressFill.className = scoreProgressFill.className.replace(/bg-\w+-\d+/g, '');
                    scoreProgressFill.classList.add(barColor, 'h-full', 'rounded-full', 'transition-all', 'duration-100', 'shadow-sm');
                    scoreProgressFill.style.width = `${100 - totalProgress}%`;

                    // 更新刻度高亮
                    const scaleContainer = scoreProgressFill.parentElement.nextElementSibling;
                    if (scaleContainer) {
                        const scaleNumbers = scaleContainer.querySelectorAll('span');
                        const nearestIndexRaw = Math.round((displayScore + POS_MAX) / (POS_MAX / 5));
                        const nearestIndex = Math.max(0, Math.min(scaleNumbers.length - 1, nearestIndexRaw));
                        scaleNumbers.forEach((span, index) => {
                            span.className = 'text-xs text-gray-500';
                            if (index === nearestIndex) {
                                if (displayScore > 0) span.className = 'text-xs text-white font-bold bg-green-600 px-1 rounded shadow-md';
                                else if (displayScore === 0) span.className = 'text-xs text-white font-bold bg-yellow-600 px-1 rounded shadow-md';
                                else span.className = 'text-xs text-white font-bold bg-red-600 px-1 rounded shadow-md';
                            }
                        });
                    }
                }

                return displayScore;
            }

            return 0;
        }

        // 共用：清除元素上可能阻礙「答對變綠」的錯誤/動畫/紅色類別
        function clearErrorState(el) {
            if (!el) return;
            // 移除常見會造成錯誤視覺或阻礙變色的類別
            el.classList.remove('shake-error', 'bg-red-100', 'border-red-300');
            // 若元素內有文字節點，亦清除會覆蓋文字顏色的類別
            try {
                const inner = el.querySelector && el.querySelector('div');
                if (inner) {
                    inner.classList.remove('text-red-800', 'text-yellow-800', 'text-orange-800', 'text-blue-800', 'text-purple-800');
                }
            } catch (e) {
                // defensive: 如果不是 element 或 querySelector 發生例外，忽略
            }
        }

        function handleChapterClick(chapterCard, chapterData) {
            // 必須先選擇經文
            if (gameState.selectedVerseIndex === null) {
                return;
            }
            
            const selectedQuestion = gameState.questionData[gameState.selectedVerseIndex];
            
            // 檢查是否正確：
            // - easy：使用 pairId（前段/後段配對）
            // - normal：僅比對書卷名稱
            // - hard：比對書卷與章節
            let isCorrect = false;
            if (gameState.difficulty === 'easy') {
                isCorrect = !!(selectedQuestion.pairId && chapterCard.dataset.pairId && selectedQuestion.pairId === chapterCard.dataset.pairId);
            } else if (gameState.difficulty === 'normal') {
                isCorrect = selectedQuestion.book === chapterData.book;
            } else {
                isCorrect = selectedQuestion.book === chapterData.book && selectedQuestion.chapter === chapterData.chapter;
            }
            
            if (isCorrect) {
                // 淡出遊戲提示
                const existingInstructions = document.querySelectorAll('.game-instruction');
                existingInstructions.forEach(inst => {
                    inst.style.animation = 'instructionFadeOut 1s ease-out forwards';
                    setTimeout(() => {
                        if (inst.parentElement) {
                            inst.parentElement.removeChild(inst);
                        }
                    }, 1000);
                });
                // 同步隱藏可愛吐司提示
                try { hideCuteHint(); } catch (_) {}

                // 若該題有提示效果，立即移除（easy 模式使用 pairId）
                const hintVerseCard = document.querySelector(`[data-index="${gameState.selectedVerseIndex}"]`);
                if (hintVerseCard) hintVerseCard.classList.remove('hint-flash');
                if (gameState.difficulty === 'easy') {
                    const hintChapterCard = document.querySelector(`[data-pair-id="${selectedQuestion.pairId}"]`);
                    if (hintChapterCard) hintChapterCard.classList.remove('hint-flash');
                } else {
                    const hintChapterCard = document.querySelector(`[data-book="${chapterData.book}"][data-chapter="${chapterData.chapter}"]`);
                    if (hintChapterCard) hintChapterCard.classList.remove('hint-flash');
                }

                // 記錄答對時的失誤次數（用於進度條顏色判斷）
                const maxAttempts = { easy: 3, normal: 2, hard: 1 };
                const originalAttempts = maxAttempts[gameState.difficulty];
                const currentAttempts = gameState.questionAttempts[gameState.selectedVerseIndex];
                const hadMistakes = currentAttempts < originalAttempts;

                // 答對了
                let scoreGained = 0;
                if (gameState.questionAttempts[gameState.selectedVerseIndex] > 0) {
                    // 基礎分數：練習模式固定 100；排行模式依罕見度（常見/冷門/全部）100/125/150；每次失誤扣25分
                    const mistakeCount = originalAttempts - currentAttempts;
                    const inPractice = !!gameState.range;
                    const rarityBaseMap = { common: 100, rare: 125, all: 150 };
                    const basePerQuestion = inPractice ? 100 : (rarityBaseMap[gameState.rarity] || 100);
                    let totalScore = basePerQuestion - (mistakeCount * 25);
                    
                    // 如果開啟時間獎勵，額外加上時間獎勵分數
                    if (gameState.showTimeReward) {
                        const timeRewardScore = updateCurrentScore();
                        totalScore += timeRewardScore;
                    }
                    // 每題最低分數限制為 0（不允許負分）
                    totalScore = Math.max(0, totalScore);
                    
                    gameState.score += totalScore;
                    scoreGained = totalScore;
                    gameState.totalCorrectAnswers++;
                }
                
                // 標記為正確，並清除任何殘留的錯誤/動畫/紅色類別，確保文字能正確變成綠色
                chapterCard.classList.add('bg-green-100', 'border-green-300');
                chapterCard.classList.remove('bg-gradient-to-br', 'from-purple-50', 'to-purple-100', 'border-purple-300', 'chapter-arrow');
                // 清除可能殘留的錯誤／震動／紅色樣式，統一使用 helper
                clearErrorState(chapterCard);
                // 將章節文字改為綠色
                const chapterInner = chapterCard.querySelector('div');
                if (chapterInner) {
                    chapterInner.classList.remove('text-red-800', 'text-blue-800', 'text-purple-800');
                    chapterInner.classList.add('text-green-800');
                }
                
                // 移除經文卡片的選中狀態和點擊事件
                const verseCard = document.querySelector(`[data-index="${gameState.selectedVerseIndex}"]`);
                    if (verseCard) {
                    // mark verse correct and clear any lingering error/shake/red classes via helper
                    clearErrorState(verseCard);
                    verseCard.classList.remove('bg-blue-50', 'border-blue-200', 'bg-yellow-100', 'border-yellow-300', 'bg-orange-100', 'border-orange-300', 'selected-verse');
                    verseCard.classList.add('bg-green-100', 'border-green-300');
                    verseCard.style.pointerEvents = 'none';
                    // 經文文字變綠表示答對
                    const innerText = verseCard.querySelector('div');
                    if (innerText) {
                        innerText.classList.remove('text-red-800', 'text-blue-800', 'text-purple-800');
                        innerText.classList.add('text-green-800');
                    }

                    // 簡單/普通難度：在該題前段/整段經文卡片下方顯示「書卷 章節」（例如：馬太福音 5:9）
                    if (gameState.difficulty === 'easy' || gameState.difficulty === 'normal') {
                        try {
                            const already = verseCard.querySelector('.verse-ref-label');
                            if (!already) {
                                const ref = document.createElement('div');
                                ref.className = 'verse-ref-label text-xs text-gray-700 font-semibold text-center';
                                ref.textContent = `${selectedQuestion.book || ''} ${selectedQuestion.chapter || ''}`.trim();
                                // 淡入效果
                                ref.style.opacity = '0';
                                ref.style.transition = 'opacity 260ms ease';
                                verseCard.appendChild(ref);
                                requestAnimationFrame(() => { ref.style.opacity = '1'; });
                                // 顯示 5 秒後淡出並移除
                                try { if (ref.__hideTimer) clearTimeout(ref.__hideTimer); } catch (e) {}
                                ref.__hideTimer = setTimeout(() => {
                                    try {
                                        ref.style.opacity = '0';
                                        const onEnd = () => {
                                            ref.removeEventListener('transitionend', onEnd);
                                            try { if (ref.parentElement) ref.parentElement.removeChild(ref); } catch (e2) {}
                                        };
                                        ref.addEventListener('transitionend', onEnd);
                                    } catch (e3) {}
                                }, 3000);
                            } else {
                                // 已存在：重置淡出計時並確保可見
                                already.style.transition = already.style.transition || 'opacity 260ms ease';
                                already.style.opacity = '1';
                                try { if (already.__hideTimer) clearTimeout(already.__hideTimer); } catch (e) {}
                                already.__hideTimer = setTimeout(() => {
                                    try {
                                        already.style.opacity = '0';
                                        const onEnd = () => {
                                            already.removeEventListener('transitionend', onEnd);
                                            try { if (already.parentElement) already.parentElement.removeChild(already); } catch (e2) {}
                                        };
                                        already.addEventListener('transitionend', onEnd);
                                    } catch (e3) {}
                                }, 3000);
                            }
                        } catch (e) { /* ignore label errors */ }
                    }
                }
                
                // 重置選中狀態
                gameState.selectedVerseIndex = null;
                
                // 更新題目進度顯示
                updateQuestionOvals();
                
                // 檢查是否完成所有題目
                setTimeout(() => checkLevelComplete(), 500);
                
                // 答題結束後，在手機上將焦點回到前段經文面板
                scrollToFrontPanel();

                if (scoreGained > 0) {
                    showScoreAnimation(`+${scoreGained}分`, false, verseCard);
                }
                
            } else {
                // 答錯了
                gameState.questionAttempts[gameState.selectedVerseIndex]--;
                gameState.levelPerfect = false;
                gameState.consecutiveMistakes++;
                gameState.totalMistakes++; // 增加失誤計數
                
                // 淡出遊戲提示
                const existingInstructions = document.querySelectorAll('.game-instruction');
                existingInstructions.forEach(inst => {
                    inst.style.animation = 'instructionFadeOut 1s ease-out forwards';
                    setTimeout(() => {
                        if (inst.parentElement) {
                            inst.parentElement.removeChild(inst);
                        }
                    }, 1000);
                });
                // 同步隱藏可愛吐司提示
                try { hideCuteHint(); } catch (_) {}
                
                // 顯示失誤扣分動畫
                const verseCard = document.querySelector(`[data-index="${gameState.selectedVerseIndex}"]`);
                if (verseCard) {
                    showScoreAnimation('-25', false, verseCard);
                }
                
                // 檢查是否需要顯示提示功能提醒（每關最多一次）
                if (gameState.consecutiveMistakes >= 3 && 
                    gameState.hintsRemaining > 0 && 
                    !gameState.levelHintReminderShown) {
                    showHintReminder();
                    gameState.levelHintReminderShown = true;
                }
                
                // 添加震動效果到選錯的章節卡片
                chapterCard.classList.add('shake-error');
                setTimeout(() => {
                    chapterCard.classList.remove('shake-error');
                }, 600);
                
                if (gameState.questionAttempts[gameState.selectedVerseIndex] <= 0) {
                    // 沒有機會了，標記經文為錯誤
                    const verseCard = document.querySelector(`[data-index="${gameState.selectedVerseIndex}"]`);
                    if (verseCard) {
                        verseCard.classList.add('bg-red-100', 'border-red-300', 'shake-error');
                        verseCard.classList.remove('bg-blue-50', 'border-blue-200', 'bg-yellow-100', 'border-yellow-300', 'bg-orange-100', 'border-orange-300', 'selected-verse');
                        verseCard.style.pointerEvents = 'none';
                        
                        // 將經文內容文字也改為紅色，表示此題已鎖定無法得分
                        const innerText = verseCard.querySelector('div');
                        if (innerText) {
                            innerText.classList.remove('text-blue-800', 'text-purple-800', 'text-green-800');
                            innerText.classList.add('text-red-800');
                        }

                        // 移除震動效果
                        setTimeout(() => {
                            verseCard.classList.remove('shake-error');
                        }, 600);
                    }
                    
                    // 找到正確答案並標記為紅色（只標記正確答案，不標記選錯的章節）
                    let correctChapter = null;
                    const allChapters = document.querySelectorAll('.chapter-card');
                    
                    for (let chapter of allChapters) {
                        // easy: 使用 pairId 比對
                        if (gameState.difficulty === 'easy' && selectedQuestion.pairId) {
                            if (chapter.dataset.pairId && chapter.dataset.pairId === selectedQuestion.pairId) {
                                correctChapter = chapter;
                                break;
                            }
                        } else if (gameState.difficulty === 'normal') {
                            if (chapter.dataset.book === selectedQuestion.book) {
                                correctChapter = chapter;
                                break;
                            }
                        } else {
                            if (chapter.dataset.book === selectedQuestion.book && chapter.dataset.chapter === selectedQuestion.chapter) {
                                correctChapter = chapter;
                                break;
                            }
                        }
                    }
                    
                    // 只將正確答案標記為紅色，不標記選錯的章節
                    if (correctChapter) {
                        correctChapter.classList.add('bg-red-100', 'border-red-300', 'shake-error');
                        correctChapter.classList.remove('bg-gradient-to-br', 'from-purple-50', 'to-purple-100', 'border-purple-300');
                        correctChapter.style.pointerEvents = 'none';
                        // 答案文字也改為紅色以示提示
                        const correctInner = correctChapter.querySelector('div');
                        if (correctInner) {
                            correctInner.classList.remove('text-blue-800', 'text-purple-800', 'text-green-800');
                            correctInner.classList.add('text-red-800');
                        }
                        
                        // 移除震動效果
                        setTimeout(() => {
                            correctChapter.classList.remove('shake-error');
                        }, 600);
                    }
                    
                    // 移除選中狀態
                    gameState.selectedVerseIndex = null;
                    
                    // 更新題目進度顯示
                    updateQuestionOvals();
                    
                    // 檢查是否所有題目都完成
                    setTimeout(() => checkLevelComplete(), 500);

                    // 若該題次數用盡，將視圖回到前段面板，方便使用者查看下一題
                    scrollToFrontPanel();
                } else {
                    // 還有機會，更新經文卡片顏色並保持選中狀態
                    updateVerseCardColor(gameState.selectedVerseIndex);
                }
            }
        }

        function updateVerseCardColor(index) {
            const verseCard = document.querySelector(`[data-index="${index}"]`);
            if (!verseCard) return;
            
            const attempts = gameState.questionAttempts[index];
            const maxAttempts = { easy: 3, normal: 2, hard: 1 };
            const originalAttempts = maxAttempts[gameState.difficulty];
            
            // 移除所有顏色類別
            verseCard.classList.remove('bg-blue-50', 'border-blue-200', 'bg-yellow-100', 'border-yellow-300', 'bg-orange-100', 'border-orange-300', 'bg-red-100', 'border-red-300');
            
            // 若該經文還未作答（嘗試次數等於原始次數），一律顯示藍色
            if (attempts === originalAttempts) {
                verseCard.classList.add('bg-blue-50', 'border-blue-200');
                // 文字回復藍色
                const inner = verseCard.querySelector('div');
                if (inner) {
                    inner.classList.remove('text-red-800', 'text-purple-800', 'text-green-800');
                    inner.classList.add('text-blue-800');
                }
            } else {
                // 已經作答過但還有機會，根據剩餘次數顯示不同顏色
                if (attempts === 2) {
                    verseCard.classList.add('bg-yellow-100', 'border-yellow-300');
                    const inner = verseCard.querySelector('div');
                    if (inner) {
                        inner.classList.remove('text-red-800', 'text-blue-800', 'text-green-800');
                        inner.classList.add('text-yellow-800');
                    }
                } else if (attempts === 1) {
                    verseCard.classList.add('bg-orange-100', 'border-orange-300');
                    const inner = verseCard.querySelector('div');
                    if (inner) {
                        inner.classList.remove('text-red-800', 'text-blue-800', 'text-green-800');
                        inner.classList.add('text-orange-800');
                    }
                } else if (attempts === 0) {
                    verseCard.classList.add('bg-red-100', 'border-red-300');
                    const inner = verseCard.querySelector('div');
                    if (inner) {
                        inner.classList.remove('text-blue-800', 'text-yellow-800', 'text-orange-800', 'text-green-800');
                        inner.classList.add('text-red-800');
                    }
                }
            }
            
            // 更新題目進度顯示
            updateQuestionOvals();
        }

        function checkLevelComplete() {
            // 確保有題目數據
            if (!gameState.questionData || gameState.questionData.length === 0) {
                console.log('沒有題目數據，無法檢查關卡完成狀態');
                return;
            }
            
            const completedQuestions = gameState.questionData.filter((_, index) => {
                const verseCard = document.querySelector(`[data-index="${index}"]`);
                return verseCard && (verseCard.classList.contains('bg-green-100') || verseCard.classList.contains('bg-red-100'));
            }).length;
            
            console.log(`已完成題目: ${completedQuestions}/${gameState.questionData.length}`);
            
            if (completedQuestions === gameState.questionData.length) {
                // 停止計時器
                if (gameState.timerInterval) {
                    clearInterval(gameState.timerInterval);
                    gameState.timerInterval = null;
                }
                
                // 檢查獎勵
                const correctQuestions = gameState.questionData.filter((_, index) => {
                    const verseCard = document.querySelector(`[data-index="${index}"]`);
                    return verseCard && verseCard.classList.contains('bg-green-100');
                }).length;
                
                const allCorrect = correctQuestions === gameState.questionData.length;
                console.log(`答對題目: ${correctQuestions}/${gameState.questionData.length}, 全對: ${allCorrect}`);
                
                // 記錄關卡結果
                // 檢查是否有使用過提示的題目（僅考慮本關的提示記錄）
                const levelUsedHints = Array.from(gameState.usedHints).some(h => {
                    const s = String(h);
                    // new format: "<level>|<questionIndex>"
                    if (s.indexOf('|') !== -1) return s.startsWith(`${gameState.currentLevel}|`);
                    // fallback: numeric entries (legacy) - treat as belonging to this level only if they look like an index
                    const n = Number(s);
                    return !isNaN(n) && n < gameState.questionData.length;
                });
                
                if (gameState.levelPerfect && !levelUsedHints && allCorrect) {
                    // 完美關卡（全對且無提示且無失誤）
                    gameState.levelResults[gameState.currentLevel] = 'perfect';
                    gameState.score += 300;
                    showScoreAnimation('完美+300分', true);
                    console.log('完美關卡！');
                } else if (allCorrect) {
                    // 全對關卡（全對但可能用了提示或有失誤）
                    gameState.levelResults[gameState.currentLevel] = 'complete';
                    gameState.score += 100;
                    showScoreAnimation('全對+100分', true);
                    console.log('全對關卡！');
                } else {
                    // 部分正確
                    gameState.levelResults[gameState.currentLevel] = 'partial';
                    console.log('部分正確關卡');
                }
                
                // 立即更新關卡進度顯示
                updateLevelOvals();
                
                // 使用更短的延遲並確保執行
                setTimeout(() => {
                    console.log(`當前關卡: ${gameState.currentLevel}`);
                    if (gameState.currentLevel >= 5) {
                        console.log('遊戲完成！');
                        showEncouragement();
                        setTimeout(() => {
                            console.log('執行完成遊戲');
                            completeGame();
                        }, 1500);
                    } else {
                        console.log('進入下一關');
                        showEncouragement();
                        setTimeout(() => {
                            console.log('執行下一關');
                            nextLevel();
                        }, 1500);
                    }
                }, 800);
            }
        }

        function useHint() {
            if (gameState.hintsRemaining <= 0) return;
            const hintBtn = document.getElementById('hintBtn');
            if (hintBtn.disabled) return;

            // 禁用提示按鈕，避免連續誤點
            hintBtn.disabled = true;
            hintBtn.classList.add('opacity-50', 'cursor-not-allowed');

            // 找到所有未完成且未答錯的題目
            const availableQuestions = [];
            gameState.questionData.forEach((question, index) => {
                const verseCard = document.querySelector(`[data-index="${index}"]`);
                if (verseCard &&
                    !verseCard.classList.contains('bg-green-100') &&
                    !verseCard.classList.contains('bg-red-100') &&
                    gameState.questionAttempts[index] > 0) {
                    availableQuestions.push(index);
                }
            });
            if (availableQuestions.length === 0) {
                // 沒有可提示題目，立即恢復按鈕
                setTimeout(() => {
                    if (gameState.hintsRemaining > 0) {
                        hintBtn.disabled = false;
                        hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }, 500);
                return;
            }

            // 扣除提示次數
            gameState.hintsRemaining--;
            updateGameUI();

            // Prefer the currently selected question if the player has one selected and it's still answerable;
            // otherwise pick a random available question.
            let selectedQuestionIndex = null;
            if (gameState.selectedVerseIndex != null) {
                const sel = gameState.selectedVerseIndex;
                const selCard = document.querySelector(`[data-index="${sel}"]`);
                const selAttempts = typeof gameState.questionAttempts[sel] === 'number' ? gameState.questionAttempts[sel] : 0;
                const selNotAnswered = selCard && !selCard.classList.contains('bg-green-100') && !selCard.classList.contains('bg-red-100') && selAttempts > 0;
                if (selNotAnswered) selectedQuestionIndex = sel;
            }

            if (selectedQuestionIndex == null) {
                const randomIndex = Math.floor(Math.random() * availableQuestions.length);
                selectedQuestionIndex = availableQuestions[randomIndex];
            }
            const selectedQuestion = gameState.questionData[selectedQuestionIndex];
            try {
                const levelKey = `${gameState.currentLevel}|${selectedQuestionIndex}`;
                gameState.usedHints.add(levelKey);
            } catch (e) {
                // fallback for environments where usedHints may not be a Set
                try { gameState.usedHints.add(selectedQuestionIndex); } catch (ee) { /* ignore */ }
            }

            // 清除所有現有的提示效果
            document.querySelectorAll('.hint-flash').forEach(element => {
                element.classList.remove('hint-flash');
            });

            // 找到正確的章節卡片（easy 使用 pairId）
            const verseCard = document.querySelector(`[data-index="${selectedQuestionIndex}"]`);
            let correctChapter = null;
            if (gameState.difficulty === 'easy' && selectedQuestion.pairId) {
                correctChapter = document.querySelector(`[data-pair-id="${selectedQuestion.pairId}"]`);
            } else {
                correctChapter = document.querySelector(`[data-book="${selectedQuestion.book}"][data-chapter="${selectedQuestion.chapter}"]`);
            }
            if (correctChapter && verseCard) {
                correctChapter.classList.add('hint-flash');
                verseCard.classList.add('hint-flash');
                // 4秒後移除效果並恢復按鈕
                setTimeout(() => {
                    correctChapter.classList.remove('hint-flash');
                    verseCard.classList.remove('hint-flash');
                    if (gameState.hintsRemaining > 0) {
                        hintBtn.disabled = false;
                        hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }, 4000);
            } else {
                // 若找不到卡片，1秒後恢復按鈕
                setTimeout(() => {
                    if (gameState.hintsRemaining > 0) {
                        hintBtn.disabled = false;
                        hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }, 1000);
            }
        }
        


        function showScoreAnimation(text, isSpecial, targetElement = null) {
            const scoreElement = document.getElementById('centerScore');
            
            // 檢查是否需要數字動畫
            const currentScore = parseInt(scoreElement.textContent) || 0;
            const newScore = gameState.score;
            
            if (newScore !== currentScore) {
                // 使用計數動畫更新分數
                // pulse and particles scaled by the delta
                try { pulseCenterScore(newScore - currentScore); } catch (e) {}
                try { spawnScoreParticles(newScore - currentScore); } catch (e) {}
                animateScoreWithCounting(currentScore, newScore);
            } else {
                // 直接更新分數顯示
                scoreElement.textContent = gameState.score;
            }
            
            // 移除「分」字
            const displayText = text.replace('分', '');
            
            // 檢查是否有現有的普通得分動畫，如果有則移除
            if (!isSpecial) {
                const existingScorePopups = document.querySelectorAll('.score-popup');
                existingScorePopups.forEach(popup => {
                    if (popup.parentElement) {
                        popup.parentElement.removeChild(popup);
                    }
                });
            }
            
            // 創建浮動分數動畫
            const floatingScore = document.createElement('div');
            floatingScore.textContent = displayText;
            floatingScore.style.pointerEvents = 'none';
            floatingScore.style.zIndex = '9999';
            floatingScore.style.position = 'absolute';
            
            // 根據分數類型設置不同效果和位置
            if (text.includes('完美+300')) {
                // 完美獎勵: on mobile animate to centerBadge and overlay like ordinary +score;
                // on desktop keep the full-screen central perfect popup
                const isMobile = (window.matchMedia && window.matchMedia('(max-width: 640px)').matches) || window.innerWidth <= 640;
                if (isMobile) {
                    // Mobile: prefer overlaying on the actual center score (gold number). Do not create badges.
                    floatingScore.className = 'text-5xl font-extrabold text-yellow-400 score-popup';
                    floatingScore.style.textShadow = '0 2px 8px rgba(0,0,0,0.45)';
                    try {
                        const pad = 8;

                        // Prefer the actual center score element if available
                        let destRect = null;
                        const centerEl = document.getElementById('centerScore');
                        if (centerEl) {
                            try { const r = centerEl.getBoundingClientRect(); if (r && r.width > 4) destRect = r; } catch(e) { destRect = null; }
                        }
                        // fallback to mobile-center-badge if present
                        if (!destRect) {
                            const centerBadge = document.querySelector('.mobile-center-badge');
                            if (centerBadge) {
                                try { const r = centerBadge.getBoundingClientRect(); if (r) destRect = r; } catch(e) { destRect = null; }
                            }
                        }
                        // final fallback to viewport center
                        if (!destRect) destRect = { left: Math.round(window.innerWidth / 2), top: Math.round(window.innerHeight / 2), width: 0, height: 0 };

                        let destLeft = Math.round(destRect.left + destRect.width / 2);
                        let destTop = Math.round(destRect.top + destRect.height / 2);

                        floatingScore.style.position = 'fixed';
                        floatingScore.style.whiteSpace = 'nowrap';
                        floatingScore.style.fontSize = '1.3rem';
                        floatingScore.style.padding = '0';
                        floatingScore.style.borderRadius = '0';
                        floatingScore.style.background = 'none';
                        floatingScore.style.backdropFilter = '';
                        floatingScore.style.opacity = '0';
                        floatingScore.style.zIndex = '10002';
                        document.body.appendChild(floatingScore);
                        // Add particles and pulse for perfect on mobile: show gold glitter
                        try { pulseCenterScore(300); } catch(e) {}
                        try { spawnGoldGlitter(300); } catch(e) {}

                        const popupRect = floatingScore.getBoundingClientRect();
                        const popupW = popupRect.width;
                        const popupH = popupRect.height;
                        let destLeftPx = destLeft - Math.round(popupW / 2);
                        let destTopPx = destTop - Math.round(popupH / 2);
                        destLeftPx = Math.max(pad, Math.min(window.innerWidth - pad - popupW, destLeftPx));
                        destTopPx = Math.max(pad, Math.min(window.innerHeight - pad - popupH, destTopPx));

                        if (targetElement) {
                            const startRect = targetElement.getBoundingClientRect();
                            const startCenterX = Math.round(startRect.left + startRect.width / 2);
                            const startCenterY = Math.round(startRect.top + startRect.height / 2);
                            let startLeftPx = startCenterX - Math.round(popupW / 2);
                            let startTopPx = startCenterY - Math.round(popupH / 2);
                            startLeftPx = Math.max(pad, Math.min(window.innerWidth - pad - popupW, startLeftPx));
                            startTopPx = Math.max(pad, Math.min(window.innerHeight - pad - popupH, startTopPx));
                            floatingScore.style.left = startLeftPx + 'px';
                            floatingScore.style.top = startTopPx + 'px';
                            floatingScore.style.transform = 'scale(1.15)';
                            floatingScore.style.transition = 'left 520ms cubic-bezier(.2,.9,.2,1), top 520ms cubic-bezier(.2,.9,.2,1), opacity 520ms ease, transform 520ms cubic-bezier(.2,.9,.2,1)';
                            floatingScore.getBoundingClientRect();
                            requestAnimationFrame(() => {
                                floatingScore.style.left = destLeftPx + 'px';
                                floatingScore.style.top = destTopPx + 'px';
                                floatingScore.style.opacity = '1';
                                floatingScore.style.transform = 'scale(1)';
                            });
                        } else {
                            floatingScore.style.left = destLeftPx + 'px';
                            floatingScore.style.top = destTopPx + 'px';
                            floatingScore.style.transition = 'opacity 240ms ease, transform 320ms cubic-bezier(.2,.9,.2,1)';
                            requestAnimationFrame(() => {
                                floatingScore.style.opacity = '1';
                                floatingScore.style.transform = 'scale(1)';
                            });
                        }
                    } catch (e) {
                        // fallback to desktop behavior if anything fails
                        floatingScore.className = 'text-7xl font-black text-yellow-500 perfect-popup';
                        floatingScore.style.textShadow = '0 0 50px rgba(255, 215, 0, 1)';
                        floatingScore.style.position = 'fixed';
                        floatingScore.style.left = '50%';
                        floatingScore.style.top = '50%';
                        floatingScore.style.transform = 'translate(-50%, -50%)';
                        floatingScore.style.zIndex = '10000';
                        document.body.appendChild(floatingScore);
                        scoreElement.classList.add('score-flash');
                        // Desktop: sustained gold-glitter effect
                        try { spawnGoldGlitter(300, document.body); } catch(e) {}
                        try { pulseCenterScore(300); } catch(e) {}
                    }
                } else {
                    // Desktop: original full-screen perfect popup
                    floatingScore.className = 'text-7xl font-black text-yellow-500 perfect-popup';
                    floatingScore.style.textShadow = '0 0 50px rgba(255, 215, 0, 1)';
                    floatingScore.style.position = 'fixed';
                    floatingScore.style.left = '50%';
                    floatingScore.style.top = '50%';
                    floatingScore.style.transform = 'translate(-50%, -50%)';
                    floatingScore.style.zIndex = '10000';
                    document.body.appendChild(floatingScore);
                    scoreElement.classList.add('score-flash');
                        createPerfectEffects(document.body);
                        try { pulseCenterScore(300); } catch(e) {}
                        try { spawnScoreParticles(300); } catch(e) {}
                }
            } else if (text.includes('全對+100')) {
                // 全對獎勵: same mobile overlay behavior as ordinary +score; desktop keeps large celebration
                const isMobile = (window.matchMedia && window.matchMedia('(max-width: 640px)').matches) || window.innerWidth <= 640;
                if (isMobile) {
                    // Mobile: prefer overlaying on centerScore for 全對 as well
                    floatingScore.className = 'text-4xl font-extrabold text-green-400 score-popup';
                    floatingScore.style.textShadow = '0 2px 8px rgba(0,0,0,0.35)';
                    try {
                        const pad = 8;

                        // Prefer the actual center score element if available
                        let destRect = null;
                        const centerEl = document.getElementById('centerScore');
                        if (centerEl) {
                            try { const r = centerEl.getBoundingClientRect(); if (r && r.width > 4) destRect = r; } catch(e) { destRect = null; }
                        }
                        // fallback to mobile-center-badge if present
                        if (!destRect) {
                            const centerBadge = document.querySelector('.mobile-center-badge');
                            if (centerBadge) {
                                try { const r = centerBadge.getBoundingClientRect(); if (r) destRect = r; } catch(e) { destRect = null; }
                            }
                        }
                        if (!destRect) destRect = { left: Math.round(window.innerWidth / 2), top: Math.round(window.innerHeight / 2), width: 0, height: 0 };

                        let destLeft = Math.round(destRect.left + destRect.width / 2);
                        let destTop = Math.round(destRect.top + destRect.height / 2);

                        floatingScore.style.position = 'fixed';
                        floatingScore.style.whiteSpace = 'nowrap';
                        floatingScore.style.fontSize = '1.15rem';
                        floatingScore.style.padding = '0';
                        floatingScore.style.borderRadius = '0';
                        floatingScore.style.background = 'none';
                        floatingScore.style.backdropFilter = '';
                        floatingScore.style.opacity = '0';
                        floatingScore.style.zIndex = '10002';
                        document.body.appendChild(floatingScore);
                            try { pulseCenterScore(100); } catch(e) {}
                            try { spawnConfettiRain(100, targetElement || null); } catch(e) {}

                        const popupRect = floatingScore.getBoundingClientRect();
                        const popupW = popupRect.width;
                        const popupH = popupRect.height;
                        let destLeftPx = destLeft - Math.round(popupW / 2);
                        let destTopPx = destTop - Math.round(popupH / 2);
                        destLeftPx = Math.max(pad, Math.min(window.innerWidth - pad - popupW, destLeftPx));
                        destTopPx = Math.max(pad, Math.min(window.innerHeight - pad - popupH, destTopPx));

                        if (targetElement) {
                            const startRect = targetElement.getBoundingClientRect();
                            const startCenterX = Math.round(startRect.left + startRect.width / 2);
                            const startCenterY = Math.round(startRect.top + startRect.height / 2);
                            let startLeftPx = startCenterX - Math.round(popupW / 2);
                            let startTopPx = startCenterY - Math.round(popupH / 2);
                            startLeftPx = Math.max(pad, Math.min(window.innerWidth - pad - popupW, startLeftPx));
                            startTopPx = Math.max(pad, Math.min(window.innerHeight - pad - popupH, startTopPx));
                            floatingScore.style.left = startLeftPx + 'px';
                            floatingScore.style.top = startTopPx + 'px';
                            floatingScore.style.transform = 'scale(1.12)';
                            floatingScore.style.transition = 'left 520ms cubic-bezier(.2,.9,.2,1), top 520ms cubic-bezier(.2,.9,.2,1), opacity 520ms ease, transform 520ms cubic-bezier(.2,.9,.2,1)';
                            floatingScore.getBoundingClientRect();
                            requestAnimationFrame(() => {
                                floatingScore.style.left = destLeftPx + 'px';
                                floatingScore.style.top = destTopPx + 'px';
                                floatingScore.style.opacity = '1';
                                floatingScore.style.transform = 'scale(1)';
                            });
                        } else {
                            floatingScore.style.left = destLeftPx + 'px';
                            floatingScore.style.top = destTopPx + 'px';
                            floatingScore.style.transition = 'opacity 240ms ease, transform 320ms cubic-bezier(.2,.9,.2,1)';
                            requestAnimationFrame(() => {
                                floatingScore.style.opacity = '1';
                                floatingScore.style.transform = 'scale(1)';
                            });
                        }
                    } catch (e) {
                        floatingScore.className = 'text-6xl font-black text-green-500 celebration-popup';
                        floatingScore.style.textShadow = '0 0 15px rgba(34, 197, 94, 0.6), 0 2px 4px rgba(0, 0, 0, 0.3)';
                        floatingScore.style.position = 'fixed';
                        floatingScore.style.left = '50%';
                        floatingScore.style.top = '50%';
                        floatingScore.style.transform = 'translate(-50%, -50%)';
                        floatingScore.style.zIndex = '10000';
                        document.body.appendChild(floatingScore);
                            createCelebrationEffects(document.body);
                            try { pulseCenterScore(100); } catch(e) {}
                            try { spawnScoreParticles(100); } catch(e) {}
                    }
                } else {
                    floatingScore.className = 'text-6xl font-black text-green-500 celebration-popup';
                    floatingScore.style.textShadow = '0 0 15px rgba(34, 197, 94, 0.6), 0 2px 4px rgba(0, 0, 0, 0.3)';
                    floatingScore.style.position = 'fixed';
                    floatingScore.style.left = '50%';
                    floatingScore.style.top = '50%';
                    floatingScore.style.transform = 'translate(-50%, -50%)';
                    floatingScore.style.zIndex = '10000';
                    document.body.appendChild(floatingScore);
                        createCelebrationEffects(document.body);
                        try { pulseCenterScore(100); } catch(e) {}
                        try { spawnConfettiRain(100); } catch(e) {}
                }
            } else {
                // 普通得分/扣分動畫 - 顯示在對應的經文卡片上方
                const isNegative = text.includes('-');
                floatingScore.className = `text-4xl font-black ${isNegative ? 'text-red-500' : 'text-green-500'} score-popup`;
                floatingScore.style.textShadow = isNegative ? 
                    '0 0 20px rgba(239, 68, 68, 0.6)' : 
                    '0 0 20px rgba(34, 197, 94, 0.6)';
                
                // On mobile prefer showing next to the center score (gold number) so the popup isn't clipped
                // inside the verse card (which causes it to be invisible on small screens).
                const isMobile = (window.matchMedia && window.matchMedia('(max-width: 640px)').matches) || window.innerWidth <= 640;
                const centerBadge = document.querySelector('.mobile-center-badge');
                if (isMobile) {
                    // Animate the floating score from the verse card (if provided) to the center score/gold number
                    try {
                        const pad = 8; // px padding from viewport edge

                        // Prefer the actual center score element if available (do not create badges or touch encouragementText)
                        let destRect = null;
                        let centerRect = null;
                        const centerEl = document.getElementById('centerScore');
                        if (centerEl) {
                            try { centerRect = centerEl.getBoundingClientRect(); } catch(e) { centerRect = null; }
                            if (centerRect && centerRect.width > 4) destRect = centerRect;
                        }
                        // fallback to mobile-center-badge if centerScore not measurable
                        if (!destRect && centerBadge) {
                            try { destRect = centerBadge.getBoundingClientRect(); } catch(e) { destRect = null; }
                        }
                        // final fallback to viewport center
                        if (!destRect) {
                            destRect = { left: Math.round(window.innerWidth / 2), top: Math.round(window.innerHeight / 2), width: 0, height: 0 };
                        }

                        let destLeft = Math.round(destRect.left + destRect.width / 2);
                        let destTop = Math.round(destRect.top + destRect.height / 2);

                        floatingScore.style.position = 'fixed';
                        floatingScore.style.left = destLeft + 'px';
                        floatingScore.style.top = destTop + 'px';
                        // apply temporary transform so we can measure size
                        floatingScore.style.transform = 'translate(-50%, -50%) scale(0.95)';
                        floatingScore.style.zIndex = '10001';
                        // ensure mobile-friendly size and prevent wrapping/truncation
                        floatingScore.style.whiteSpace = 'nowrap';
                        floatingScore.style.fontSize = '1.2rem';
                        floatingScore.style.padding = '2px 6px';
                        floatingScore.style.borderRadius = '6px';
                        floatingScore.style.background = 'rgba(255,255,255,0.06)';
                        floatingScore.style.backdropFilter = 'saturate(120%) blur(4px)';
                        floatingScore.style.opacity = '0';
                        document.body.appendChild(floatingScore);

                        // Measure and clamp using the popup's size so it won't be clipped at edges.
                        const popupRect = floatingScore.getBoundingClientRect();
                        const popupW = popupRect.width;
                        const popupH = popupRect.height;

                        // Determine whether we should overlay directly on the gold center score
                        const useCenterOverlay = !!centerRect;

                        // compute top-left coords so the popup is fully visible
                        let destLeftPx = destLeft - Math.round(popupW / 2);
                        let destTopPx = destTop - Math.round(popupH / 2);
                        destLeftPx = Math.max(pad, Math.min(window.innerWidth - pad - popupW, destLeftPx));
                        destTopPx = Math.max(pad, Math.min(window.innerHeight - pad - popupH, destTopPx));
                        // update to clamped top-left
                        floatingScore.style.left = destLeftPx + 'px';
                        floatingScore.style.top = destTopPx + 'px';
                        floatingScore.style.transform = 'scale(0.95)';

                        // If overlaying on the center score, remove translucent background so it covers the gold number
                        if (useCenterOverlay) {
                            floatingScore.style.background = 'none';
                            floatingScore.style.backdropFilter = '';
                            floatingScore.style.padding = '0';
                            floatingScore.style.borderRadius = '0';
                            floatingScore.style.color = ''; // keep CSS class color
                            floatingScore.style.zIndex = '10002';
                            // add stronger text shadow so numeric text reads over the gold background
                            floatingScore.style.textShadow = '0 2px 8px rgba(0,0,0,0.45)';
                            // slightly increase font-size to be visually prominent
                            floatingScore.style.fontSize = '1.15rem';
                        }

                        // If we have a source element, start at its center and animate to the center score
                        if (targetElement) {
                            try {
                                const startRect = targetElement.getBoundingClientRect();
                                const startCenterX = Math.round(startRect.left + startRect.width / 2);
                                const startCenterY = Math.round(startRect.top + startRect.height / 2);
                                // compute start top-left for popup
                                let startLeftPx = startCenterX - Math.round(popupW / 2);
                                let startTopPx = startCenterY - Math.round(popupH / 2);
                                startLeftPx = Math.max(pad, Math.min(window.innerWidth - pad - popupW, startLeftPx));
                                startTopPx = Math.max(pad, Math.min(window.innerHeight - pad - popupH, startTopPx));
                                floatingScore.style.left = startLeftPx + 'px';
                                floatingScore.style.top = startTopPx + 'px';
                                floatingScore.style.transform = 'scale(1.15)';

                                // prepare transition (animate left/top and scale/opacity)
                                floatingScore.style.transition = 'left 520ms cubic-bezier(.2,.9,.2,1), top 520ms cubic-bezier(.2,.9,.2,1), opacity 520ms ease, transform 520ms cubic-bezier(.2,.9,.2,1)';
                                // force layout then animate to destination (top-left coords)
                                floatingScore.getBoundingClientRect();
                                requestAnimationFrame(() => {
                                    floatingScore.style.left = destLeftPx + 'px';
                                    floatingScore.style.top = destTopPx + 'px';
                                    floatingScore.style.opacity = '1';
                                    floatingScore.style.transform = 'scale(1)';
                                });
                            } catch (innerErr) {
                                // if measuring the source fails, fallback to showing at destination
                                floatingScore.style.opacity = '1';
                                floatingScore.style.transform = 'scale(1)';
                            }
                        } else {
                            // no source: simple pop-in at destination (already set to top-left)
                            floatingScore.style.transition = 'opacity 240ms ease, transform 320ms cubic-bezier(.2,.9,.2,1)';
                            requestAnimationFrame(() => {
                                floatingScore.style.opacity = '1';
                                floatingScore.style.transform = 'scale(1)';
                            });
                        }
                    } catch (e) {
                        // If centering failed entirely, try overlaying on the verse/chapter title (front/back)
                        const alt = document.getElementById('verseTitle') || document.getElementById('chapterTitle');
                        if (alt) {
                            // overlay directly over the title text (covering it)
                            floatingScore.style.position = 'absolute';
                            floatingScore.style.left = '50%';
                            floatingScore.style.top = '50%';
                            floatingScore.style.transform = 'translate(-50%, -50%)';
                            floatingScore.style.opacity = '1';
                            floatingScore.style.zIndex = '9999';
                            floatingScore.style.background = 'linear-gradient(90deg,#16a34a,#4ade80)';
                            floatingScore.style.color = '#fff';
                            floatingScore.style.padding = '4px 8px';
                            floatingScore.style.borderRadius = '6px';
                            alt.style.position = 'relative';
                            alt.appendChild(floatingScore);
                        } else {
                            // final fallback: attach to score container like before
                            if (targetElement) {
                                floatingScore.style.left = '50%';
                                floatingScore.style.top = '-10px';
                                floatingScore.style.transform = 'translate(-50%, -100%)';
                                targetElement.style.position = 'relative';
                                targetElement.appendChild(floatingScore);
                            } else {
                                floatingScore.style.right = '-20px';
                                floatingScore.style.top = '50%';
                                floatingScore.style.transform = 'translateY(-50%)';
                                scoreElement.parentElement.style.position = 'relative';
                                scoreElement.parentElement.appendChild(floatingScore);
                            }
                        }
                    }
                } else if (targetElement) {
                    // 在經文卡片上方顯示
                    floatingScore.style.left = '50%';
                    floatingScore.style.top = '-10px';
                    floatingScore.style.transform = 'translate(-50%, -100%)';
                    
                    targetElement.style.position = 'relative';
                    targetElement.appendChild(floatingScore);
                } else {
                    // 備用位置：分數區域右側
                    floatingScore.style.right = '-20px';
                    floatingScore.style.top = '50%';
                    floatingScore.style.transform = 'translateY(-50%)';
                    
                    scoreElement.parentElement.style.position = 'relative';
                    scoreElement.parentElement.appendChild(floatingScore);
                }
            }
            
            // 移除動畫元素
            // 縮短浮動分數顯示時間以匹配更快的計數動畫
            const duration = text.includes('完美+300') ? 2000 : text.includes('全對+100') ? 1600 : 1200;
            // Prefer listening for transitionend when we set a transition (mobile fly animation)
            let removed = false;
            function cleanup() {
                if (removed) return;
                removed = true;
                try { if (floatingScore.parentElement) floatingScore.parentElement.removeChild(floatingScore); } catch(e) {}
                try { scoreElement.classList.remove('score-flash'); } catch(e) {}
            }

            if (floatingScore.style.transition) {
                const to = setTimeout(cleanup, duration + 120);
                floatingScore.addEventListener('transitionend', function te(e) {
                    // ensure it was our element finishing
                    if (e.target === floatingScore) {
                        clearTimeout(to);
                        floatingScore.removeEventListener('transitionend', te);
                        cleanup();
                    }
                });
            } else {
                setTimeout(cleanup, duration);
            }
        }
        
        function createPerfectEffects(container) {
            // debug: report that perfect effects are triggered and the provided container
            try { console.log('[DEBUG] createPerfectEffects called, container:', container && (container.id || container.tagName || String(container))); } catch(e) {}
            // Create dispersed star sparkle effects. Use the high-z .gold-glitter style
            // (which uses position: fixed and a high z-index) so the stars are not
            // clipped by lower stacking contexts on desktop. We still drive the
            // sparkle animation using the existing keyframes for a consistent look.
            for (let i = 0; i < 12; i++) {
                const sparkle = document.createElement('div');
                sparkle.textContent = '✨';
                // Use the gold-glitter class (position:fixed; high z-index)
                sparkle.className = 'gold-glitter perfect-sparkle';
                // allow per-instance sizing
                sparkle.style.fontSize = '4rem';

                // evenly distributed angles with a little radius randomness
                const angle = (i / 12) * 2 * Math.PI;
                const radius = 150 + Math.random() * 100;
                const centerX = Math.round(window.innerWidth / 2);
                const centerY = Math.round(window.innerHeight / 2);

                // Place using fixed coordinates so they appear across the whole viewport
                sparkle.style.left = (centerX + Math.cos(angle) * radius) + 'px';
                sparkle.style.top = (centerY + Math.sin(angle) * radius) + 'px';
                sparkle.style.transform = 'translate(-50%, -50%)';
                sparkle.style.pointerEvents = 'none';
                // Override class animation to use sparkleEffect timing so existing keyframes are reused
                sparkle.style.animation = `sparkleEffect 1.2s ease-out ${i * 0.08}s forwards`;

                document.body.appendChild(sparkle);

                setTimeout(() => {
                    if (sparkle.parentElement) sparkle.parentElement.removeChild(sparkle);
                }, 1400 + Math.round(i * 80));
            }
        }
        
        function createCelebrationEffects(container) {
            // debug: report that celebration effects are triggered and the provided container
            try { console.log('[DEBUG] createCelebrationEffects called, container:', container && (container.id || container.tagName || String(container))); } catch(e) {}
            // Create celebration confetti pieces. Use fixed positioning and a
            // higher z-index so confetti is visible above typical page content
            // on desktop (prevents clipping when container has transforms).
            for (let i = 0; i < 8; i++) {
                const confetti = document.createElement('div');
                confetti.textContent = '🎉';
                confetti.className = 'confetti-piece';
                // confetti-piece already defines position: fixed and animation; but
                // ensure visibility and sizing for this instance
                confetti.style.position = 'fixed';
                confetti.style.fontSize = '3rem';
                confetti.style.left = (20 + i * 8) + '%';
                confetti.style.top = '25%';
                confetti.style.pointerEvents = 'none';
                confetti.style.zIndex = '10005';
                confetti.style.animation = `confettiEffect 1.0s ease-out ${i * 0.05}s forwards`;

                document.body.appendChild(confetti);

                setTimeout(() => {
                    if (confetti.parentElement) confetti.parentElement.removeChild(confetti);
                }, 1100 + Math.round(i * 50));
            }
        }

        function showEncouragement() {
            // 根據不同情況的鼓勵話語
            const levelResults = gameState.levelResults[gameState.currentLevel];
            let encouragements = [];
            
            if (levelResults === 'perfect') {
                encouragements = [
                    '完美！棒極了！',
                    '太棒了！經文達人！',
                    '無懈可擊！超強！',
                    '完美表現！蒙福！'
                ];
            } else if (levelResults === 'complete') {
                encouragements = [
                    '全對！厲害！',
                    '太棒了！扎實！',
                    '優秀！繼續！',
                    '很好！繼續前進！'
                ];
            } else {
                encouragements = [
                    '不錯！加油！',
                    '加油！一步一步！',
                    '很好！持續！',
                    '繼續！多研讀！',
                    '努力！主恩夠用！'
                ];
            }
            
            const randomEncouragement = encouragements[Math.floor(Math.random() * encouragements.length)];
            const encouragementElement = document.getElementById('encouragementText');

            // Ensure the element is attached to document.body so it's not confined by parent stacking contexts
            try {
                if (encouragementElement.parentElement !== document.body) document.body.appendChild(encouragementElement);
            } catch (e) { /* ignore DOM move errors */ }

            // Show encouragement as a centered overlay (fixed) so the full sentence is visible
            encouragementElement.style.position = 'fixed';
            encouragementElement.style.left = '50%';
            encouragementElement.style.top = '50%';
            encouragementElement.style.transform = 'translate(-50%, -50%)';
            // Place encouragement above pinned controls but below modals so modals cover it
            encouragementElement.style.zIndex = '45';
            encouragementElement.style.pointerEvents = 'none';
            encouragementElement.style.textAlign = 'center';
            encouragementElement.style.padding = '0 12px';
            encouragementElement.style.maxWidth = '92vw';
            // allow wrapping so long phrases show fully inside the centered box
            encouragementElement.style.whiteSpace = 'normal';

            // enforce a stable white->yellow gradient color for the entire show lifecycle
            const gradientClass = 'text-3xl md:text-2xl font-extrabold platinum-gold-text opacity-100';
            const origEncClass = gradientClass; // ensure restoration keeps the same gradient
            encouragementElement.className = gradientClass;
            // rendering hints to keep the text crisp during animation
            encouragementElement.style.willChange = 'transform, opacity';
            encouragementElement.style.filter = 'none';
            // set the text inside an inner span so we can animate scale-only reliably on mobile
            encouragementElement.innerHTML = `<span class="encourage-inner">${randomEncouragement}</span>`;
            const innerSpan = encouragementElement.querySelector('.encourage-inner');
            // If on mobile, enforce single-line and shrink text to fit container if necessary
            if ((window.matchMedia && window.matchMedia('(max-width:640px)').matches) || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '')) {
                // make sure inner span is on one line
                if (innerSpan) {
                    innerSpan.style.whiteSpace = 'nowrap';
                    innerSpan.style.display = 'inline-block';
                }
                // shrink-to-fit: reduce font-size until it no longer overflows or min reached
                const containerWidth = encouragementElement.clientWidth || encouragementElement.getBoundingClientRect().width;
                if (innerSpan && containerWidth > 0) {
                    const style = window.getComputedStyle(innerSpan);
                    let fontSizePx = parseFloat(style.fontSize) || 20;
                    const minFontPx = 14; // do not shrink below this
                    // Measure and shrink if needed
                    while (fontSizePx > minFontPx && innerSpan.scrollWidth > containerWidth) {
                        fontSizePx -= 1;
                        innerSpan.style.fontSize = fontSizePx + 'px';
                    }
                }
            }
            // force a reflow to ensure the browser registers the DOM/text change
            void encouragementElement.offsetWidth;

            // Simple, non-blurry display: fade in, hold, then fade out and cleanup.
            // Avoid any scale/pulse animations which can cause perceived blur in some webviews.
            encouragementElement.style.transition = 'opacity 420ms cubic-bezier(.2,.9,.2,1)';
            // ensure starting opacity is 0 for a clean fade-in
            encouragementElement.style.opacity = '0';
            // trigger fade-in
            requestAnimationFrame(() => { encouragementElement.style.opacity = '1'; });

            const visibleMs = 2400; // how long text stays visible before fading out (doubled)

            // Clear any previous timers attached to this element to avoid leftover visuals
            try {
                if (encouragementElement.__enc_timers) {
                    encouragementElement.__enc_timers.forEach(id => clearTimeout(id));
                }
            } catch (e) {}
            encouragementElement.__enc_timers = [];

            // schedule fade-out
            const fadeTimer = setTimeout(() => {
                encouragementElement.style.opacity = '0';
            }, visibleMs);
            encouragementElement.__enc_timers.push(fadeTimer);

            // final cleanup after fade-out completes
            const cleanupTimer = setTimeout(() => {
                try { encouragementElement.className = origEncClass; } catch (e) { encouragementElement.className = ''; }
                // remove text content so element no longer occupies visual space
                encouragementElement.innerHTML = '';
                // clear inline styles we added
                encouragementElement.style.transition = '';
                encouragementElement.style.opacity = '';
                encouragementElement.style.willChange = '';
                encouragementElement.style.filter = '';

                // clear stored timers
                try { encouragementElement.__enc_timers.forEach(id => clearTimeout(id)); } catch (e) {}
                encouragementElement.__enc_timers = null;

                // If a mobile badge observer was previously attached, ensure it remains disconnected
                try {
                    if (encouragementElement.__mobileBadgeObserver) {
                        encouragementElement.__mobileBadgeObserver.disconnect();
                        delete encouragementElement.__mobileBadgeObserver;
                    }
                } catch (e) {}
            }, visibleMs + 500);
            encouragementElement.__enc_timers.push(cleanupTimer);
        }

        function showGameInstruction(text, autoFadeMs = 2000) {
            // 使用可愛吐司提示取代覆蓋層
            showCuteHint(text, 'purple', autoFadeMs, '✨');
            // 回傳淡出函數供外部手動調用
            return () => hideCuteHint();
        }
        
        function showHintReminder() {
            // 用可愛吐司提示提醒有提示功能
            showCuteHint(pick(HINTS.hintReminder), 'amber', 2400, '💡');
        }

        function nextLevel() {
            // 在進入下一關前，先檢查剩餘未使用的可用經文數是否足夠（至少 5 篇）
            try {
                const pool = getAvailableVerses();
                const usedKey = (v) => `${v.book}|${v.chapter}|${v.verse}`;
                const usedVersesSet = gameState.usedVerses || new Set();
                const uniqueRemaining = Array.isArray(pool) ? pool.filter(v => !usedVersesSet.has(usedKey(v))).length : 0;
                if (uniqueRemaining < 5) {
                    alert('⚠️ 剩餘未使用的可用經文不足 5 篇，請擴大範圍或改選罕見度。本局將結束。');
                    // 結束本局並顯示結算
                    completeGame();
                    return;
                }
            } catch (e) {
                // 若檢查過程發生例外，保守起見仍嘗試進入下一關
            }

            gameState.currentLevel++;
            gameState.isFirstQuestionOfLevel = true;
            gameState.levelHintReminderShown = false; // 重置每關提示提醒狀態

            generateLevel();
            updateGameUI();
        }

        function completeGame() {
            // 停止計時器
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            // 標記遊戲完成並記錄完成時間
            gameState.gameCompleted = true;
            gameState.gameEndTime = Date.now(); // 記錄遊戲結束時間
            
            // 先計算 accuracy 並更新/選定結語經文，讓之後的儲存會包含相同的 closing verse
            const accuracy = gameState.totalQuestions > 0 ? Math.round((gameState.totalCorrectAnswers / gameState.totalQuestions) * 100) : 0;
            try { updateClosingVerse(accuracy); } catch (e) {}

            // 保存分數到排行榜（此時 gameState.closingVerse 已存在）
            // Visual feedback on game completion
            try { pulseCenterScore(gameState.score ? Math.min(300, gameState.score) : 100); } catch(e) {}
            try { spawnScoreParticles(gameState.score ? Math.min(300, gameState.score) : 100); } catch(e) {}

            const gameRecord = saveScore(gameState.score);
            
            // 直接在遊戲畫面顯示結算視窗
            checkAndShowGameComplete(gameRecord);
        }
        
    async function checkAndShowGameComplete(gameRecord) {
            let rank = 0;
            
            // 只有選擇排行模式（罕見度）且完成遊戲才能進入排行榜
            if (gameState.rarity && gameState.gameCompleted) {
                const ldr = loadLeaderboard();
                const allLeaderboards = (ldr && typeof ldr.then === 'function') ? await ldr : ldr;
                const currentLeaderboard = (allLeaderboards && allLeaderboards[gameState.difficulty]) ? allLeaderboards[gameState.difficulty] : [];
                
                // 檢查是否能進入排行榜（前5名）
                if (currentLeaderboard.length < 5) {
                    // 排行榜未滿，直接進入（最多保留前5名）
                    rank = currentLeaderboard.length + 1;
                } else {
                    // 檢查是否超過最低分數
                    const lowestScore = currentLeaderboard[currentLeaderboard.length - 1].score;
                    if (gameState.score > lowestScore) {
                        // 計算排名
                        for (let i = 0; i < currentLeaderboard.length; i++) {
                            if (gameState.score > currentLeaderboard[i].score) {
                                rank = i + 1;
                                break;
                            }
                        }
                        if (rank === 0) rank = currentLeaderboard.length + 1;
                    }
                }
            }
            
            // 顯示結算視窗
            if (gameState.skipLeaderboardOnComplete && gameState.replaySourceRecord) {
                // For replay runs: show a modal that visually matches the leaderboard-record view
                showReplayEndModal(rank, gameState.replaySourceRecord);
            } else {
                showPlayerNameModal(rank);
            }
        }

        // Show the end-of-replay modal: reuse the same modal structure as record-view but
        // populate static fields (closing verse, date/time, player name) from the original record
        // while recalculating the detailed score breakdown from the current gameState.
        function showReplayEndModal(rank, sourceRecord) {
            const modal = document.getElementById('playerNameModal');
            if (!modal) return;

            // Ensure modal is in 'viewing' mode so name input is hidden and close behaves like record view
            modal.dataset.viewingRecord = 'true';
            modal.dataset.viewingDifficulty = sourceRecord.difficulty || gameState.difficulty || '';
            // Set currentRecord so the "同題重玩" button can start another replay using the same snapshot
            try { modal.dataset.currentRecord = JSON.stringify(sourceRecord); } catch (e) { modal.dataset.currentRecord = ''; }

            // Update static displays using the stored record so it matches exactly what was shown when saved
            // but ensure score breakdown is rebuilt from the live gameState
            const rankMessage = document.getElementById('rankMessage');
            const leaderboardMessage = document.getElementById('leaderboardMessage');
            const leaderboardHeader = document.getElementById('leaderboardHeader');

            document.getElementById('finalScore').textContent = gameState.score;
            const accuracy = gameState.totalQuestions > 0 ? Math.round((gameState.totalCorrectAnswers / gameState.totalQuestions) * 100) : 0;
            document.getElementById('finalAccuracy').textContent = `${accuracy}%`;
            const ratioEl = document.getElementById('finalAccuracyRatio');
            if (ratioEl) ratioEl.innerHTML = `<strong>(${gameState.totalCorrectAnswers}/${gameState.totalQuestions})</strong>`;

            // Populate closing verse from the original saved record so it matches the leaderboard view
            try {
                const closingTextEl = document.getElementById('closingVerseText');
                const closingRefEl = document.getElementById('closingVerseRef');
                if (sourceRecord.closingVerse || sourceRecord.closingVerseRef) {
                    applyClosingVerse(sourceRecord.closingVerse, sourceRecord.closingVerseRef, false);
                } else {
                    // fallback to current gameState chosen verse
                    updateClosingVerse(accuracy);
                }
            } catch (e) {}

            // For replay runs we should NOT show any "entered leaderboard" congratulations
            // Always hide the leaderboard message/header and the name input so it matches record view
            if (leaderboardHeader) leaderboardHeader.innerHTML = '';
            if (leaderboardMessage) leaderboardMessage.classList.add('hidden');

            // Hide name input (viewing mode)
            const nameInputSection = document.getElementById('nameInputSection');
            if (nameInputSection) nameInputSection.classList.add('hidden');

            // Show the same-question replay button even in replay end modal (allow infinite replays)
            const replayBtn = document.getElementById('replaySameQuestionsBtn');
            if (replayBtn) {
                replayBtn.classList.remove('hidden');
            }

            // Rebuild the detailed breakdown from current gameState (not the stored record)
            generateScoreBreakdown();

            // Finally show modal and lock scroll
            modal.classList.remove('hidden');
            lockBodyScroll();

            // Clear input and errors
            const input = document.getElementById('playerNameInput');
            if (input) input.value = '';
            const nameError = document.getElementById('nameError');
            if (nameError) nameError.classList.add('hidden');

            // Enable Enter-to-confirm while this modal is open
            try { attachPlayerNameModalEnterHotkey(); } catch (e) {}
        }

    async function checkAndShowLeaderboardEntry(gameRecord) {
            // 只有選擇整本聖經且完成遊戲才能進入排行榜
            if (gameState.range !== 'all' || !gameState.gameCompleted) {
                return;
            }
            
            const ldr = loadLeaderboard();
            const allLeaderboards = (ldr && typeof ldr.then === 'function') ? await ldr : ldr;
            const currentLeaderboard = (allLeaderboards && allLeaderboards[gameState.difficulty]) ? allLeaderboards[gameState.difficulty] : [];
            
            // 檢查是否能進入排行榜（前5名）
            let canEnterLeaderboard = false;
            let rank = 0;
            if (currentLeaderboard.length < 5) {
                // 排行榜未滿，直接進入（最多保留前5名）
                canEnterLeaderboard = true;
                rank = currentLeaderboard.length + 1;
            } else {
                // 檢查是否超過最低分數
                const lowestScore = currentLeaderboard[currentLeaderboard.length - 1].score;
                if (gameState.score > lowestScore) {
                    canEnterLeaderboard = true;
                    // 計算排名
                    for (let i = 0; i < currentLeaderboard.length; i++) {
                        if (gameState.score > currentLeaderboard[i].score) {
                            rank = i + 1;
                            break;
                        }
                    }
                    if (rank === 0) rank = currentLeaderboard.length + 1;
                }
            }
            
            if (canEnterLeaderboard) {
                showPlayerNameModal(rank);
            }
        }

        function showPlayerNameModal(rank) {
            const modal = document.getElementById('playerNameModal');
            const rankMessage = document.getElementById('rankMessage');
            const leaderboardMessage = document.getElementById('leaderboardMessage');
            const leaderboardHeader = document.getElementById('leaderboardHeader');
            const nameInputSection = document.getElementById('nameInputSection');
            // Hide cute hint to avoid overlapping with modal
            try { hideCuteHint(); } catch (e) {}
            // Defensive: if duplicate closing verse elements were ever inserted, dedupe now
            try {
                const cv = document.getElementById('closingVerse');
                if (cv) {
                    const texts = cv.querySelectorAll('#closingVerseText');
                    const refs = cv.querySelectorAll('#closingVerseRef');
                    for (let i = 1; i < texts.length; i++) texts[i].remove();
                    for (let i = 1; i < refs.length; i++) refs[i].remove();
                }
            } catch (_) {}
            
            // 更新分數資訊
            document.getElementById('finalScore').textContent = gameState.score;
            const accuracy = gameState.totalQuestions > 0 ? Math.round((gameState.totalCorrectAnswers / gameState.totalQuestions) * 100) : 0;
            document.getElementById('finalAccuracy').textContent = `${accuracy}%`;
            const ratioEl = document.getElementById('finalAccuracyRatio');
            if (ratioEl) ratioEl.innerHTML = `<strong>(${gameState.totalCorrectAnswers}/${gameState.totalQuestions})</strong>`;
            
            // 生成詳細計分數據
            generateScoreBreakdown();
            
            // 根據遊玩狀況選擇結語經文
            updateClosingVerse(accuracy);
            
            // 如果進入排行榜，顯示排行榜訊息和名稱輸入
            // Also: when this modal is the post-game end modal, only show the same-question
            // replay button if this run did NOT actually enter the leaderboard (rank === 0).
            const replayBtn = document.getElementById('replaySameQuestionsBtn');
            const sameReplayNote = document.getElementById('sameReplayNote');
            if (rank > 0) {
                rankMessage.textContent = `您獲得了第${rank}名！`;
                if (leaderboardHeader) {
                    // choose class based on rank for visual styling
                    let cls = 'rank-default';
                    if (rank === 1) cls = 'rank-gold';
                    else if (rank === 2) cls = 'rank-silver';
                    else if (rank === 3) cls = 'rank-bronze';
                    leaderboardHeader.classList.remove('rank-gold','rank-silver','rank-bronze','rank-default');
                    leaderboardHeader.classList.add(cls);
                    leaderboardHeader.innerHTML = `
                        <span class="rank-header ${cls}">
                            <span class="rank-badge">${rank}</span>
                            <span class="rank-title">第${rank}名</span>
                        </span>
                    `;
                }
                leaderboardMessage.classList.remove('hidden');
                // 確保不是檢視模式
                if (modal) modal.dataset.viewingRecord = '';
                nameInputSection.classList.remove('hidden');
                // If the run actually entered the leaderboard, hide the replay button in the post-game modal
                if (replayBtn) replayBtn.classList.add('hidden');
            } else {
                if (leaderboardHeader) leaderboardHeader.innerHTML = '';
                leaderboardMessage.classList.add('hidden');
                nameInputSection.classList.add('hidden');
                // If the run did NOT enter the leaderboard, allow same-question replay from the end modal
                if (replayBtn) replayBtn.classList.remove('hidden');
            }

            // Hide the explanatory note if the same-question replay button is not available
            try {
                if (sameReplayNote) {
                    if (!replayBtn || replayBtn.classList.contains('hidden')) {
                        sameReplayNote.classList.add('hidden');
                    } else {
                        sameReplayNote.classList.remove('hidden');
                    }
                }
            } catch (e) { /* ignore */ }
            
            // Ensure modal is attached to document.body so it isn't placed inside lower stacking contexts
            if (modal && modal.parentElement !== document.body) {
                try { document.body.appendChild(modal); } catch (e) { /* ignore */ }
            }
            // Ensure modal overlay is above pinned controls (which use very high z-index on mobile)
            if (modal) {
                try { modal.style.zIndex = '11000'; } catch (e) { /* ignore */ }
            }
            modal.classList.remove('hidden');
            // lock background scroll for mobile comfort
            lockBodyScroll();
            
            // 清空輸入框
            document.getElementById('playerNameInput').value = '';
            document.getElementById('nameError').classList.add('hidden');

            // Enable Enter-to-confirm while this modal is open
            try { attachPlayerNameModalEnterHotkey(); } catch (e) {}
        }

        function lockBodyScroll() {
            // remember previous overflow
            try {
                document.body.dataset._prevOverflow = document.body.style.overflow || '';
                document.body.style.overflow = 'hidden';
                document.body.style.touchAction = 'none';
            } catch (e) {}
        }

        // Add click handlers so tapping the big score triggers a small pulse + particles
        try {
            document.addEventListener('DOMContentLoaded', () => {
                const center = document.getElementById('centerScore');
                if (center) {
                    center.style.cursor = 'pointer';
                    center.addEventListener('click', (e) => {
                        try { pulseCenterScore(50); } catch(e) {}
                        try { spawnScoreParticles(50); } catch(e) {}
                    });
                }

                const final = document.getElementById('finalScore');
                if (final) {
                    final.style.cursor = 'pointer';
                    final.addEventListener('click', (e) => {
                        try { pulseCenterScore(50); } catch(e) {}
                        // originRect: spawn near the finalScore element
                        try { spawnScoreParticles(50, final.getBoundingClientRect()); } catch(e) {}
                    });
                }

                // Also allow the main title to trigger the same effect when tapped/clicked
                const mainTitle = document.getElementById('mainTitle');
                if (mainTitle) {
                    mainTitle.style.cursor = 'pointer';
                    mainTitle.addEventListener('click', (e) => {
                        try { pulseCenterScore(50); } catch(e) {}
                        try { spawnScoreParticles(50, mainTitle.getBoundingClientRect()); } catch(e) {}
                    });
                }

                // scoring toggle for mobile: hide details but provide expand control
                try {
                    const toggleBtn = document.getElementById('toggleScoringBtn');
                    const scoringCard = document.getElementById('scoringCard');
                    if (toggleBtn && scoringCard) {
                        // show toggle only on small viewports
                        const showToggle = window.matchMedia && window.matchMedia('(max-width:420px)').matches;
                        if (showToggle) toggleBtn.style.display = 'inline-block';
                        // helper to set label text while preserving leading emoji/icon
                        const setToggleLabel = (open) => {
                            const labelSpan = toggleBtn.querySelector('span:not([aria-hidden])');
                            const text = open ? '收起計分說明' : '顯示計分說明';
                            if (labelSpan) labelSpan.textContent = text; else toggleBtn.textContent = text;
                            // update aria and chevron
                            toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
                            const chev = toggleBtn.querySelector('.chev');
                            if (chev) chev.style.transform = open ? 'rotate(180deg)' : 'none';
                            // announce state for screen readers
                            const live = document.getElementById('toggleScoringA11y');
                            if (live) live.textContent = open ? '已展開計分說明' : '已收起計分說明';
                        };
                        // initialize label based on current state
                        const initiallyOpen = scoringCard.classList.contains('scoring-open');
                        setToggleLabel(initiallyOpen);

                        toggleBtn.addEventListener('click', () => {
                            const open = scoringCard.classList.toggle('scoring-open');
                            setToggleLabel(open);
                        });
                    }
                } catch (e) { /* ignore */ }
            });
        } catch (e) { /* defensive: ignore if DOM not ready in some environments */ }

        // 全域：偵測並追蹤「減少動態效果」偏好（效能/無障礙）
        (function(){
            try {
                const mq = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
                window.__reducedMotion = !!(mq && mq.matches);
                if (mq && mq.addEventListener) {
                    mq.addEventListener('change', (e) => { window.__reducedMotion = !!e.matches; });
                }
            } catch (e) { /* ignore */ }
        })();
        function getReducedMotion() { return !!window.__reducedMotion; }

        function unlockBodyScroll() {
            try {
                document.body.style.overflow = document.body.dataset._prevOverflow || '';
                document.body.style.touchAction = '';
                delete document.body.dataset._prevOverflow;
            } catch (e) {}
        }
        
        // Attach/detach an Enter key handler that confirms and returns to main menu when the end-game modal is open
        function attachPlayerNameModalEnterHotkey() {
            try {
                const modal = document.getElementById('playerNameModal');
                if (!modal) return;
                // Remove previous handler if any
                if (modal.__enterHandler) {
                    try { document.removeEventListener('keydown', modal.__enterHandler); } catch (e) {}
                    modal.__enterHandler = null;
                }
                const handler = (ev) => {
                    if (ev && ev.key === 'Enter' && !ev.shiftKey && !ev.ctrlKey && !ev.altKey && !ev.metaKey) {
                        // Only trigger if modal is actually visible
                        if (!modal.classList.contains('hidden')) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            try { confirmPlayerName(); } catch (e) {}
                        }
                    }
                };
                modal.__enterHandler = handler;
                document.addEventListener('keydown', handler);
            } catch (e) { /* ignore */ }
        }

        function detachPlayerNameModalEnterHotkey() {
            try {
                const modal = document.getElementById('playerNameModal');
                if (!modal) return;
                const handler = modal.__enterHandler;
                if (handler) {
                    try { document.removeEventListener('keydown', handler); } catch (e) {}
                    modal.__enterHandler = null;
                }
            } catch (e) { /* ignore */ }
        }
        
        // Wrapper kept for backwards compatibility when called from game-end flow
        function generateScoreBreakdown() {
            renderScoreBreakdown(gameState, { isRecord: false });
        }
        
        function addScoreItem(container, label, calculation, score, colorClass, isTotal = false) {
            const item = document.createElement('div');
            item.className = `flex justify-between items-center ${isTotal ? 'col-span-2 border-t pt-2 mt-2' : ''}`;
            
            item.innerHTML = `
                <div class="flex flex-col">
                    <span class="${colorClass}">${label}</span>
                    ${calculation ? `<span class="text-gray-500 text-xs">${calculation}</span>` : ''}
                </div>
                <span class="${colorClass} font-bold">${score}</span>
            `;
            
            container.appendChild(item);
        }
        
        function getBonusScore() {
            let bonusScore = 0;
            
            // 計算完美和全對獎勵（scaled）
            Object.values(gameState.levelResults).forEach(result => {
                if (result === 'perfect') bonusScore += 300;
                else if (result === 'complete') bonusScore += 100;
            });
            
            // 計算提示獎勵（scaled）
            const hintCounts = { easy: 5, normal: 3, hard: 1 };
            const totalHints = hintCounts[gameState.difficulty];
            const hintsRemaining = totalHints - gameState.usedHints.size;
            bonusScore += hintsRemaining * 50;
            
            return bonusScore;
        }

        // Shared renderer used by both game-end and leaderboard record views
    function renderScoreBreakdown(source, options = {}) {
            const container = document.getElementById('scoreBreakdownContent');
            if (!container) return;
            container.innerHTML = '';

            const isRecord = !!options.isRecord;

            // normalize fields between gameState and stored record
            const correctAnswers = source.correctAnswers != null ? source.correctAnswers : (source.totalCorrectAnswers != null ? source.totalCorrectAnswers : 0);
            const totalMistakes = source.totalMistakes != null ? source.totalMistakes : 0;
            const difficulty = source.difficulty || gameState.difficulty;

                    // 基礎分數（依罕見度 / 練習固定）
            const rarity = source.rarity || gameState.rarity || null;
            const rarityLabel = '';
            const rarityBaseMap = { common: 100, rare: 125, all: 150 };
            const perQ = rarity ? (rarityBaseMap[rarity] || 100) : 100;
            const baseScore = correctAnswers * perQ;
            addScoreItem(container, '基礎分數', `${correctAnswers} × ${perQ}`, `+${baseScore}分`, 'text-blue-600');

            // 失誤扣分
            if (totalMistakes > 0) {
                const mistakeDeduction = totalMistakes * 25;
                addScoreItem(container, '失誤扣分', `${totalMistakes} × 25`, `-${mistakeDeduction}分`, 'text-red-600');
            }

            // 時間獎懲：gameState 路徑沿用原邏輯，record 則使用記錄中的 timeReward 或顯示耗時
            if (isRecord) {
                // For record view we only render time-based score adjustments if a numeric timeReward exists.
                if (source.timeReward != null) {
                    const timeScore = source.timeReward;
                    if (timeScore !== 0) {
                        const sign = timeScore > 0 ? '+' : '';
                        addScoreItem(container, '時間獎懲', '答題速度', `${sign}${timeScore}分`, timeScore > 0 ? 'text-green-600' : 'text-red-600');
                    }
                }
            } else {
                if (gameState.showTimeReward) {
                    // 修正：依規則應回加 25 × 失誤數 以消除失誤扣分的影響
                    const timeScore = gameState.score - baseScore + (totalMistakes * 25) - getBonusScore();
                    if (timeScore !== 0) {
                        const sign = timeScore > 0 ? '+' : '';
                        addScoreItem(container, '時間獎懲', '答題速度', `${sign}${timeScore}分`, timeScore > 0 ? 'text-green-600' : 'text-red-600');
                    }
                }
            }

            // 關卡獎勵
            let perfectCount = 0;
            let completeCount = 0;
            const levelResults = source.levelResults || {};
            Object.values(levelResults).forEach(r => {
                if (r === 'perfect') perfectCount++;
                else if (r === 'complete') completeCount++;
            });

            if (perfectCount > 0) addScoreItem(container, '完美獎勵', `${perfectCount} × 300`, `+${perfectCount * 300}分`, 'text-yellow-600');
            if (completeCount > 0) addScoreItem(container, '全對獎勵', `${completeCount} × 100`, `+${completeCount * 100}分`, 'text-green-600');

            // 提示獎勵
            if (isRecord) {
                if (source.hintsRemaining != null && source.totalHints != null) {
                    const hintsLeft = source.hintsRemaining || 0;
                    if (hintsLeft > 0) addScoreItem(container, '提示獎勵', `${hintsLeft} × 50`, `+${hintsLeft * 50}分`, 'text-orange-600');
                }
            } else {
                const hintCounts = { easy: 5, normal: 3, hard: 1 };
                const totalHints = hintCounts[difficulty];
                const hintsUsedCount = gameState.usedHints ? gameState.usedHints.size : 0;
                const hintsRemaining = totalHints - hintsUsedCount;
                if (hintsRemaining > 0) {
                    const hintBonus = hintsRemaining * 50;
                    addScoreItem(container, '提示獎勵', `${hintsRemaining} × 50`, `+${hintBonus}分`, 'text-orange-600');
                }
            }

            // 總分
            const totalScore = source.score != null ? source.score : (gameState.score || 0);
            addScoreItem(container, '總分', '', `${totalScore}分`, 'text-purple-700 font-bold', true);
        }

        // Backwards-compatible wrapper used when viewing a leaderboard record
        function renderScoreBreakdownFromRecord(record) {
            renderScoreBreakdown(record, { isRecord: true });
        }
        
        // Keep only one text+ref inside the closing verse container
        function sanitizeClosingVerseContainer() {
            try {
                const cv = document.getElementById('closingVerse');
                if (!cv) return;
                // Ensure exactly one text node and one ref node exist
                let textEl = cv.querySelector('#closingVerseText');
                let refEl = cv.querySelector('#closingVerseRef');
                // Create if missing
                if (!textEl) {
                    textEl = document.createElement('div');
                    textEl.id = 'closingVerseText';
                    textEl.className = 'text-lg font-bold text-gray-800 mb-1 closing-verse-clamp';
                    cv.insertAdjacentElement('afterbegin', textEl);
                }
                if (!refEl) {
                    refEl = document.createElement('div');
                    refEl.id = 'closingVerseRef';
                    refEl.className = 'text-sm text-gray-600 font-semibold';
                    refEl.style.marginTop = '4px';
                    cv.appendChild(refEl);
                }
                // Remove any other children except these two
                const keep = new Set([textEl, refEl]);
                Array.from(cv.childNodes).forEach(node => {
                    if (!keep.has(node)) cv.removeChild(node);
                });
            } catch (e) { /* ignore */ }
        }

        // Consistently apply closing verse text/ref to the modal and optionally persist to gameState
        function applyClosingVerse(text, ref, persist = false) {
            sanitizeClosingVerseContainer();
            const closingVerseText = document.getElementById('closingVerseText');
            const closingVerseRef = document.getElementById('closingVerseRef');
            const safeText = (text && String(text).trim().length) ? String(text).trim() : '感謝遊玩！';
            let safeRef = (ref && String(ref).trim().length) ? String(ref).trim() : '';
            // Normalize refs that mistakenly append the verse text (e.g., "書 章:節:「經文…")
            if (safeRef) {
                const m = safeRef.match(/^(.*?\s\d+:\d+(?:-\d+)?)/);
                if (m) safeRef = m[1];
            }
            // Avoid double-leading quotes when verse itself already starts with a quote mark
            function wrapChineseQuotes(s) {
                const str = String(s).trim();
                if (!str) return '';
                const leadingQuotes = ['「','『','“','"','”','』','』'];
                const first = str[0];
                // If the verse already begins with any quote mark, do not add outer quotes
                if (leadingQuotes.includes(first)) return str;
                return `「${str}」`;
            }
            if (closingVerseText) closingVerseText.textContent = wrapChineseQuotes(safeText);
            if (closingVerseRef) closingVerseRef.textContent = safeRef;
            if (persist) {
                try {
                    gameState.closingVerse = safeText;
                    gameState.closingVerseRef = safeRef;
                } catch (e) {}
            }
        }

        function updateClosingVerse(accuracy) {
            const closingVerseText = document.getElementById('closingVerseText');
            const closingVerseRef = document.getElementById('closingVerseRef');

            // 1) 準備允許的書卷（依玩家選擇的範圍）；僅用作偏好，不做強制
            function getAllowedBooks() {
                try {
                    if (gameState.range === 'testament') return bibleBooks[gameState.testament] || [];
                    if (gameState.range === 'custom') return Array.isArray(gameState.customBooks) ? gameState.customBooks : [];
                    // 'all' 或未設定 -> 全部
                    return [...bibleBooks.old, ...bibleBooks.new];
                } catch (e) {
                    return [...bibleBooks.old, ...bibleBooks.new];
                }
            }
            const allowedBooks = getAllowedBooks();

            // 2) 輕量歷史：盡量避免最近重複，但不強制
            function getHistory() {
                try {
                    const raw = sessionStorage.getItem('closingVerseHistory');
                    const arr = raw ? JSON.parse(raw) : [];
                    return Array.isArray(arr) ? arr : [];
                } catch (e) { return []; }
            }
            function pushHistory(refStr) {
                try {
                    if (!refStr) return;
                    const maxKeep = 10;
                    const arr = getHistory().filter(x => x && x !== refStr);
                    arr.unshift(refStr);
                    while (arr.length > maxKeep) arr.pop();
                    sessionStorage.setItem('closingVerseHistory', JSON.stringify(arr));
                } catch (e) {}
            }
            const recentHistory = getHistory();

            // 3) 文字解析工具（僅必要時使用）
            function parseRef(ref) {
                if (!ref || typeof ref !== 'string') return null;
                const i = ref.indexOf(' ');
                if (i <= 0) return { book: ref, chapter: null, verse: null };
                const book = ref.slice(0, i).trim();
                const rest = ref.slice(i + 1).trim();
                const m = rest.match(/^(\d+):(\d+)(?:-\d+)?$/);
                if (!m) return { book, chapter: null, verse: null };
                return { book, chapter: parseInt(m[1], 10), verse: parseInt(m[2], 10) };
            }

            // 4) 各表現等級對應的候選經文（沿用原來的精選名單；作為後備）
            const pools = {
                excellent: [
                    { text: "你們要靠主常常喜樂。我再說，你們要喜樂。", ref: "腓立比書 4:4" },
                    { text: "那美好的仗我已經打過了，當跑的路我已經跑盡了，所信的道我已經守住了。", ref: "提摩太後書 4:7" },
                    { text: "神能照著運行在我們心裡的大力充充足足地成就一切，超過我們所求所想的。", ref: "以弗所書 3:20" },
                    { text: "得勝的，我要賜他在我寶座上與我同坐。", ref: "啟示錄 3:21" },
                    { text: "忠心至死，我就賜給你那生命的冠冕。", ref: "啟示錄 2:10" },
                    { text: "好，你這又良善又忠心的僕人。", ref: "馬太福音 25:21" },
                    { text: "凡得勝的必這樣穿白衣，我也必不從生命冊上塗抹他的名。", ref: "啟示錄 3:5" },
                    { text: "義人的腳步被耶和華立定；他的道路，耶和華也喜愛。", ref: "詩篇 37:23" },
                    { text: "你們是世上的光。城造在山上是不能隱藏的。", ref: "馬太福音 5:14" },
                    { text: "聖靈所結的果子，就是仁愛、喜樂、和平。", ref: "加拉太書 5:22" }
                ],
                good: [
                    { text: "我靠著那加給我力量的，凡事都能做。", ref: "腓立比書 4:13" },
                    { text: "忘記背後，努力面前的，向著標竿直跑。", ref: "腓立比書 3:13-14" },
                    { text: "但那等候耶和華的必重新得力。", ref: "以賽亞書 40:31" },
                    { text: "你當剛強壯膽！不要懼怕，也不要驚惶。", ref: "約書亞記 1:9" },
                    { text: "當將你的事交託耶和華，並倚靠他，他就必成全。", ref: "詩篇 37:5" },
                    { text: "你們所遇見的試探，無非是人所能受的。", ref: "哥林多前書 10:13" },
                    { text: "我們行善，不可喪志；若不灰心，到了時候就要收成。", ref: "加拉太書 6:9" },
                    { text: "你要保守你心，勝過保守一切，因為一生的果效是由心發出。", ref: "箴言 4:23" },
                    { text: "應當一無掛慮，只要凡事藉著禱告、祈求，和感謝。", ref: "腓立比書 4:6" },
                    { text: "神所賜、出人意外的平安必在基督耶穌裡保守你們的心懷意念。", ref: "腓立比書 4:7" }
                ],
                encouraging: [
                    { text: "疲乏的，他賜能力；軟弱的，他加力量。", ref: "以賽亞書 40:29" },
                    { text: "你當剛強壯膽！不要懼怕，也不要驚惶。", ref: "約書亞記 1:9" },
                    { text: "我的恩典夠你用的，因為我的能力是在人的軟弱上顯得完全。", ref: "哥林多後書 12:9" },
                    { text: "耶和華必在你前面行；他必與你同在，必不撇下你。", ref: "申命記 31:8" },
                    { text: "你們要將一切的憂慮卸給神，因為他顧念你們。", ref: "彼得前書 5:7" },
                    { text: "神是我們的避難所，是我們的力量，是我們在患難中隨時的幫助。", ref: "詩篇 46:1" },
                    { text: "耶和華靠近傷心的人，拯救靈性痛悔的人。", ref: "詩篇 34:18" },
                    { text: "你要把你的重擔卸給耶和華，他必撫養你。", ref: "詩篇 55:22" },
                    { text: "凡勞苦擔重擔的人可以到我這裡來，我就使你們得安息。", ref: "馬太福音 11:28" },
                    { text: "在神沒有難成的事。", ref: "路加福音 1:37" }
                ],
                supportive: [
                    { text: "你們中間若有缺少智慧的，應當求那厚賜與眾人、也不斥責人的神。", ref: "雅各書 1:5" },
                    { text: "你要專心仰賴耶和華，不可倚靠自己的聰明。", ref: "箴言 3:5" },
                    { text: "你的話是我腳前的燈，是我路上的光。", ref: "詩篇 119:105" },
                    { text: "敬畏耶和華是智慧的開端；認識至聖者便是聰明。", ref: "箴言 9:10" },
                    { text: "我心裡存記你的話，免得我得罪你。", ref: "詩篇 119:11" },
                    { text: "聖經都是神所默示的，於教訓、督責、使人歸正、教導人學義都是有益的。", ref: "提摩太後書 3:16" },
                    { text: "信道是從聽道來的，聽道是從基督的話來的。", ref: "羅馬書 10:17" },
                    { text: "草必枯乾，花必凋殘，惟有我們神的話必永遠立定。", ref: "以賽亞書 40:8" },
                    { text: "天地要廢去，我的話卻不能廢去。", ref: "馬太福音 24:35" },
                    { text: "人活著，不是單靠食物，乃是靠神口裡所出的一切話。", ref: "馬太福音 4:4" }
                ]
            };

            // 5) 依 accuracy 計算等級（只用於後備池與微弱偏好）
            let tier = 'supportive';
            if (accuracy >= 90) tier = 'excellent';
            else if (accuracy >= 70) tier = 'good';
            else if (accuracy >= 50) tier = 'encouraging';

            // 6) 主要路徑：從外部經文庫挑選符合「安慰、勸勉、造就、鼓勵」原則的經文
            function pickPositiveFromDB() {
                try {
                    const db = getActiveVerseDB();
                    if (!Array.isArray(db) || db.length === 0) return null;

                    // 主題關鍵詞分類（安慰/勸勉/造就/鼓勵）
                    const THEMES = {
                        comfort: ['安慰','撫慰','醫治','醫治你','拯救我','倚靠','信靠','保守','平安','安息','避難所','靠主','靠着主','扶持','幫助','同在','不撇下','不丟棄','不離開'],
                        exhort: ['勸勉','勉勵','勸戒','警醒','持守','忍耐','自守','彼此相愛','彼此勸慰','行善','行事為人','要追求','要學','要遠避','不可懼怕','不可停止','要謹守'],
                        edify: ['造就','建造','堅固','成全','教導','教訓','智慧','真理','公義','敬虔','學義','成長','成聖','得著','得以','使你們','使我們'],
                        encourage: ['鼓勵','剛強','勇敢','壯膽','喜樂','盼望','得力','加添力量','歡呼','高興','放心','振作','不灰心','不喪膽','得勝']
                    };
                    const NEGATIVE = ['怒','發怒','懲罰','刑罰','鞭','咒詛','滅','審判','仇','仇敵','報應','毀滅','殺','砍','擊打','咒','哀號','災','災禍','有禍了','咒詛','咒罵'];

                    // 根據表現偏好主題：低分偏向安慰/鼓勵；高分偏向勸勉/造就
                    let preferredThemes = ['comfort','encourage','exhort','edify'];
                    if (accuracy >= 70) preferredThemes = ['exhort','edify','encourage','comfort'];

                    const pool = db.slice();

                    function classifyThemes(text) {
                        if (!text || typeof text !== 'string') return [];
                        const t = [];
                        const hasNeg = NEGATIVE.some(k => text.includes(k));
                        if (hasNeg) return t;
                        for (const [key, words] of Object.entries(THEMES)) {
                            if (words.some(w => text.includes(w))) t.push(key);
                        }
                        return t;
                    }

                    // 候選：需命中任一主題，且非負面；同時優先短句可讀性
                    let candidates = pool.filter(v => Array.isArray(v) ? false : true)
                        .map(v => ({ rec: v, themes: classifyThemes(v.verse) }))
                        .filter(x => x.themes.length > 0);

                    if (!candidates.length) return null;

                    // 分 rarity：常見 > 冷門（對結語可讀性友善）
                    function byRarity(list, r) { return list.filter(x => x.rec.rarity === r); }
                    let cCommon = byRarity(candidates, 'common');
                    let cRare = byRarity(candidates, 'rare');

                    // 偏好同範圍書卷
                    function preferAllowed(arr) {
                        return [...arr].sort((a,b) => {
                            const aIn = allowedBooks.includes(a.rec.book) ? 1 : 0;
                            const bIn = allowedBooks.includes(b.rec.book) ? 1 : 0;
                            if (bIn !== aIn) return bIn - aIn;
                            // 其次偏好較短的經文（更適合結語顯示）
                            const al = (a.rec.verse || '').length;
                            const bl = (b.rec.verse || '').length;
                            return al - bl;
                        });
                    }
                    cCommon = preferAllowed(cCommon);
                    cRare = preferAllowed(cRare);

                    // 依主題偏好重新過濾排序
                    function themeScore(themes) {
                        // 高權重給首選主題（index 越小越優先）
                        let score = 0;
                        for (const t of themes) {
                            const idx = preferredThemes.indexOf(t);
                            if (idx >= 0) score += (10 - idx * 3);
                        }
                        return score;
                    }

                    function pickFrom(arr) {
                        if (!arr.length) return null;
                        // 去除近期重複
                        const nonRepeat = arr.filter(x => !recentHistory.includes(`${x.rec.book} ${x.rec.chapter}`));
                        const base = nonRepeat.length ? nonRepeat : arr;
                        // 按主題分數降序、長度升序
                        const sorted = [...base].sort((a,b) => {
                            const ts = themeScore(b.themes) - themeScore(a.themes);
                            if (ts !== 0) return ts;
                            const al = (a.rec.verse || '').length;
                            const bl = (b.rec.verse || '').length;
                            return al - bl;
                        });
                        return sorted[0];
                    }

                    const picked = pickFrom(cCommon) || pickFrom(cRare);
                    if (!picked) return null;

                    const v = picked.rec;
                    return { text: v.verse, ref: `${v.book} ${v.chapter}` };
                } catch (e) { return null; }
            }

            // 7) 後備路徑：精選池（依等級），同樣先避近期重複、偏好本局書卷
            function pickFromCurated() {
                const raw = pools[tier] || [];
                if (!raw.length) return null;
                const preferred = raw.filter(v => {
                    const p = parseRef(v.ref);
                    const inBook = !p || !p.book ? true : allowedBooks.includes(p.book);
                    const notRecent = !recentHistory.includes(v.ref);
                    return inBook && notRecent;
                });
                const nonRecent = preferred.length ? preferred : raw.filter(v => !recentHistory.includes(v.ref));
                const poolToUse = nonRecent.length ? nonRecent : raw;
                return poolToUse[Math.floor(Math.random() * poolToUse.length)];
            }

            let selected = pickPositiveFromDB() || pickFromCurated();
            if (!selected) {
                // safety fallback：任取 supportive 原始精選
                const raw = pools[tier] || pools.supportive;
                selected = raw[Math.floor(Math.random() * raw.length)];
            }

            const verse = selected.text;
            const reference = selected.ref;
            applyClosingVerse(verse, reference, true);
            try { pushHistory(reference); } catch (e) {}
        }

        function confirmPlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const nameError = document.getElementById('nameError');
            const playerName = nameInput.value.trim();
            const leaderboardMessage = document.getElementById('leaderboardMessage');
            
            // 如果 modal 是檢視模式（從首頁點開），不應該允許更改名稱或再次儲存
            const modal = document.getElementById('playerNameModal');
            if (modal && modal.dataset.viewingRecord === 'true') {
                // 檢視模式：不儲存，關閉前讀取要還原的難度
                const viewingDifficulty = modal.dataset.viewingDifficulty || gameState.difficulty;
                // 清除檢視旗標（稍後還原 tab）
                modal.dataset.viewingRecord = '';
                modal.dataset.viewingDifficulty = '';
                // 關閉視窗並還原 name input 顯示
                const modalElView = document.getElementById('playerNameModal');
                if (modalElView) {
                    try { detachPlayerNameModalEnterHotkey(); } catch (e) {}
                    modalElView.classList.add('hidden');
                    try { unlockBodyScroll(); } catch(e) {}
                }
                const nameInputSectionElView = document.getElementById('nameInputSection');
                if (nameInputSectionElView) nameInputSectionElView.classList.remove('hidden');
                // 返回主畫面並更新排行榜顯示為原先檢視的難度
                showStartScreen();
                updateLeaderboardDisplay(viewingDifficulty || gameState.difficulty);
                return;
            } else {
                // 如果進入排行榜，需要驗證玩家名稱並儲存
                if (!leaderboardMessage.classList.contains('hidden')) {
                    if (!validatePlayerName(playerName)) {
                        return;
                    }
                    // 保存到排行榜（如果是以相同題目再來一局則跳過儲存）
                    savePlayerToLeaderboard(playerName, { skipSave: !!gameState.skipLeaderboardOnComplete });
                    // 使用完後重置旗標
                    gameState.skipLeaderboardOnComplete = false;
                }
            }
            
            // 關閉視窗並還原 name input 顯示
            // 非檢視模式走到這裡（正常儲存/關閉）
            const modalEl = document.getElementById('playerNameModal');
            if (modalEl) {
                try { detachPlayerNameModalEnterHotkey(); } catch (e) {}
                modalEl.classList.add('hidden');
                // ensure background scrolling is restored on mobile
                try { unlockBodyScroll(); } catch(e) {}
                // 清除可能的檢視旗標與記錄的難度
                modalEl.dataset.viewingRecord = '';
                modalEl.dataset.viewingDifficulty = '';
            }
            const nameInputSectionEl = document.getElementById('nameInputSection');
            if (nameInputSectionEl) nameInputSectionEl.classList.remove('hidden');
            
            // 返回主畫面並更新排行榜顯示
            showStartScreen();
            updateLeaderboardDisplay(gameState.difficulty);
        }

        function validatePlayerName(name) {
            const nameError = document.getElementById('nameError');
            
            // 允許留空（將顯示為匿名）
            if (!name) {
                nameError.classList.add('hidden');
                return true;
            }
            
            // 檢查長度
            if (name.length < 2) {
                nameError.textContent = '名稱至少需要2個字';
                nameError.classList.remove('hidden');
                return false;
            }
            
            if (name.length > 10) {
                nameError.textContent = '名稱不能超過10個字';
                nameError.classList.remove('hidden');
                return false;
            }
            
            // 檢查是否只包含中英文
            const validPattern = /^[a-zA-Z\u4e00-\u9fa5]+$/;
            if (!validPattern.test(name)) {
                nameError.textContent = '只能輸入中文或英文';
                nameError.classList.remove('hidden');
                return false;
            }
            
            // 簡單的不雅文字檢查
            const inappropriateWords = ['笨蛋', '白痴', '傻瓜', 'stupid', 'idiot', 'fool'];
            const lowerName = name.toLowerCase();
            for (let word of inappropriateWords) {
                if (lowerName.includes(word)) {
                    nameError.textContent = '請使用適當的名稱';
                    nameError.classList.remove('hidden');
                    return false;
                }
            }
            
            nameError.classList.add('hidden');
            return true;
        }

        // savePlayerToLeaderboard(playerName, options)
        // options = { skipSave: boolean }
        function savePlayerToLeaderboard(playerName, options = {}) {
            // 只有完成遊戲才能進入排行榜
            if (!gameState.gameCompleted && !options.allowIncomplete) {
                return;
            }
            console.log('[LEADERBOARD] savePlayerToLeaderboard called', { playerName, options, gameCompleted: gameState.gameCompleted, skipLeaderboardOnComplete: gameState.skipLeaderboardOnComplete });
            
            // If online adapter exists, delegate the persistence; otherwise use localStorage
            let allLeaderboards = null;
            if (!(window.Leaderboard && typeof window.Leaderboard.save === 'function')) {
                allLeaderboards = JSON.parse(localStorage.getItem('bibleGameLeaderboard') || '{}');
                if (!allLeaderboards.easy) allLeaderboards.easy = [];
                if (!allLeaderboards.normal) allLeaderboards.normal = [];
                if (!allLeaderboards.hard) allLeaderboards.hard = [];
            }
            
            // 計算遊戲耗時
            const gameTime = gameState.gameStartTime ? Math.floor((Date.now() - gameState.gameStartTime) / 1000) : 0;
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // 處理玩家名稱，留空則顯示為匿名
            const finalPlayerName = playerName.trim() || '匿名';
            
            // 創建遊戲記錄（包含快照）
            const gameRecord = {
                id: Date.now(),
                playerName: finalPlayerName,
                score: gameState.score,
                difficulty: gameState.difficulty,
                date: new Date().toLocaleDateString('zh-TW'),
                time: timeString,
                completed: gameState.gameCompleted,
                correctAnswers: gameState.totalCorrectAnswers,
                totalQuestions: gameState.totalQuestions,
                totalMistakes: gameState.totalMistakes,
                levelResults: { ...gameState.levelResults },
                range: gameState.range,
                rarity: gameState.rarity || null,
                mode: gameState.rarity ? 'ranking' : 'practice',
                testament: gameState.testament,
                customBooks: [...gameState.customBooks],
                // persist hint/time related transient fields so record view can exactly reproduce breakdown
                hintsRemaining: gameState.hintsRemaining != null ? gameState.hintsRemaining : null,
                // totalHints is derived from difficulty; store it for exact replay
                totalHints: (function(){ const hintCounts = { easy: 5, normal: 3, hard: 1 }; return hintCounts[gameState.difficulty] || null; })(),
                // store whether time reward was shown and explicit numeric timeReward if available
                showTimeReward: gameState.showTimeReward === true,
                timeReward: (typeof gameState.timeReward === 'number') ? gameState.timeReward : null,
                // small helper: store usedHints count to help diagnostics
                usedHintsCount: (gameState.usedHints ? gameState.usedHints.size : 0),
                // persist chosen closing verse so record view uses the same verse as game end
                closingVerse: gameState.closingVerse || null,
                closingVerseRef: gameState.closingVerseRef || null,
                questionSnapshot: (function(){ try { return JSON.parse(JSON.stringify(gameState.questionData || [])); } catch(e){ return null; } })()
            };
            
            // 若選擇跳過儲存（例如同樣題目再來一局），則不寫入排行榜
            if (options.skipSave) {
                console.log('[LEADERBOARD] options.skipSave true - not persisting record for replay run');
                return;
            }

            // Online or local save
            if (window.Leaderboard && typeof window.Leaderboard.save === 'function') {
                try {
                    window.Leaderboard.save(gameRecord).then(() => updateLeaderboardDisplay(gameState.difficulty)).catch(err => {
                        console.warn('Online leaderboard save failed; falling back to local', err);
                        try {
                            let fallback = JSON.parse(localStorage.getItem('bibleGameLeaderboard') || '{}');
                            if (!fallback.easy) fallback.easy = [];
                            if (!fallback.normal) fallback.normal = [];
                            if (!fallback.hard) fallback.hard = [];
                            fallback[gameState.difficulty].push(gameRecord);
                            fallback[gameState.difficulty].sort((a,b)=>(b.score||0)-(a.score||0));
                            fallback[gameState.difficulty] = fallback[gameState.difficulty].slice(0,5);
                            localStorage.setItem('bibleGameLeaderboard', JSON.stringify(fallback));
                            updateLeaderboardDisplay(gameState.difficulty);
                        } catch(e) {}
                    });
                } catch (e) {
                    console.warn('Online leaderboard save threw; fallback to local', e);
                }
                return;
            }

            // Local save path
            allLeaderboards[gameState.difficulty].push(gameRecord);
            allLeaderboards[gameState.difficulty].sort((a, b) => (b.score || 0) - (a.score || 0));
            allLeaderboards[gameState.difficulty] = allLeaderboards[gameState.difficulty].slice(0, 5);
            localStorage.setItem('bibleGameLeaderboard', JSON.stringify(allLeaderboards));
        }



        function animateScoreWithCounting(fromScore, toScore) {
            const scoreElement = document.getElementById('centerScore');
            const difference = toScore - fromScore;
            
            if (difference === 0) return;
            // 先取消先前尚未結束的計數動畫，避免重疊
            try {
                if (scoreElement && scoreElement.__countingInterval) {
                    clearInterval(scoreElement.__countingInterval);
                    scoreElement.__countingInterval = null;
                }
            } catch (e) {}

            // 若使用者偏好減少動態，直接跳到目標值並做極短促的視覺提示
            if (getReducedMotion()) {
                scoreElement.textContent = toScore;
                scoreElement.classList.add('counting-animation');
                setTimeout(() => scoreElement.classList.remove('counting-animation'), 40);
                return;
            }

            // 更積極的快速動畫：縮短總時長並限制更新次數以獲得更快響應
            const totalDurationMs = 450; // 動畫總時長（毫秒）——更快
            const maxSteps = 40; // 限制步數以更快完成

            let absDiff = Math.abs(difference);
            let steps = Math.min(absDiff, maxSteps);
            if (steps <= 0) steps = 1;

            // 每一步的數值變化（向上或向下取整，確保不會無限循環）
            const rawStep = difference / steps;
            const stepValue = rawStep > 0 ? Math.ceil(rawStep) : Math.floor(rawStep);

            // 更短的單步延遲以達到快速完成
            const stepDuration = Math.max(8, Math.floor(totalDurationMs / steps));

            let currentValue = fromScore;
            let stepCount = 0;

            const countingInterval = setInterval(() => {
                currentValue += stepValue;
                stepCount++;

                // 防止超越目標：若越界則直接設為目標並結束
                if ((stepValue > 0 && currentValue >= toScore) || (stepValue < 0 && currentValue <= toScore) || stepCount >= steps) {
                    clearInterval(countingInterval);
                    scoreElement.textContent = toScore;
                    scoreElement.classList.add('counting-animation');
                    setTimeout(() => scoreElement.classList.remove('counting-animation'), 60);
                    return;
                }

                scoreElement.textContent = currentValue;
                scoreElement.classList.add('counting-animation');

                setTimeout(() => {
                    scoreElement.classList.remove('counting-animation');
                }, 40);
            }, stepDuration);
            // 記錄 interval 以便下一次更新能夠中止
            try { scoreElement.__countingInterval = countingInterval; } catch (e) {}
        }

        // spawn lightweight particles near the center score; intensity scales with magnitude
        function spawnScoreParticles(delta, originRect) {
            // clamp particle count; user requested doubling the previous counts
            const abs = Math.abs(delta);
            let count = 2; // base doubled
            if (abs >= 300) count = 16; // was 8 -> doubled
            else if (abs >= 150) count = 12; // was 6
            else if (abs >= 60) count = 8; // was 4
            else if (abs >= 20) count = 6; // was 3

            // 減少動態：顯著降低數量與距離
            const reduced = getReducedMotion();
            if (reduced) {
                count = Math.min(count, 4);
            }

            // white -> platinum/gold palette
            const positiveColors = ['#ffffff', '#fff7e6', '#fff3b0', '#ffefc4'];
            const negativeColors = ['#ffffff', '#fff7e6', '#fff3b0']; // keep white present for negative as well

            const center = originRect || (function(){ const el = document.getElementById('centerScore'); try { return el.getBoundingClientRect(); } catch(e){ return null; } })();
            const cx = center ? Math.round(center.left + center.width / 2) : Math.round(window.innerWidth / 2);
            const cy = center ? Math.round(center.top + center.height / 2) : Math.round(window.innerHeight / 2);

            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'score-particle';
                // use a small star/flash glyph instead of a solid circle
                p.textContent = '✦';
                const size = 10 + Math.round(Math.random() * 12) + Math.min(26, Math.floor(Math.abs(delta) / 30));
                p.style.fontSize = size + 'px';
                p.style.width = (size + 4) + 'px';
                p.style.height = (size + 4) + 'px';
                p.style.display = 'inline-flex';
                p.style.alignItems = 'center';
                p.style.justifyContent = 'center';

                // choose color from platinum/gold family
                const colors = delta >= 0 ? positiveColors : negativeColors;
                p.style.color = colors[Math.floor(Math.random() * colors.length)];
                // transparent background to allow glyph only appearance
                p.style.background = 'transparent';

                // random direction spread; distance doubled per user request
                const angle = Math.random() * Math.PI * 2;
                const distance = reduced ? (8 + Math.random() * 16) : ((26 + Math.random() * 40) * 2); // reduced-motion: shorter
                const dx = Math.round(Math.cos(angle) * distance) + 'px';
                const dy = Math.round(Math.sin(angle) * distance) + 'px';
                p.style.setProperty('--dx', dx);
                p.style.setProperty('--dy', dy);

                p.style.left = (cx - (size + 4) / 2) + 'px';
                p.style.top = (cy - (size + 4) / 2) + 'px';

                document.body.appendChild(p);
                // remove after animation（reduced-motion: 更快清理）
                setTimeout(() => { try { if (p.parentElement) p.parentElement.removeChild(p); } catch(e) {} }, reduced ? 600 : 1500);
            }
        }

        // pulse the large center score element; scale intensity based on delta
        function pulseCenterScore(delta) {
            const el = document.getElementById('centerScore');
            if (!el) return;
            // magnitude mapping: map delta to scale multiplier
            const abs = Math.min(1000, Math.abs(delta));
            let scale = 1.06; // default small pop
            if (abs >= 300) scale = 1.28;
            else if (abs >= 150) scale = 1.20;
            else if (abs >= 60) scale = 1.12;
            else if (abs >= 20) scale = 1.08;

            // apply transform with a short ease-out
            el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1)';
            el.style.transformOrigin = 'center center';
            el.style.transform = `scale(${scale})`;
            // subtle shadow/enhance for positive deltas
            if (delta > 0) {
                el.style.textShadow = '0 4px 18px rgba(255,255,255,0.9), 0 0 40px rgba(255, 255, 220, 0.6)';
            }
            // revert back
            setTimeout(() => {
                try { el.style.transform = ''; el.style.transition = ''; el.style.textShadow = ''; } catch(e) {}
            }, 380);
        }

        // Spawn a vertical confetti rain of colorful ribbons; intensity scales with magnitude
        function spawnConfettiRain(delta, originRect) {
            try {
                const abs = Math.abs(delta || 100);
                // determine count: scaled but capped
                let base = 10;
                if (abs >= 300) base = 40;
                else if (abs >= 150) base = 30;
                else if (abs >= 60) base = 20;
                else if (abs >= 20) base = 14;
                let count = Math.min(80, base);

                // 減少動態：大幅降低數量
                if (getReducedMotion()) {
                    count = Math.min(count, 12);
                }

                const colors = ['#EF4444','#F97316','#F59E0B','#10B981','#3B82F6','#8B5CF6','#EC4899'];

                // spawn area: above the viewport or near originRect center
                const spawnCenter = originRect ? Math.round(originRect.left + originRect.width/2) : Math.round(window.innerWidth/2);
                const startY = -20; // start slightly above

                for (let i = 0; i < count; i++) {
                    const el = document.createElement('div');
                    el.className = 'confetti-piece';
                    el.style.background = colors[Math.floor(Math.random()*colors.length)];
                    // vary size and horizontal offset
                    const w = 6 + Math.floor(Math.random()*12);
                    const h = Math.max(10, w + Math.floor(Math.random()*8));
                    el.style.width = w + 'px';
                    el.style.height = h + 'px';
                    // make horizontal spread wider for lower-intensity celebrations (e.g. +100)
                    const spreadFactor = (abs <= 100) ? 0.6 : 0.45; // wider spread for small delta bursts
                    const spread = Math.round(window.innerWidth * spreadFactor);
                    const leftBase = spawnCenter - Math.round(spread / 2);
                    const left = leftBase + Math.floor(Math.random() * spread) + Math.floor((Math.random() - 0.5) * 120);
                    el.style.left = (Math.max(6, Math.min(window.innerWidth - 6, left))) + 'px';
                    el.style.top = startY + 'px';
                    // random horizontal drift applied via CSS variable
                    const drift = Math.round((Math.random()*200) - 100) + 'px';
                    el.style.setProperty('--conf-x', drift);
                    el.style.opacity = '1';
                    el.style.transform = `translateY(0)`;
                    el.style.borderRadius = (Math.random() > 0.6 ? '2px' : '6px');
                    document.body.appendChild(el);

                    // stagger removal slightly after animation end（reduced-motion: 縮短生命週期）
                    const life = getReducedMotion() ? 2800 + Math.floor(Math.random()*600) : 6400 + Math.floor(Math.random()*1600);
                    setTimeout(() => { try { if (el.parentElement) el.parentElement.removeChild(el); } catch(e) {} }, life);
                }
            } catch (e) { /* ignore visual errors */ }
        }

        // Spawn gold glitter particles: small shimmering glyphs that drift down slowly; can be continuous for a short duration
    function spawnGoldGlitter(intensity, originRect) {
            try {
                // Tapering glitter shower: run for up to 20s, spawn frequently at start and gradually reduce
        const abs = Math.abs(intensity || 300);
        const reduced = getReducedMotion();
        const totalDuration = reduced ? 6000 : 20000; // reduced-motion: shorter overall
                const startTime = Date.now();
        const maxTotal = reduced ? 80 : 400; // safety cap

                // initial and final parameters (will interpolate over time)
        const initialInterval = reduced ? 300 : 120; // ms between ticks at start
        const finalInterval = reduced ? 900 : 1200; // ms between ticks at end
        const initialGroup = reduced ? 3 : Math.min(10, Math.max(4, Math.floor((abs/50))));
        const finalGroup = 1;

                let spawned = 0;

                const spawnTick = () => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed > totalDuration || spawned >= maxTotal) return;
                    const t = Math.min(1, elapsed / totalDuration);

                    // linear interpolation helper
                    const lerp = (a,b,p) => Math.round(a + (b-a)*p);

                    const interval = lerp(initialInterval, finalInterval, t);
                    const group = Math.max(finalGroup, lerp(initialGroup, finalGroup, t));

                    // spawn 'group' stars this tick
                    for (let i = 0; i < group && spawned < maxTotal; i++) {
                        const g = document.createElement('div');
                        g.className = 'gold-glitter';
                        g.textContent = '✦'; // use a star glyph

                        // spawn across a wide horizontal area; prefer originRect center if provided
                        const spawnCenterX = originRect ? Math.round(originRect.left + originRect.width/2) : Math.round(window.innerWidth/2);
                        const spread = Math.round(window.innerWidth * 0.7); // wide spread across the sky
                        const leftBase = spawnCenterX - Math.round(spread/2);
                        const left = leftBase + Math.floor(Math.random() * spread) + Math.floor((Math.random() - 0.5) * 200);
                        const clampedLeft = Math.max(6, Math.min(window.innerWidth-6, left));

                        const spawnTop = originRect ? Math.round(originRect.top) : -40; // start above viewport for falling effect
                        const top = spawnTop + Math.round(Math.random() * 40 - 10);

                        g.style.left = clampedLeft + 'px';
                        g.style.top = top + 'px';

                        // animation duration longer for a gentle fall; vary per star
                        const dur = (reduced ? 900 : 1800) + Math.floor(Math.random() * (reduced ? 800 : 2200));
                        g.style.animationDuration = dur + 'ms';

                        // horizontal drift and slight rotation
                        const dx = Math.round((Math.random() * 220) - 110);
                        const rot = Math.round((Math.random() * 60) - 30);
                        g.style.transform = `translateX(${dx}px) rotate(${rot}deg)`;
                        g.style.opacity = '0.98';

                        document.body.appendChild(g);

                        // cleanup after animation plus a small buffer
                        setTimeout(() => { try { if (g.parentElement) g.parentElement.removeChild(g); } catch (e) {} }, dur + 400);

                        spawned++;
                    }

                    // schedule next tick with slight randomness
                    const jitter = Math.floor((Math.random() - 0.5) * (interval * 0.3));
                    setTimeout(spawnTick, Math.max(40, interval + jitter));
                };

                // kick off
                spawnTick();
            } catch (e) { /* ignore visual errors */ }
        }


        function updateGameUI() {
            // 更新關卡進度橢圓條
            try { updateLevelOvals(); } catch (e) { /* ignore */ }
            
            // 更新題目進度橢圓條
            try { updateQuestionOvals(); } catch (e) { /* ignore */ }
            
            // 更新分數顯示（使用計數動畫）
            const scoreElement = document.getElementById('centerScore');
            const currentScore = parseInt(scoreElement.textContent) || 0;
            const newScore = gameState.score;
            
            if (newScore !== currentScore) {
                animateScoreWithCounting(currentScore, newScore);
                // 向輔助工具播報分數變化
                try { const live = document.getElementById('scoreAriaLive'); if (live) live.textContent = `分數 ${newScore} 分`; } catch(e){}
            } else {
                scoreElement.textContent = gameState.score;
            }
            
            // 更新提示按鈕狀態和圖案顯示
            updateHintButton();
        }

        function updateLevelOvals() {
            const container = document.getElementById('levelOvals');
            if (!container) return;
            container.innerHTML = '';

            for (let i = 1; i <= 5; i++) {
                const oval = document.createElement('div');
                // reduced height and font to save vertical space
                oval.className = 'flex-1 h-7 rounded-full flex items-center justify-center text-xs font-semibold transition-all duration-200';

                if (i < gameState.currentLevel || (i === gameState.currentLevel && gameState.levelResults[i])) {
                    // 已完成的關卡（包括剛完成的當前關卡）
                    const levelResult = gameState.levelResults && gameState.levelResults[i];
                    if (levelResult === 'perfect') {
                        // thinner border and lighter shadow
                        oval.className += ' bg-gradient-to-br from-yellow-400 to-yellow-500 text-yellow-900 border-2 border-yellow-600 shadow-sm';
                        oval.innerHTML = '<span class="px-2">完美</span>';
                    } else if (levelResult === 'complete') {
                        oval.className += ' bg-emerald-500 text-white border-2 border-yellow-400 shadow-sm';
                        oval.innerHTML = '<span class="px-2">全對</span>';
                    } else {
                        oval.className += ' bg-green-400 text-green-900 border-2';
                        oval.innerHTML = '<span class="px-2">完成</span>';
                    }
                } else if (i === gameState.currentLevel) {
                    // 當前關卡（進行中）
                    oval.className += ' bg-purple-200 text-purple-800 animate-pulse';
                    oval.innerHTML = `<span class="px-2">🎮${i}</span>`;
                } else {
                    // 未開始的關卡
                    oval.className += ' bg-gray-200 text-gray-500 border-2';
                    oval.innerHTML = `<span class="px-2">⏳${i}</span>`;
                }

                container.appendChild(oval);
            }
        }

        function updateQuestionOvals() {
            const container = document.getElementById('questionOvals');
            if (!container) return;
            container.innerHTML = '';

            let correctCount = 0;
            let totalAnswered = 0;

            // 確保有題目數據才進行更新
            if (!gameState.questionData || gameState.questionData.length === 0) {
                document.getElementById('currentQuestion').textContent = '0/0';
                return;
            }

            for (let i = 0; i < gameState.questionData.length; i++) {
                const oval = document.createElement('div');
                // shorter ovals to reduce vertical footprint
                oval.className = 'flex-1 h-5 rounded-full flex items-center justify-center text-[11px] font-semibold transition-all duration-200';

                const verseCard = document.querySelector(`[data-index="${i}"]`);
                const maxAttempts = { easy: 3, normal: 2, hard: 1 };
                const originalAttempts = maxAttempts[gameState.difficulty];
                const currentAttempts = gameState.questionAttempts[i] || originalAttempts;

                if (verseCard && verseCard.classList.contains('bg-green-100')) {
                    // 答對了，檢查是否無失誤且未使用提示
                    if (currentAttempts === originalAttempts) {
                        const levelHintKey = `${gameState.currentLevel}|${i}`;
                        const hintUsedThisLevel = (gameState.usedHints && (gameState.usedHints.has(levelHintKey) || gameState.usedHints.has(i)));
                        if (!hintUsedThisLevel) {
                        // 無失誤且無提示完成 - 翠綠色配金邊 (smaller shadow)
                        oval.className += ' bg-emerald-500 text-white border-2 border-yellow-400 shadow-sm';
                        oval.innerHTML = '<span>✓</span>';
                        } else {
                            // used hint this level: treat as answered-with-hint
                            oval.className += ' bg-green-400 text-green-900 border-2';
                            oval.innerHTML = '<span>✓</span>';
                        }
                    } else {
                        // 有失誤 - 普通綠色
                        oval.className += ' bg-green-400 text-green-900 border-2';
                        oval.innerHTML = '<span>✓</span>';
                    }
                    correctCount++;
                    totalAnswered++;
                } else if (verseCard && verseCard.classList.contains('bg-red-100')) {
                    // 答錯
                    oval.className += ' bg-red-400 text-red-900 border-2';
                    oval.innerHTML = '<span>✗</span>';
                    totalAnswered++;
                } else if (verseCard && (verseCard.classList.contains('bg-yellow-100') || verseCard.classList.contains('bg-orange-100'))) {
                    // 已經嘗試過但還未完成 - 黃色
                    oval.className += ' bg-yellow-400 text-yellow-900 border-2';
                    oval.innerHTML = '<span>!</span>';
                } else {
                    // 未開始
                    oval.className += ' bg-gray-200 text-gray-500 border-2';
                    oval.innerHTML = '<span>?</span>';
                }

                container.appendChild(oval);
            }

            // 更新數字顯示
            const cq = document.getElementById('currentQuestion');
            if (cq) cq.textContent = `${totalAnswered}/${gameState.questionData.length}`;
        }

        function updateHintButton() {
            const hintBtn = document.getElementById('hintBtn');
            const hintCount = document.getElementById('hintCount');
            
            // 更新提示次數顯示
            if (hintCount) {
                hintCount.textContent = `⭐×${gameState.hintsRemaining}`;
                
                // 根據剩餘次數改變顏色
                if (gameState.hintsRemaining <= 0) {
                    hintCount.className = 'text-sm font-bold text-gray-400 ml-3';
                } else if (gameState.hintsRemaining <= 1) {
                    hintCount.className = 'text-sm font-bold text-red-600 ml-3';
                } else if (gameState.hintsRemaining <= 2) {
                    hintCount.className = 'text-sm font-bold text-orange-600 ml-3';
                } else {
                    hintCount.className = 'text-sm font-bold text-blue-600 ml-3';
                }
            }
            
            // 更新按鈕狀態
            if (gameState.hintsRemaining <= 0) {
                hintBtn.classList.add('opacity-50', 'cursor-not-allowed');
                hintBtn.disabled = true;
            } else {
                hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                hintBtn.disabled = false;
            }
        }



        function saveScore(score) {
            // 計算遊戲耗時（從開始到完成最後一關，不包括結算視窗時間）
            const endTime = gameState.gameEndTime || Date.now();
            const gameTime = gameState.gameStartTime ? Math.floor((endTime - gameState.gameStartTime) / 1000) : 0;
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // 創建遊戲記錄
            const gameRecord = {
                id: Date.now(), // 唯一ID
                score: score,
                difficulty: gameState.difficulty,
                date: new Date().toLocaleDateString('zh-TW'),
                time: timeString,
                completed: gameState.gameCompleted,
                correctAnswers: gameState.totalCorrectAnswers,
                totalQuestions: gameState.totalQuestions,
                totalMistakes: gameState.totalMistakes,
                levelResults: { ...gameState.levelResults },
                range: gameState.range,
                testament: gameState.testament,
                customBooks: [...gameState.customBooks],
                // include closing verse chosen at game end so record view shows identical verse
                closingVerse: gameState.closingVerse || null,
                closingVerseRef: gameState.closingVerseRef || null,
                // persist transient fields to allow exact replay of breakdown
                hintsRemaining: gameState.hintsRemaining != null ? gameState.hintsRemaining : null,
                totalHints: (function(){ const hintCounts = { easy: 5, normal: 3, hard: 1 }; return hintCounts[gameState.difficulty] || null; })(),
                showTimeReward: gameState.showTimeReward === true,
                timeReward: (typeof gameState.timeReward === 'number') ? gameState.timeReward : null,
                usedHintsCount: (gameState.usedHints ? gameState.usedHints.size : 0)
            };
            // 儲存題組快照（最小必要資訊以便重播）
            try {
                gameRecord.questionSnapshot = {
                    questionData: JSON.parse(JSON.stringify(gameState.questionData || [])),
                    levelResults: { ...gameState.levelResults },
                    totalQuestions: gameState.totalQuestions
                };
            } catch (e) {
                gameRecord.questionSnapshot = null;
            }
            
            return gameRecord;
        }

        function loadLeaderboard() {
            // If online leaderboard is configured, this function becomes a thin wrapper to fetch
            // and map results into the same structure { easy:[], normal:[], hard:[] }.
            if (window.Leaderboard && typeof window.Leaderboard.load === 'function') {
                console.log('[LEADERBOARD] using online leaderboard load');
                return window.Leaderboard.load();
            }

            const stored = JSON.parse(localStorage.getItem('bibleGameLeaderboard') || '{}');
            
            // 如果是舊格式（陣列），轉換為新格式
            if (Array.isArray(stored)) {
                const newFormat = { easy: [], normal: [], hard: [] };
                stored.forEach(record => {
                    if (record.difficulty && newFormat[record.difficulty]) {
                        newFormat[record.difficulty].push({
                            score: record.score,
                            date: record.date
                        });
                    }
                });
                // 每個難度保留前5名（升級）
                Object.keys(newFormat).forEach(difficulty => {
                    newFormat[difficulty].sort((a, b) => b.score - a.score);
                    newFormat[difficulty] = newFormat[difficulty].slice(0, 5);
                });
                localStorage.setItem('bibleGameLeaderboard', JSON.stringify(newFormat));
                return newFormat;
            }
            
            // 確保每個難度都存在，並限制為最多 5 筆
            if (!stored.easy) stored.easy = [];
            if (!stored.normal) stored.normal = [];
            if (!stored.hard) stored.hard = [];
            Object.keys(stored).forEach(k => {
                if (Array.isArray(stored[k])) {
                    stored[k].sort((a, b) => (b.score || 0) - (a.score || 0));
                    stored[k] = stored[k].slice(0, 5);
                }
            });
            // Backfill/estimate transient fields for older records that predate these properties.
            // We keep the estimate conservative and attach a flag so consumers can detect it.
            try {
                Object.keys(stored).forEach(k => {
                    if (!Array.isArray(stored[k])) return;
                    stored[k].forEach(record => {
                        // If a record already has explicit timeReward, skip
                        if (record.timeReward != null) return;

                        // Need minimal fields to attempt an estimate
                        const correctAnswers = record.correctAnswers != null ? record.correctAnswers : (record.totalCorrectAnswers != null ? record.totalCorrectAnswers : null);
                        const totalMistakes = record.totalMistakes != null ? record.totalMistakes : 0;
                        const levelResults = record.levelResults || {};

                        if (correctAnswers == null || record.score == null) {
                            // insufficient data to estimate
                            return;
                        }

                        // compute base score and level bonuses using the same rules as renderer
                        const baseScore = correctAnswers * 100;
                        let bonusScore = 0;
                        Object.values(levelResults).forEach(r => {
                            if (r === 'perfect') bonusScore += 300;
                            else if (r === 'complete') bonusScore += 100;
                        });

                        // estimate hint bonus when possible
                        let hintBonus = 0;
                        if (record.hintsRemaining != null && record.totalHints != null) {
                            hintBonus = (record.hintsRemaining || 0) * 50;
                        } else if (record.totalHints != null && record.usedHintsCount != null) {
                            const hintsLeft = Math.max(0, (record.totalHints || 0) - (record.usedHintsCount || 0));
                            hintBonus = hintsLeft * 50;
                        }
                        bonusScore += hintBonus;

                        // 與結算視圖一致：回加 20 × 失誤數
                        const estimatedTimeReward = (record.score || 0) - baseScore + (totalMistakes * 25) - bonusScore;
                        record.timeReward = estimatedTimeReward;
                        record.timeRewardEstimated = true;
                    });
                });
            } catch (e) { /* non-fatal */ }

            // Backfill deterministic closingVerse for legacy records missing it so repeated opens are stable.
            try {
                // verse pools mirrored from updateClosingVerse logic
                const versePools = {
                    excellent: [
                        { text: "你們要靠主常常喜樂。我再說，你們要喜樂。", ref: "腓立比書 4:4" },
                        { text: "那美好的仗我已經打過了，當跑的路我已經跑盡了，所信的道我已經守住了。", ref: "提摩太後書 4:7" },
                        { text: "神能照著運行在我們心裡的大力充充足足地成就一切，超過我們所求所想的。", ref: "以弗所書 3:20" },
                        { text: "得勝的，我要賜他在我寶座上與我同坐。", ref: "啟示錄 3:21" },
                        { text: "忠心至死，我就賜給你那生命的冠冕。", ref: "啟示錄 2:10" },
                        { text: "好，你這又良善又忠心的僕人。", ref: "馬太福音 25:21" },
                        { text: "凡得勝的必這樣穿白衣，我也必不從生命冊上塗抹他的名。", ref: "啟示錄 3:5" },
                        { text: "義人的腳步被耶和華立定；他的道路，耶和華也喜愛。", ref: "詩篇 37:23" },
                        { text: "你們是世上的光。城造在山上是不能隱藏的。", ref: "馬太福音 5:14" },
                        { text: "聖靈所結的果子，就是仁愛、喜樂、和平。", ref: "加拉太書 5:22" }
                    ],
                    good: [
                        { text: "我靠著那加給我力量的，凡事都能做。", ref: "腓立比書 4:13" },
                        { text: "你當剛強壯膽，不要懼怕，也不要驚惶。", ref: "申命記 31:6" },
                        { text: "所信的道我已經守住了。", ref: "提摩太後書 4:7" },
                        { text: "神是我們的避難所和力量。", ref: "詩篇 46:1" }
                    ],
                    encouraging: [
                        { text: "不要失望，要堅固禱告。", ref: "帖撒羅尼迦前書 5:17" },
                        { text: "倚靠耶和華的人有福了。", ref: "詩篇 40:4" },
                        { text: "凡事藉著禱告和祈求，帶著感謝，將你們所要的告訴神。", ref: "腓立比書 4:6" }
                    ],
                    supportive: [
                        { text: "耶和華是我的牧者，我必不致缺乏。", ref: "詩篇 23:1" },
                        { text: "你要剛強壯膽，不可懼怕。", ref: "約書亞記 1:9" },
                        { text: "凡事互相寬容，彼此相愛。", ref: "以弗所書 4:2" }
                    ]
                };

                function simpleHash(str) {
                    let h = 0;
                    for (let i = 0; i < str.length; i++) {
                        h = ((h << 5) - h) + str.charCodeAt(i);
                        h |= 0;
                    }
                    return Math.abs(h);
                }

                Object.keys(stored).forEach(k => {
                    if (!Array.isArray(stored[k])) return;
                    stored[k].forEach(record => {
                        if (record.closingVerse != null || record.closingVerseRef != null) return;
                        // compute approximate accuracy if possible
                        const correct = record.correctAnswers != null ? record.correctAnswers : (record.totalCorrectAnswers != null ? record.totalCorrectAnswers : null);
                        const totalQ = record.totalQuestions != null ? record.totalQuestions : null;
                        if (correct == null || totalQ == null || totalQ === 0) return; // insufficient data
                        const acc = Math.round((correct / totalQ) * 100);

                        let pool = versePools.supportive;
                        if (acc >= 90) pool = versePools.excellent;
                        else if (acc >= 70) pool = versePools.good;
                        else if (acc >= 50) pool = versePools.encouraging;

                        const idxSeed = (record.id != null) ? String(record.id) : String(record.score || '') + String(record.date || '');
                        const idx = simpleHash(idxSeed) % pool.length;
                        record.closingVerse = pool[idx].text;
                        record.closingVerseRef = pool[idx].ref;
                        record.closingVerseEstimated = true;
                    });
                });

                // persist our backfilled fields so future loads are stable
                try {
                    localStorage.setItem('bibleGameLeaderboard', JSON.stringify(stored));
                } catch (e) { /* ignore persistence failures */ }
            } catch (e) { /* non-fatal */ }

            return stored;
        }



        async function updateLeaderboardDisplay(selectedDifficulty = 'easy') {
            // Support async load for online mode
            const allLeaderboards = await (async () => {
                const res = loadLeaderboard();
                if (res && typeof res.then === 'function') {
                    try { return await res; } catch(e) { console.warn('online leaderboard load failed; falling back', e); }
                }
                return res;
            })();
            const container = document.getElementById('leaderboardList');
            
            // 獲取指定難度的排行榜
            const difficultyLeaderboard = allLeaderboards[selectedDifficulty] || [];
            
            container.innerHTML = '';
            
            // 創建五個欄位（橫向排列）
            for (let i = 0; i < 5; i++) {
                const column = document.createElement('div');
                column.className = 'text-center';
                
                if (i < difficultyLeaderboard.length) {
                    const record = difficultyLeaderboard[i];
                    const rankNumber = i + 1;

                    // 顯示玩家名稱
                    const playerName = record.playerName || '匿名';

                    // 罕見度標籤資料
                    const rarity = record.rarity || null;
                    const rarityLabelMap = { common: '常見', rare: '冷門', all: '全部' };
                    const rarityBgMap = {
                        common: '#D1FAE5', // emerald-100
                        rare: '#EDE9FE',  // violet-100
                        all: '#E5E7EB'    // gray-200
                    };
                    const rarityTextMap = {
                        common: '#065F46', // emerald-800
                        rare: '#5B21B6',   // violet-800
                        all: '#374151'     // gray-700
                    };
                    const rarityLabel = rarity ? (rarityLabelMap[rarity] || '未知') : null;
                    const rarityBg = rarity ? (rarityBgMap[rarity] || '#E5E7EB') : '#E5E7EB';
                    const rarityText = rarity ? (rarityTextMap[rarity] || '#374151') : '#374151';

                    // rank CSS class + medal icon
                    const rankClass = (rankNumber === 1) ? 'rank-1' : (rankNumber === 2) ? 'rank-2' : (rankNumber === 3) ? 'rank-3' : 'rank-default';
                    const medal = (rankNumber === 1) ? '🥇' : (rankNumber === 2) ? '🥈' : (rankNumber === 3) ? '🥉' : '';

                    const aria = `第${rankNumber}名，${playerName}，${record.score}分`;

                    column.innerHTML = `
                        <div class="leaderboard-card ${rankClass}" data-record-id="${record.id}" title="${playerName}" role="button" aria-label="${aria}">
                            <div class="lb-rank-ribbon"><span>${rankNumber}</span></div>
                            ${medal ? `<div class="lb-medal" aria-hidden="true">${medal}</div>` : ''}
                            <div class="lb-card-body text-left">
                                <div class="lb-top-row">
                                    <div class="lb-score">${record.score}<span class="unit">分</span></div>
                                    <div class="lb-name flex-1 min-w-0"><span class="truncate" title="${playerName}">${playerName}</span></div>
                                </div>
                                <div class="lb-meta">${record.date || ''}${record.time ? ' · ' + record.time : ''}${record.elapsed ? ' · ' + record.elapsed : ''}</div>
                                ${rarityLabel ? `<div class="mt-1">
                                    <span class="lb-pill" style="background-color: ${rarityBg}; color: ${rarityText};">經文範圍：${rarityLabel}</span>
                                </div>` : ''}
                            </div>
                        </div>
                    `;

                } else {
                    // 空位置 - 僅保留「暫無記錄」文字
                    column.innerHTML = `
                        <div class="leaderboard-card rank-default" aria-hidden="true">
                            <div class="lb-rank-ribbon"><span>-</span></div>
                            <div class="lb-card-body text-center" style="min-height: 3.2rem; display: flex; align-items: center; justify-content: center;">
                                <div class="text-sm font-semibold text-gray-400">暫無記錄</div>
                            </div>
                        </div>
                    `;
                }
                
                container.appendChild(column);
            }
            
            // Click handler: 點擊任何排行榜卡片會打開結算視窗以回顧該場記錄
            container.querySelectorAll('[data-record-id]').forEach(el => {
                el.style.cursor = 'pointer';
                el.addEventListener('click', (e) => {
                    const id = el.getAttribute('data-record-id');
                    openLeaderboardRecordById(id, selectedDifficulty);
                });
            });
        }







        // 單次初始化旗標，避免重建造成閃爍
        window.__marqueeInitialized = window.__marqueeInitialized || false;

        function initializeVerseMarquee() {
            const marqueeContainer = document.getElementById('verseMarquee');
            if (!marqueeContainer) return;
            if (window.__marqueeInitialized) return; // 防止重複初始化

            // 構建期間暫時隱藏，避免首度渲染閃爍
            const prevVisibility = marqueeContainer.style.visibility;
            marqueeContainer.style.visibility = 'hidden';
            marqueeContainer.innerHTML = '';

            // 生成更多行以提升密度（使用 34 行）
            const totalLines = 34;
            const __activeDB = getActiveVerseDB();
            const __commonPool = Array.isArray(__activeDB) ? __activeDB.filter(v => v && v.rarity === 'common') : [];
            // 跑馬燈一律使用常見經文；若暫無常見經文則暫不渲染，等待資料到齊再刷新
            if (!__commonPool || __commonPool.length === 0) {
                marqueeContainer.style.visibility = prevVisibility || '';
                return;
            }
            const shuffledVerses = [...__commonPool].sort(() => Math.random() - 0.5);
            const selectedVerses = shuffledVerses.slice(0, totalLines).map(v => v.verse);

            // 若使用者偏好減少動態，直接渲染靜態多行文字並退出
            if (getReducedMotion && getReducedMotion()) {
                const frag = document.createDocumentFragment();
                for (let i = 0; i < Math.min(totalLines, selectedVerses.length); i++) {
                    const verseElement = document.createElement('div');
                    verseElement.className = 'verse-text';
                    verseElement.style.animation = 'none';
                    verseElement.style.position = 'relative';
                    verseElement.style.top = 'auto';
                    verseElement.style.left = 'auto';
                    verseElement.style.transform = 'none';
                    verseElement.style.opacity = '0.65';
                    verseElement.style.filter = 'none';
                    verseElement.style.fontSize = '1rem';
                    verseElement.style.textShadow = 'none';
                    verseElement.style.margin = '2px 0';
                    verseElement.textContent = selectedVerses[i] || '';
                    frag.appendChild(verseElement);
                }
                marqueeContainer.appendChild(frag);
                marqueeContainer.style.visibility = prevVisibility || '';
                window.__marqueeInitialized = true;
                return;
            }

            // 預設的字體大小基準值（以 rem 為單位）。接著我們會把最小放大 0.5x、最大放大 2x，並線性映射保留分佈。
            const baseFontSizes = [2.6,3.2,3.6,4.2,3.4,4.6,3.9,4.0,3.3,4.8,3.7,2.9,3.0,4.4,3.5,5.2,6.5];
            const baseMin = Math.min(...baseFontSizes);
            const baseMax = Math.max(...baseFontSizes);
            const newMin = baseMin * 0.5; // 最小值 x0.5
            const newMax = baseMax * 2;   // 最大值 x2
            // 線性映射函數，保持原始分佈比例
            const scaledFontSizes = baseFontSizes.map(s => {
                if (baseMax === baseMin) return newMin;
                const t = (s - baseMin) / (baseMax - baseMin);
                return (newMin + t * (newMax - newMin));
            });

            // 三個速度群組（秒）：快速 / 中速 / 慢速
            const speedGroups = [18, 30, 45];
            const maxDuration = Math.max(...speedGroups);

            // richer color pool (主色 + glow)，循環使用
            const colorPool = [
                { c: '255,99,132',   a: 0.14 }, // pink-red
                { c: '255,159,64',   a: 0.12 }, // orange
                { c: '255,205,86',   a: 0.10 }, // yellow
                { c: '75,192,192',   a: 0.10 }, // teal
                { c: '54,162,235',   a: 0.11 }, // blue
                { c: '153,102,255',  a: 0.12 }, // purple
                { c: '201,203,207',  a: 0.08 }, // gray
                { c: '99,102,241',   a: 0.11 }, // indigo
                { c: '16,185,129',   a: 0.10 }, // green
                { c: '236,72,153',   a: 0.12 }  // fuchsia
            ];

            const frag = document.createDocumentFragment();
            for (let i = 0; i < totalLines; i++) {
                const verseElement = document.createElement('div');
                verseElement.className = 'verse-text';

                // For each line, pick 3 random verses to rotate through on each full marquee cycle
                const picks = [];
                const activeDB = getActiveVerseDB();
                const pool = Array.isArray(activeDB) ? activeDB.filter(v => v && v.rarity === 'common') : [];
                for (let p = 0; p < 3; p++) {
                    const v = pool[Math.floor(Math.random() * pool.length)];
                    picks.push(v ? (v.verse || '') : '');
                }
                // ensure we have at least one fallback
                if (picks.length === 0) picks.push(selectedVerses[i] || '');
                verseElement.textContent = picks[0] || '';
                // attach list and index for iteration handler
                verseElement.__marqueeList = picks;
                verseElement.__marqueeIdx = 0;
                // on each completed animation loop, switch to the next verse in this line's list
                verseElement.addEventListener('animationiteration', function() {
                    try {
                        this.__marqueeIdx = (this.__marqueeIdx + 1) % (this.__marqueeList ? this.__marqueeList.length : 1);
                        const next = (this.__marqueeList && this.__marqueeList[this.__marqueeIdx]) || '';
                        this.textContent = next;
                    } catch (e) { /* ignore */ }
                });

                // 垂直位置以百分比計算，平均分布並保持在視窗外開始/結束
                // 中心偏移控制讓行分布更加均勻
                const centerOffset = -30; // 起始偏移
                const step = 6; // 每行間距百分比（行距已在 CSS 中調整）
                const vpos = Math.round(centerOffset + i * step);
                verseElement.style.top = `${vpos}%`;

                // 固定 line-height（見 CSS），僅改變 font-size
                const chosenSizeValue = scaledFontSizes[i % scaledFontSizes.length];
                const chosenSize = `${chosenSizeValue}rem`;
                verseElement.style.fontSize = chosenSize;

                // 分配速度群組：循環分配以在視覺上產生深度
                const duration = speedGroups[i % speedGroups.length];
                verseElement.style.animationDuration = `${duration}s`;
                verseElement.style.animation = `marquee-horizontal ${duration}s linear infinite`;

                // 依據字體大小計算深度感（越大視為越靠前）
                const depthNormalized = (chosenSizeValue - newMin) / (newMax - newMin); // 0..1
                const zIndex = 10 + Math.round(depthNormalized * 90); // 10..100
                verseElement.style.zIndex = zIndex;

                // 依深度調整模糊（遠處較模糊）與透明度
                const maxBlur = 3.0; // px
                const blurPx = Math.round((1 - depthNormalized) * maxBlur * 10) / 10; // 0..maxBlur
                verseElement.style.filter = `blur(${blurPx}px)`;

                // 顏色與發光：根據索引選用 colorPool，並以速度群組與深度增加層次
                const colorEntry = colorPool[i % colorPool.length];
                const baseAlpha = colorEntry.a;
                const speedIndex = i % speedGroups.length; // 0 fast,1 mid,2 slow
                // 深度會讓近處更飽滿、遠處較淡
                const depthFactor = 0.8 + depthNormalized * 1.2; // 0.8..2.0
                const finalAlpha = Math.max(0.04, Math.min(0.30, baseAlpha * depthFactor * (1 - speedIndex * 0.08)));
                verseElement.style.color = `rgba(${colorEntry.c}, ${finalAlpha})`;

                // text-shadow 作為 glow，近處給較強光暈，遠處較弱；慢速群組更強
                const glowBase = 12 + Math.round((10 + speedIndex * 8) * (0.6 + depthNormalized * 1.2));
                const glowAlpha = Math.min(0.45, 0.10 + speedIndex * 0.06 + depthNormalized * 0.12 + (i % 5) * 0.01);
                verseElement.style.textShadow = `0 0 ${glowBase}px rgba(${colorEntry.c}, ${glowAlpha}), 0 2px ${Math.round(glowBase/3)}px rgba(0,0,0,0.06)`;

                // 透明度整體表現結合深度與速度（近處與慢速看起來更清晰）
                const baseOpacity = 0.55 + depthNormalized * 0.45; // 0.55..1.0
                verseElement.style.opacity = `${Math.max(0.18, Math.min(1, baseOpacity - speedIndex * 0.10))}`;

                // 使用最大持續時間來計算延遲步進以避免短速組合時同時出現
                const delayStep = maxDuration / totalLines;
                verseElement.style.animationDelay = `${i * -delayStep}s`;

                frag.appendChild(verseElement);
            }
            marqueeContainer.appendChild(frag);
            marqueeContainer.style.visibility = prevVisibility || '';
            window.__marqueeInitialized = true;
        }

        // 若外部資料於初始化後才抵達，更新每行的輪播備選內容，避免重建造成閃爍
        function refreshVerseMarqueeData() {
            try {
    const marqueeContainer = document.getElementById('verseMarquee');
    const activeDB = getActiveVerseDB();
    const pool = Array.isArray(activeDB) ? activeDB.filter(v => v && v.rarity === 'common') : [];
    if (!marqueeContainer || !Array.isArray(pool) || pool.length === 0) return;
                const lines = marqueeContainer.querySelectorAll('.verse-text');
                lines.forEach(line => {
                    const picks = [];
                    for (let p = 0; p < 3; p++) {
            const v = pool[Math.floor(Math.random() * pool.length)];
                        picks.push(v ? (v.verse || '') : '');
                    }
                    line.__marqueeList = picks;
                    // reduced-motion 靜態模式：即時更新顯示文字
                    if (getReducedMotion && getReducedMotion()) {
                        line.textContent = picks[0] || '';
                    }
                });
            } catch (e) { /* ignore */ }
        }

        // Online Leaderboard Adapter (Supabase) — optional
        // Provide a global window.Leaderboard with methods: load(), save(record), clear()
        // Requires a config file bible-challenge/leaderboard-config.js that defines window.SUPABASE_CONFIG = { url, anonKey, table }
        ;(function initOnlineLeaderboard(){
            try {
                const cfg = (window && window.SUPABASE_CONFIG) || null;
                if (!cfg || !cfg.url || !cfg.anonKey) return; // not configured
                if (!(window.supabase && typeof window.supabase.createClient === 'function')) return; // client not loaded

                const client = window.supabase.createClient(cfg.url, cfg.anonKey, cfg.options || {});
                const table = cfg.table || 'scores';

                function toPublicRecord(row){
                    if (!row) return null;
                    // Map DB row into app record shape
                    return {
                        id: row.id || row.created_at || row.rowid || Date.now(),
                        playerName: row.player_name || row.playerName || '匿名',
                        score: row.score || 0,
                        difficulty: row.difficulty || 'easy',
                        date: row.date || (row.created_at ? new Date(row.created_at).toLocaleDateString('zh-TW') : ''),
                        time: row.time || '',
                        completed: row.completed ?? true,
                        correctAnswers: row.correct_answers ?? row.correctAnswers ?? null,
                        totalQuestions: row.total_questions ?? row.totalQuestions ?? null,
                        totalMistakes: row.total_mistakes ?? row.totalMistakes ?? null,
                        levelResults: row.level_results ?? row.levelResults ?? {},
                        range: row.range || 'all',
                        rarity: row.rarity || null,
                        mode: row.mode || 'ranking',
                        testament: row.testament || 'both',
                        customBooks: row.custom_books || [],
                        hintsRemaining: row.hints_remaining ?? null,
                        totalHints: row.total_hints ?? null,
                        showTimeReward: row.show_time_reward ?? false,
                        timeReward: row.time_reward ?? null,
                        usedHintsCount: row.used_hints_count ?? null,
                        closingVerse: row.closing_verse ?? null,
                        closingVerseRef: row.closing_verse_ref ?? null,
                        questionSnapshot: row.question_snapshot ?? null
                    };
                }

                async function load(){
                    try {
                        // Fetch top 5 per difficulty sorted by score desc, then created_at asc for tie-break
                        const difficulties = ['easy','normal','hard'];
                        const out = { easy: [], normal: [], hard: [] };
                        for (const d of difficulties) {
                            const { data, error } = await client
                                .from(table)
                                .select('*')
                                .eq('difficulty', d)
                                .order('score', { ascending: false })
                                .order('created_at', { ascending: true })
                                .limit(5);
                            if (error) throw error;
                            out[d] = (data || []).map(toPublicRecord);
                        }
                        return out;
                    } catch (e) {
                        console.warn('[LEADERBOARD] online load error', e);
                        // fallback to local if available
                        try { return JSON.parse(localStorage.getItem('bibleGameLeaderboard') || '{}'); } catch(_) { return { easy:[], normal:[], hard:[] }; }
                    }
                }

                async function save(record){
                    try {
                        // Persist minimal fields + useful metadata. Avoid overly large questionSnapshot by default; keep if config allows.
                        const keepSnapshot = !!cfg.storeSnapshot;
                        const row = {
                            player_name: record.playerName || '匿名',
                            score: record.score || 0,
                            difficulty: record.difficulty || 'easy',
                            date: record.date || new Date().toLocaleDateString('zh-TW'),
                            time: record.time || '',
                            completed: record.completed !== false,
                            correct_answers: record.correctAnswers ?? null,
                            total_questions: record.totalQuestions ?? null,
                            total_mistakes: record.totalMistakes ?? null,
                            level_results: record.levelResults || {},
                            range: record.range || 'all',
                            rarity: record.rarity || null,
                            mode: record.mode || 'ranking',
                            testament: record.testament || 'both',
                            custom_books: record.customBooks || [],
                            hints_remaining: record.hintsRemaining ?? null,
                            total_hints: record.totalHints ?? null,
                            show_time_reward: record.showTimeReward === true,
                            time_reward: record.timeReward ?? null,
                            used_hints_count: record.usedHintsCount ?? null,
                            closing_verse: record.closingVerse ?? null,
                            closing_verse_ref: record.closingVerseRef ?? null,
                            question_snapshot: keepSnapshot ? (record.questionSnapshot || null) : null,
                            project_tag: cfg.projectTag || null
                        };
                        const { error } = await client.from(table).insert(row);
                        if (error) throw error;
                    } catch (e) {
                        console.warn('[LEADERBOARD] online save error', e);
                        throw e;
                    }
                }

                async function clear(){
                    try {
                        // Danger: wipe all rows. Optionally scope by project tag if configured
                        if (cfg.projectTag) {
                            const { error } = await client.from(table).delete().eq('project_tag', cfg.projectTag);
                            if (error) throw error;
                        } else {
                            const { error } = await client.from(table).delete().neq('id', null);
                            if (error) throw error;
                        }
                    } catch (e) {
                        console.warn('[LEADERBOARD] online clear error', e);
                        throw e;
                    }
                }

                window.Leaderboard = { load, save, clear };
                console.log('[LEADERBOARD] online adapter enabled');
            } catch (e) {
                // no-op if not configured
            }
        })();
            // Small init: scoring toggle for mobile to hide/show scoring body and remarks together
            document.addEventListener('DOMContentLoaded', function() {
                try {
                    var toggleBtn = document.getElementById('toggleScoringBtn');
                    var scoringCard = document.getElementById('scoringCard');
                    var scoringBody = document.getElementById('scoringBody');
                    if (toggleBtn && scoringCard && scoringBody) {
                        var expanded = scoringCard.classList.contains('scoring-open');
                        toggleBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                        toggleBtn.textContent = expanded ? '隱藏計分說明' : '顯示計分說明';
                        toggleBtn.addEventListener('click', function() {
                            expanded = !expanded;
                            scoringCard.classList.toggle('scoring-open', expanded);
                            toggleBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                            toggleBtn.textContent = expanded ? '隱藏計分說明' : '顯示計分說明';
                        });
                    }
                } catch (e) {
                    console.warn('scoring toggle init failed', e);
                }

                // 無障礙：對話框焦點管理與 Esc 關閉
                try {
                    const modals = ['confirmBackModal','playerNameModal'];
                    const focusableSel = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex]';
                    modals.forEach(id => {
                        const modal = document.getElementById(id);
                        if (!modal) return;
                        // 開啟時設定 aria-hidden、聚焦到標題或第一個可聚焦元素
                        const open = () => {
                            modal.setAttribute('aria-hidden','false');
                            const title = modal.querySelector('#'+(id==='confirmBackModal'?'confirmBackTitle':'playerNameModalTitle'));
                            const focusables = modal.querySelectorAll(focusableSel);
                            const first = focusables && focusables[0];
                            setTimeout(() => { (title || first || modal).focus({preventScroll:true}); }, 0);
                        };
                        const close = () => {
                            modal.setAttribute('aria-hidden','true');
                        };
                        // 觀察 hidden class 切換以呼叫 open/close
                        const obs = new MutationObserver(() => {
                            const hidden = modal.classList.contains('hidden');
                            if (!hidden) open(); else close();
                        });
                        obs.observe(modal, { attributes:true, attributeFilter:['class'] });

                        // Esc 關閉（playerNameModal 僅在非查看模式可關閉）
                        modal.addEventListener('keydown', (e) => {
                            if (e.key === 'Escape') {
                                if (id === 'confirmBackModal') {
                                    document.getElementById('cancelBackBtn')?.click();
                                } else if (id === 'playerNameModal') {
                                    const viewing = modal.dataset.viewingRecord === 'true';
                                    if (!viewing) document.getElementById('confirmNameBtn')?.click();
                                }
                            }
                        });
                    });
                } catch (e) { /* ignore a11y wiring errors */ }

                // 延後：優先嘗試載入外部經文資料，成功後再初始化跑馬燈（失敗則採用內建資料）
                try {
                    const kickoff = () => {
                        try { initializeVerseMarquee(); } catch(e){}
                        // 若已初始化，之後資料更新則只刷新內容，不重建 DOM
                        try { refreshVerseMarqueeData(); } catch(e){}
                    };
                    const loader = () => {
                        if (ENABLE_EXTERNAL_VERSES) {
                            attemptLoadExternalVerses().finally(kickoff);
                        } else {
                            // 直接使用內建資料
                            kickoff();
                        }
                    };
                    if ('requestIdleCallback' in window) {
                        window.requestIdleCallback(loader);
                    } else {
                        setTimeout(loader, 120);
                    }
                } catch(e){}
            });
        </script>
        <script>
            // Register a simple service worker to cache startup images and core assets for faster repeat visits
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', function() {
                    navigator.serviceWorker.register('sw.js', { scope: './' }).catch(function(_){});
                });
            }
        </script>
    </body>
    </html>
